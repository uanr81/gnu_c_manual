
@c This is part of The GNU C Reference Manual
@c Copyright (C) 2008-2016 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.

@c ----------------------------------------------------------------------------

@node Functions
@chapter Функции
@cindex functions

Можно написать функции для разделения частей программы на подпроераммы.
Чтобы написать функцию, необходимо, по крайней мере создать определение
функции.  Это хорошая идея также иметь явное объявление функции.  Это не
требуется в обязательном порядке, но неявное объявление по умолчанию может
не соответствовать самой функции, и во время компиляции могут возникнуть
предупреждения.

В каждой программе требуется, по меньшей мере, одна функция, которая
именуется @code{main}.  То есть, место с чего начинается выполнение
программы.

@menu
* Function Declarations::
* Function Definitions::
* Calling Functions::
* Function Parameters::
* Variable Length Parameter Lists::
* Calling Functions Through Function Pointers::
* The main Function::
* Recursive Functions::
* Static Functions::
* Nested Functions::
@end menu

@c ----------------------------------------------------------------------------

@node Function Declarations
@section Объявление Функции
@cindex function declarations
@cindex declarations, function

В объявление функции, указывается имя функции, список параметров и
тип возвращаемого функцией значения.  Объявление функции заканчивается точкой
с запятой.  Вот общий вид:

@example
@group
@var{тип-возвращаемого-значения} @var{имя-функции} (@var{список-параметров});
@end group
@end example

@var{тип-возвращаемого-значения} указывает тип данных значения, возвращаемого
функцией.  Можно объявить функцию, которая не возвращает ничего, используя
тип возвращаемого значения @code{void}.

@var{имя-функции} может быть любой допустимый идентификатор
(@pxref{Identifiers}).

@var{список-параметров} состоит из нуля или более параметров, разделенных
запятыми.  Типичный запись параметра состоит из типа данных и необязательного
имени параметра.  Также объявляется функция, которая имеет переменное число
параметров (@pxref{Variable Length Parameter Lists}), или не содержит совсем
параметров, отмечается с помощью @code{void}.  Полностью отсутствующий
@var{список-параметров}, также указывает на то, что функция не использует
никаких параметров, но лучше явное указание отсутствия с помощью @code{void}.

Вот пример объявления функции с двумя параметрами:

@example
@group
int foo (int, double);
@end group
@end example

Если включить имя параметра, имя следует непосредственно после указания
типа данных, например:

@example
@group
int foo (int x, double y);
@end group
@end example

Имя параметра может быть любой идентификатор (@pxref{Identifiers}), и если
есть более одного параметра, нельзя использовать одно и то же имя, более
одного раза в одном объявлении.  Имена параметров в объявлении не обязательно
должны совпадать с именами в определении.

Объявление функции требуется до первого использования этой функции.  Можне
поместить его в заголовочный файл и использовать директиву @code{#include},
чтобы включить объявление этой функцию в любых файлах исходного кода, которые
используют функцию.

@c -------------------------------------------------------------------------

@node Function Definitions
@section Определение функции
@cindex function definitions
@cindex definitions, function

Определение функции, служит для того, чтобы указать, что функция на самом
деле делает.  Определение функции состоит из информации о имени функции, типа
возвращаемого значения и типов и именах параметров, вместе с телом функции.
Тело функции представляет собой ряд инструкций, заключенных в скобки, на
самом деле это просто блок (@pxref{Blocks}).

Вот общий вид определения функции:

@example
@group
@var{тип-возвращаемого-значения}
@var{имя-функции} (@var{список-параметров})
@{
  @var{тело-функции}
@}
@end group
@end example

@var{тип-возвращиемого-значения} и @var{имя-функции} такие же, как
используются в объявлении функции (@pxref{Function Declarations}).
@var{список-параметров} такой же, как и список параметров, используемый в
объявлении функции (@pxref{Function Declarations}), за исключением того,
что @emph{обязательно} включаются имена параметров в определении функции.

Вот простой пример определения функции --- она ​​принимает два целых числа,
в качестве её параметров и возвращает их сумму в качестве возвращаемого
значения:

@example
@group
int
add_values (int x, int y)
@{
  return x + y;
@}
@end group
@end example

Для совместимости с оригинальным C, также требуется указать тип параметров
функции @emph{после} закрывающей скобкой списка параметров, так:

@example
@group
int
add_values (x, y)
    int x, int y;
@{
  return x + y;
@}
@end group
@end example

@noindent
Тем не менее, не рекомендуется этот стиль кодирования; это может вызвать
тонкие проблемы с приведением типов, наряду с другими проблемами.

@c --------------------------------------------------------------------------

@node Calling Functions
@section Вызов Функции
@cindex calling functions
@cindex functions, calling

Можно вызвать функцию, используя её имя и передав значения параметров.
Вот общий вид вызова функции:

@example
@var{имя-функции} (@var{параметры})
@end example

Вызов функции может составить целую инструкцию, или может быть использован в
качестве подвыражения.  Вот пример полной инструкции вызова функции:

@example
@group
foo (5);
@end group
@end example

@noindent
В этом примере функция @samp{foo} вызывается с параметром @code{5}.

Ниже приведен пример вызова функции, используемый в качестве подвыражения:

@example
@group
a = square (5);
@end group
@end example

@noindent
Предпологая, что функция @samp{square} возводит в квадрат ее параметр,
приведенный выше пример присваивает значение 25 переменной @code{a}.

Если список параметров принимает более одного аргумента, то отдельные
параметры разделяются запятой:

@example
@group
a = quux (5, 10);
@end group
@end example 

@c ----------------------------------------------------------------------------

@node Function Parameters
@section Параметры Функции
@cindex function parameters
@cindex parameters, function

Параметр функции может быть любым выражением --- буквальным значением,
значением, сохраненным в переменной, адресом в памяти, или более сложным
выражением путём объединения этого.

В теле функции, параметр является локальной копией значения, переданного в
функцию, поэтому нельзя изменить само переданное параметром значение, изменяя
его локальную копию.

@example
int x = 23;
foo (x);
@dots{}
/* @r{Определение функции @code{foo}.} */
int foo (int a)
@{
  a = 2 * a;
  return a;
@}
@end example

@noindent
В этом примере, даже если @code{a} параметр изменяется в функции @samp{foo},
переменная @code{x}, которая передается функции как параметр не меняется.
Если требуется использовать функцию, чтобы изменить исходное значение
@code{x}, используется вызов функции в операторе присваивания:

@example
x = foo (x);
@end example

Если значение, передаваемое функции в качестве параметра является адресом
памяти (то есть указателем), то можно получить доступ (и изменить) данные,
хранящиеся в памяти по адресу.  Благодаря этому достигается эффект, схожий
передачи в параметре по ссылке в других языках, но это не то же самое: адрес
в памяти - это просто значение, так же как и любое другое значение, и само
по себе не может быть изменено.  Разница между передачей указателя и
передачи целого числа состоим в том, что можно использовать значение
указателя в пределах тела функции.

Вот пример вызова функции в качестве указателя в параметре:

@example
@group
void
foo (int *x)
@{
  *x = *x + 42;
@}
@dots{}
int a = 15;
foo (&a);
@end group
@end example

@noindent
Формальный параметр для функции имеет тип указатель-на-тип-@code{int}, и
функция вызывается с передачей в качестве параметра значения адреса
переменной типа @code{int}.  Разыменовав указатель в пределах тела функции,
можно получить и изменить значение, находящееся по значению адреса.  Выше
изменяется значение переменной @code{a} в значение @samp{57}.

Даже если не требуется изменение значения, сохраненного в адресе, передавая
адрес переменной, а не саму переменную саму по себе, может быть полезным,
если тип переменной слишком велик, и необходима экономия памяти или
ограничить влияние на производительность при копировании параметра.
Например:

@example
@group
struct foo
@{
  int x;
  float y;
  double z;
@};

void bar (const struct foo *a);
@end group
@end example

@noindent
В том случае, если работа выпролняется на компьютере с не очень большими
адресами памяти, он будет занимать меньше памяти, передача указателя на
структуру, чем передача экземпляря структуры.

Один из типов параметров, который всегда передаётся как указатель - это любой
вид массива:

@example
@group
void foo (int a[]);
@dots{}
int x[100];
foo (x);
@end group
@end example

@noindent
В этом примере, вызов функции @code{foo} с параметром @code{a} не производит
копированее всего массива в локальную переменную параметра @code{foo},
передаётся в параметре @code{x} указатель на первый элемент массива @code{x}.
Нужно проявлять осторожность: в пределах функции, нельза использовать
@code{sizeof}, чтобы определить размер массива @code{x}---@code{sizeof}
вместо этого укажет размер указателя @code{x}.  Действительно, указаный выше
код эквивалентен:

@example
@group
void foo (int *a);
@dots{}
int x[100];
foo (x);
@end group
@end example

@noindent Явное указание длины массива в объявлении параметра не поможет.
Если действительно нужно передать массив по значению, можно обернуть его в
@code{struct}, хотя это редко бывает полезно (обычно достаточно передавать
указатель с @code{const}-спецификатором, чтобы показать, что вызваший код
не должен изменять массив).

@c --------------------------------------------------------------------------

@node Variable Length Parameter Lists
@section Список Параметров Функции Переменной Длинны
@cindex variable length parameter lists
@cindex parameters lists, variable length
@cindex function parameter lists, variable length

Можно написать функцию, которая принимает переменное число аргументов, такие
функции называются @dfn{вариативными функциями}.  Чтобы получить это, функция
должна иметь, по меньшей мере, один параметр известного типа данных, а
остальные параметры являются необязательными и могут различаться по
количеству и типу данных.

Перечисляются начальные параметры, как обычно, но после этого, используется
многоточие: @samp{...}.  Вот пример прототипа функции:

@example
int add_multiple_values (int number, ...);
@end example

Для работы с дополнительными параметрами в определении функции, нужно
использовать макросц, которые определены в библиотеке заголовочного файла
@samp{<stdarg.h>}, так что требуется включить @code{#include} этот файл.
Подробное описание этих макросов, раздел @cite{The GNU C Library}
руководства по переменному числу параметров функций.

@comment Выше указанный пункт ранее имел надлежащую @ref ссылку на раздел
@comment GLIBC в этом вопросе, но это похоже, не отрабатывает правильно, по
@comment крайней мере, в HTML.  Замените @cite на @ref; не стесняйтесь
@comment позже.

Вот пример:

@example
int
add_multiple_values (int number, ...)
@{
  int counter, total = 0;
  
  /* @r{Объявляется переменная типа @samp{va_list}.} */
  va_list parameters;

  /* @r{Вызов функции @samp{va_start}.} */
  va_start (parameters, number);

  for (counter = 0; counter < number; counter++)
    @{
      /* @r{Получение значений дополнительных параметров.} */
      total += va_arg (parameters, int);
    @}

  /* @r{Итоговое присвоение переменной @samp{parameters}.} */
  va_end (parameters);

  return total;
@}
@end example

@c Нужно описать применения правила по передаче по умолчанию
@c к параметрам, передаваемым в ``...''.

Для использования дополнительных параметров, нужно знать, сколько их есть.
Это количество может варьироваться, поэтому не задаётся жестко, но
если не известно точное количество необязательных параметров, то могут
возникнуть трудности, когда требуется прекратить использование функции
@samp{va_arg}.  В приведенном выше примере, первый параметр функции
@samp{add_multiple_values}, @samp{number}, это количество для передачи
необязательных параметров.  Таким образом, можно вызвать функцию так:

@example
sum = add_multiple_values (3, 12, 34, 190);
@end example

Первый параметр указывает на то, сколько дополнительных параметров следуют
за ним.

Кроме того, можно обратить внимание, что на самом деле не нужно использовать
функцию @samp{va_end}.  В самом деле, при использовании GCC совсем ничего
не произойдёт.  Тем не менее, можно включить это для обеспечения максимальной
совместимости с другими компиляторами.

@xref{Variadic Functions, Variadic Functions, Variadic Functions, libc, The GNU C Library Reference Manual}.

@node Calling Functions Through Function Pointers
@section Вызов Функции Через Указатель на Функцию
@cindex function pointers, calling through

Можно также вызвать функцию, используя на неё указателя.  Оператор
разыменования @code{*} не является обязательным при выполнении этого.

@example
@group
#include <stdio.h>

void foo (int i)
@{
  printf ("foo %d!\n", i);
@}
@end group

@group
void bar (int i)
@{
  printf ("%d bar!\n", i);
@}
@end group

@group
void message (void (*func)(int), int times)
@{
  int j;
  for (j=0; j<times; ++j)
    func (j);  /* (*func) (j); будет эквивалентно. */
@}

void example (int want_foo) 
@{
  void (*pf)(int) = &bar; /* The & is optional. */
  if (want_foo)
    pf = foo;
  message (pf, 5);
@}
@end group
@end example 

@c -------------------------------------------------------------------------

@node The main Function
@section Функция @code{main}
@cindex main function
@cindex function, main

Каждая программа требует, по меньшей мере, одну функцию, которая имеет имя
@samp{main}.  Это то, где программа начинает выполняться.  Не нужно писать
объявление или прототип функции @code{main}, но требуется определить её.

Возвращаемый тип значения функции @code{main} всегда тип @code{int}.  Не
требуется обязательно указывать тип возвращаемого значения @code{main}, но
можно.  Тем не менее, @emph{нельзя} указать, что возвращаемое значение имеет
тип отличныей от @code{int}.

@c ??? Реализациями разрешено поддерживать альтернативные типы. 

@cindex exit status
@cindex @code{EXIT_FAILURE}
@cindex @code{EXIT_SUCCESS}
@cindex return value of @code{main}

В общем, возвращаемое значение функцей @code{main} указывает
@dfn{статус возврата} программы.  Нулевое значение или EXIT_SUCCESS указывает
на успех и EXIT_FAILURE указывает на ошибку.  В противном случае, значение
возвращаемого значения зависит от реализации.

@c ??? Не определяется здесь.

Достижение выполнением программы @code{@}} в конце тела функции @code{main}
без указания возврата значения или использовании @code{return} без указания
возвращаемого значения (то есть, @code{return;}) являются эквивалентными.  В
C89, эффект этого не определен, но в C99 эффект эквивалентен вызову
@code{return 0;}.

Можно написать функцию @code{main} не имеющую никаких параметров (то есть,
как @code{int main (void)}), или принимающую параметры из командной строки.
Вот очень простая функция @code{main} без параметров:

@example
@group
int
main (void)
@{
  puts ("Всем привет!");
  return 0;
@}
@end group
@end example

Чтобы принять параметры командной строки, необходимо иметь два параметра в
функции @code{main}, @code{int argc} с последующим @code{char *argv[]}.
Можно изменить имена этих параметров, но они должны иметь типы
данных---@code{int} и массив указателей на тип @code{char}.  @code{argc}
указывает количество параметров командной строки, в том числе параметр с
именем самой программы.  @code{argv} представляет собой массив параметров,
как строки символов.  @code{argv[0]}, первый элемент в массиве, это имя
программы, как и набирается в командной строке@footnote{Редко, @code{argv[0]}
может быть NULL указателем (в этом случае @code{argc} это 0) или
@code{argv[0][0]} может быть нулевым символом.  В любом случае,
@code{argv[argc]} является NULL указателем.}; любые следующие элементы
массива являются параметрами, которые следуют за именем программы.

Ниже приведен пример функции @code{main}, которая принимает параметры
командной строки, и выводит то, что передаётся этими параметрами:

@example
@group
int
main (int argc, char *argv[])
@{
  int counter;

  for (counter = 0; counter < argc; counter++)
    printf ("%s\n", argv[counter]);
  
  return 0;
@}
@end group
@end example

@c ----------------------------------------------------------------------------

@node Recursive Functions
@section Рекурсивные Функции
@cindex recursive functions
@cindex functions, recursive

Можно написать функцию, которая является рекурсивной --- функцией, которая
вызывает саму себя.  Ниже приведен пример, вычисления факториала целого
числа:

@example
int
factorial (int x)
@{
  if (x < 1)
    return 1;
  else
    return (x * factorial (x - 1));
@}
@end example

Нужно быть осторожным, что не написать функцию, которая является бесконечно
рекурсивной.  В приведенном выше примере, как только @code{x} равно 1, то
рекурсия останавливается.  Однако, в следующем примере, рекурсия не
останавливается, пока программа не будет прервана принудительно или пока не
произойдёт переполнение памяти:

@example
@group
int
watermelon (int x)
@{
  return (watermelon (x));
@}
@end group
@end example

Функции могут быть конечно косвенно рекурсивными.  (ВопросFunctions579)

@c --------------------------------------------------------------------------

@node Static Functions
@section Статические Функции
@cindex static functions
@cindex functions, static
@cindex static linkage

Можно определить статическую функцию, если требуется совершать её вызов из
любого места в пределах исходного файла, в котором она определена:

@example
@group
static int
foo (int x)
@{
  return x + 42;
@}
@end group
@end example

@noindent
Это полезно, если строится библиотека многоразового использования функций и
она включает в себя некоторые подпрограммы, которые не должно быть вызваны
конечным пользователем.

Функции, которые определены таким образом, имеют так сказать,
@dfn{статическую связь}.  К сожалению, @code{static} ключевое слово имеет
несколько значений; @ref{Storage Class Specifiers}.

@c --------------------------------------------------------------------------

@node Nested Functions
@section Вложенные Функции
@cindex nested functions
@cindex functions, nested
 
В качестве расширения GNU C, можно определить функции внутри других функций,
метод, известный как вложенности функций.
 
Ниже приведен пример функции факториала хвостовой рекурсии, определенной с
помощью вложенной функции:
 
@example
@group
int
factorial (int x)
@{
  int
  factorial_helper (int a, int b)
  @{
    if (a < 1)
    @{
      return b;
    @}
    else
    @{
      return factorial_helper ((a - 1), (a * b));
    @}
  @}

 return factorial_helper (x, 1);
@}
@end group
@end example

Внимание, вложенные функции должны быть определены вместе с объявлениями
переменных в начале функции, а все остальные инструкции следуют строго после.
