@node Overflow
@appendix Переполнение

@c большая часть этого текста взята из руководства Autoconf. Формулировка
@c в основном от Paul Eggert.

[Это приложение, написанное в основном Полом Эггертом, взято из
руководства GNU Autoconf.  Мы подумали, что было бы полезно включить
сюда. --TJR]

На практике многие переносимые программы на C предполагают, что знаковое
целочисленное переполнение надежно оборачивается с использованием арифметики
с дополнением до двух.  Тем не менее, в стандарте C говорится, что поведение
программы при переполнении не определено, и в некоторых случаях программы на
C не работают в некоторых современных реализациях, потому что их переполнениене обрабатывается, как ожидали их авторы.  И наоборот, в целочисленном
остатке со знаком стандарт C требует поведения переполнения, которое обычно
не реализуется.  (ВопросOverflow17)

@menu
* Integer Overflow Basics::      Почему целочисленное переполнение - проблема
* Signed Overflow Examples::     Примеры кода, предполагающие переплнение
* Optimization and Wraparound::  Оптимизация, нарушающая циклические
                                 обработки
* Signed Overflow Advice::       Практические советы по вопросам
                                 подписанного переполнения
* Signed Integer Division::      @code{INT_MIN / -1} и @code{INT_MIN % -1}
@end menu

@node Integer Overflow Basics
@appendixsection Основы Целочисленного Переполнения
@cindex integer overflow
@cindex overflow, signed integer
@cindex signed integer overflow
@cindex wraparound arithmetic

В таких языках, как C, беззнаковое целочисленное переполнение надежно
оборачивается; например, @code{UINT_MAX + 1} дает ноль.  Это гарантируется
стандартом C и переносимо на практике, если не указаны агрессивные
нестандартные параметры оптимизации, подходящие только для специальных
приложений.

Напротив, стандарт C говорит, что целочисленное переполнение со знаком
приводит к неопределенному поведению, когда программа может делать что
угодно, включая сброс ядра или переполнение буфера.  Плохое поведение может
даже предшествовать переполнению.  Такое переполнение может произойти во
время сложения, вычитания, умножения, деления и сдвига влево.

Несмотря на это требование стандарта, многие программы на C предполагают, что
подписанное целочисленное переполнение молча оборачивается по модулю двойки,
используя арифметику дополнения до двух, если приводится полученное значение
к целочисленному типу со знаком или сохраняется в целочисленной переменной со
знаком.  Если используются консервативные флаги оптимизации, такие программы
обычно переносимы на подавляющем большинстве современных платформ, за
некоторыми исключениями, обсуждаемыми позже.

По историческим причинам стандарт C также допускает реализации с дополнением
до единици или знаковой величиной арифметики, но в настоящее время можно с
уверенностью предполагать дополнение до двух.

Кроме того, переполнение может произойти при преобразовании значения вне
допустимого диапазона в целочисленный тип со знаком.  Здесь стандартная
реализация должна определять, что происходит, но это может включать в себя
создание исключения.  На практике все известные реализации в этом случае
поддерживают обход без вывода сообщений, поэтому не нужно беспокоиться о
других возможностях.

@node Signed Overflow Examples
@appendixsection Примеры Кода, Предполагающего Переполнение Цикла
@cindex integer overflow
@cindex overflow, signed integer
@cindex signed integer overflow
@cindex wraparound arithmetic

Уже давно существует противоречие между тем, что стандарт C требует для
целочисленного переполнения со знаком, и тем, что обычно предполагают
программы C.  Стандарт допускает агрессивную оптимизацию, основанную на
предположении, что переполнение никогда не происходит, но многие практические
программы на C полагаются на обертывание переполнения.  Эти программы не
соответствуют стандарту, но они обычно работают на практике, потому что
авторы компиляторов по понятным причинам не хотят реализовывать оптимизацию,
которая нарушит работу многих программ, если, возможно, пользователь не
укажет агрессивную оптимизацию.

Стандарт C говорит, что если программа имеет целочисленное переполнение со
знаком, ее поведение не определено, а неопределённое поведение может даже
свидеьельствовать переполнению.  Возьмем крайний пример:

@c Вдохновленный примером Роберта Дьюара в
@c <http://gcc.gnu.org/ml/gcc/2007-01/msg00038.html> (2007-01-01).
@example
if (password == expected_password)
  allow_superuser_privileges ();
else if (counter++ == INT_MAX)
  abort ();
else
  printf ("%d несоответствие паролей\n", counter);
@end example

@noindent
Если переменная типа @code{int} @code{counter} равняется @code{INT_MAX},
@code{counter++} приведёт к переполнению и поведение станет неопределённым,
поэтому стандарт C позволяет компилятору оптимизировать условие
@code{(counter++ == INT_MAX)} и вызов @code{abort}.  Хуже того, если более
ранняя ошибка в программе позволяет компилятору сделать вывод о том, что
@code{counter == INT_MAX} или @code{counter} уже привело к переполнению,
стандарт C позволяет компилятору оптимизировать проверку пароля и
генерировать код, который безоговорочно разрешает привилегии
суперпользователя.

Несмотря на это требование стандарта, код C долгое время предполагал
циклическую арифметику после подписанного переполнения, и все известные
практические реализации C поддерживают некоторые идиомы C, которые
предполагают циклическую арифметику со знаком, даже если идиомы не
соответствуют строго стандарту.  Если ваш код похож на следующие примеры, он
почти наверняка будет работать с реальными компиляторами.

Вот пример, полученный из реализации @code{atoi} для Unix 7-го издания.
(1979-01-10):

@example
char *p;
int f, n;
@dots{}
while (*p >= '0' && *p <= '9')
  n = n * 10 + *p++ - '0';
return (f ? -n : n);
@end example

@noindent
Даже если входная строка находится в пределах допустимого диапазона, на
большинстве современных машин это имеет знаковое переполнение при вычислении
самого отрицательного целого числа (переполнение @code{-n}) или значения,
близкого к крайнему целому числу (переполнение первого @code{+}).

Вот еще один пример, полученный из реализации @code{rand} 7-го издания
(1979-01-10).  Здесь программист ожидает, что и умножение, и сложение
обернутся при переполнении:

@example
static long int randx = 1;
@dots{}
randx = randx * 1103515245 + 12345;
return (randx >> 16) & 077777;
@end example

В следующем примере, полученном из реализации @code{mktime} библиотеки 2.5
@acronym{GNU} C (2009-09-09), код предполагает циклическую арифметику в
@code{+} для обнаружения подписанного переполнения:

@example
time_t t, t1, t2;
int sec_requested, sec_adjustment;
@dots{}
t1 = t + sec_requested;
t2 = t1 + sec_adjustment;
if (((t1 < t) != (sec_requested < 0))
    || ((t2 < t1) != (sec_adjustment < 0)))
  return -1;
@end example

Если код выглядит как эти примеры, он, вероятно, безопасен, даже если он не
строго соответствует стандарту C.  Это может привести к мысли, что обычно
можно предполагать циклический переход при переполнении, но это не всегда
верно, как можно увидеть в следующем разделе.

@node Optimization and Wraparound
@appendixsection Оптимизация, Которые Нарушают Циклическую Арифметику
@cindex loop induction

Компиляторы иногда создают код, несовместимый с циклической целочисленной
арифметикой.  Простым примером является алгебраическое упрощение: компилятор
может преобразовать @code{(i * 2000) / 1000} в @code{i * 2}, потому что он
предполагает, что @code{i * 2000} не переполняется.  Перевод не эквивалентен
оригиналу, когда происходит переполнение: например, в типичном случае
32-битного подписанного двойного дополнения обертывания @code{int}, если
@code{i} имеет тип @code{int} и значение @code{1073742}, исходное выражение
возвращает @minus{}2147483, но оптимизированная версия возвращает
математически правильный значение 2147484.

Более тонко, оптимизации индукции цикла часто используют неопределенное
поведение подписанного переполнения.  Рассмотрим следующую надуманную
функцию @code{sumc}:

@example
int
sumc (int lo, int hi)
@{
  int sum = 0;
  int i;
  for (i = lo; i <= hi; i++)
    sum ^= i * 53;
  return sum;
@}
@end example

@noindent
Чтобы избежать умножения на 53 при каждом прохождении цикла, оптимизирующий
компилятор может внутренне преобразовать @code{sumc} в эквивалент следующего:

@example
int
transformed_sumc (int lo, int hi)
@{
  int sum = 0;
  int hic = hi * 53;
  int ic;
  for (ic = lo * 53; ic <= hic; ic += 53)
    sum ^= ic;
  return sum;
@}
@end example

@noindent
Это преобразование разрешено стандартом C, но недопустимо для арифметики с
циклическим переносом при @code{INT_MAX / 53 < hi}, потому что в этом случае
переполнение в вычислительных выражениях, таких как @code{hi * 53}, может
привести к тому, что выражение @code{i <= hi} даст значение, отличное от
преобразованного выражения @code{ic <= hic}.

По этой причине компиляторы, которые используют индукцию цикла и аналогичные
методы, часто не поддерживают надежную арифметику цикла, когда задействована
переменная индукции цикла, такая как @code{ic}. Поскольку переменные индукции
цикла генерируются компилятором и не отображаются в исходном коде, не всегда
легко сказать, влияет ли проблема на ваш код.  (ВопросOverflow224)

Вряд ли какой-либо код на самом деле зависит от арифметики циклического
преобразования в подобных случаях, поэтому на практике эти оптимизации
индукции цикла почти всегда полезны.  Однако крайние случаи в этой области
могут вызвать проблемы.  Например:

@example
int j;
for (j = 1; 0 < j; j *= 2)
  test (j);
@end example

@noindent
Здесь цикл пытается перебрать все степени двойки, которые может представлять
@code{int}, но стандарт C позволяет компилятору оптимизировать сравнение и
сгенерировать бесконечный цикл при условии, что поведение не определено при
переполнении.  На момент написания этой статьи эта оптимизация не
производилась ни одной производственной версии @acronym{GCC} с @option{-O2},
но могла выполняться другими компиляторами или более агрессивными вариантами
оптимизации @acronym{GCC}, и разработчики @acronym{GCC} не решили, будет ли
она продолжать работать с @acronym{GCC} и @option{-O2}. .

@node Signed Overflow Advice
@appendixsection Практические Советы по Вопросам Подписанного Переполнения
@cindex integer overflow
@cindex overflow, signed integer
@cindex signed integer overflow
@cindex wraparound arithmetic

В идеале самый безопасный подход - полностью избежать переполнения целых
чисел со знаком.  Например, вместо умножения двух целых чисел со знаком вы
можете преобразовать их в целые числа без знака, умножить значения без знака,
а затем проверить, находится ли результат в диапазоне со знаком.

Однако переписывать код таким образом будет неудобно, особенно если значения
со знаком могут быть отрицательными.  Кроме того, это может снизить
производительность.  Использование беззнаковой арифметики для проверки
переполнения особенно болезненно при переносимости и эффективности при работе
с целочисленными типами, такими как @code{uid_t}, ширина и подписи которых
варьируются от платформы к платформе.

Более того, многие приложения C повсеместно предполагают циклическое
поведение, и обычно нелегко найти и удалить все эти предположения.
Следовательно, вместо того, чтобы переписывать код, часто бывает полезно
поддерживать нестандартный код, предполагающий циклический переход при
переполнении.  В оставшейся части этого раздела делается попытка дать
практические советы для этой ситуации.

Если ваш код хочет обнаружить целочисленное переполнение со знаком в
@code{sum = a + b}, обычно безопасно использовать выражение, подобное
@code{(sum < a) != (b < 0)}.

Если в вашем коде используется индекс цикла со знаком, убедитесь, что индекс
не может переполниться вместе со всеми выражениями со знаком, полученными из
индекса.  Вот надуманный пример проблемного кода с двумя случаями
переполнения.

@example
for (i = INT_MAX - 10; i <= INT_MAX; i++)
  if (i + 1 < 0)
    @{
      report_overflow ();
      break;
    @}
@end example

@noindent
Из-за двух переполнений компилятор может оптимизировать или преобразовать
два сравнения способом, несовместимым с допущением обертывания.

Если в коде используется такое выражение, как @code{(i * 2000) / 1000}, и
действительно требуется, чтобы умножение повторялось при переполнении,
используется для этого беззнаковая арифметика, например,
@code{((int) (i * 2000u)) / 1000}.

Если код предполагает циклическое поведение и нужно изолировать его от любых
оптимизаций @acronym{GCC}, которые не смогут поддерживать это поведение,
огда используется опция @acronym{GCC}'s @option{-fwrapv}, которая заставляет
подписанное переполнение надежно переноситься (за исключением омтатка от
деления, как обсуждается в следующем раздел).

Если нужно выполнить перенос на платформы, где подписанное целочисленное
переполнение не надежно завершается (например, из-за проверки аппаратного
переполнения или из-за очень агрессивных оптимизаций), следует рассмотреть
возможность отладки с опцией @acronym{GCC}'s @option{-ftrapv}, которая
вызывает подписанное переполнение, вызывающее исключение.

@node Signed Integer Division
@appendixsection Целочисленное Деление со Знаком и Целочисленное Переполнение
@cindex division, integer

Переполнение при целочисленном делении со знаком не всегда безобидно:
например, на процессорах семейства i386 деление @code{INT_MIN} на @code{-1}
дает сигнал SIGFPE, который по умолчанию завершает программу.  Хуже того,
получение оставшейся части этих двух значений обычно дает один и тот же
сигнал для этих процессоров, даже несмотря на то, что стандарт C требует, что
бы @code{INT_MIN % -1} возвращал ноль, потому что выражение не переполняется.
