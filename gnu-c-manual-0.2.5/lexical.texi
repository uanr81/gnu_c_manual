
@c This is part of The GNU C Reference Manual
@c Copyright (C) 2004-2009 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.

@node Lexical Elements
@chapter Лексические Элементы
@cindex lexical elements

В этой главе описывается лексические элементы, которые составляют исходный
код Cи после предварительной обработки.  Эти элементы называются
@dfn{токены}.  Есть пять типов токенов: ключевые слова, идентификаторы,
константы, операторы и разделители.  Пропуски, иногда требуется, чтобы
разделить отдельные лексемы, это всё описано в этой главе.

@menu
* Identifiers::
* Keywords::
* Constants::
* Operators::
* Separators::
* White Space::
@end menu


@node Identifiers
@section Идентификаторы
@cindex identifiers

Идентификаторы представляют собой последовательность символов, используются
для обозначения переменных, функций, новых типов данных и макросов
препроцессора.  Можно также включать в идентификаторы буквы, десятичные
цифры, и символ подчеркивания @samp{_}.

Первый символ идентификатора не может быть цифрой.

Строчные буквы и прописные буквы различаются, так что @code{foo} и @code{FOO}
два разных идентификатора.

При использовании расширений GNU, вы можете также включать символ @samp{$}
(знак доллара) в идентификаторах.


@node Keywords
@section Ключевые Слова
@cindex keywords

Ключевые слова являются специальными идентификаторами зарезервироваными для
использования в качестве части самого языка программирования.  Вы не можете
использовать их для любых других целей.  

Вот список ключевых слов признан ANSI C89:

@example
auto break case char const continue default do double else enum extern
float for goto if int long register return short signed sizeof static
struct switch typedef union unsigned void volatile while
@end example

@noindent
ISO C99 добавляет следующие ключевые слова:

@example
inline _Bool _Complex _Imaginary
@end example

@noindent
и расширение GNU добавляет эти ключевые слова:

@example
__FUNCTION__ __PRETTY_FUNCTION__ __alignof __alignof__ __asm
__asm__ __attribute __attribute__ __builtin_offsetof __builtin_va_arg
__complex __complex__ __const __extension__ __func__ __imag __imag__ 
__inline __inline__ __label__ __null __real __real__ 
__restrict __restrict__ __signed __signed__ __thread __typeof
__volatile __volatile__ 
@end example

@noindent
В обоих ISO C99 и C89 с расширениями GNU, следующее также признаётся в
качестве ключевого слова:
@example
restrict
@end example

@node Constants
@section Constants
@cindex constants

Константа является буквальным числовым или символьным значением, например,
@code{5} или @code{'m'}.  Все константы относятся к конкретному типу данных;
Вы можете использовать явное приведение типов для указания типа константы или
позволить компилятору использовать тип по умолчанию на основе значения
константы.

@menu 
* Integer Constants::
* Character Constants::
* Real Number Constants::
* String Constants::
@end menu


@node Integer Constants
@subsection Целочисленные Константы
@cindex integer constants
@cindex constants, integer

Целочисленная константа представляет собой последовательность цифр, с
необязательным префиксом для обозначения системы счисления.

Если последовательности цифр предшествует @code{0x} или @code{0X} (ноль или
ноль затем X), то константа считается шестнадцатеричным (основание 16).
Шестнадцатеричные значения используют цифры от 0 до 9, а также буквы от
@code{a} до @code{f} и от @code{A} до @code{F}.  Вот некоторые примеры:

@example
@group
0x2f
0x88
0xAB43
0xAbCd
0x1
@end group
@end example

Если первая цифра 0 (ноль), а следующий символ не является @samp{x} или
@samp{X}, то константа считается восьмеричной (основание 8).  Восьмеричные
значения могут использовать только цифры от 0 до 7, 8 и 9 не допускаются.
Вот некоторые примеры:

@example
@group
057
012
03
0241
@end group
@end example

Во всех других случаях последовательность цифр считается десятичной
константой (основание 10).  Десятичные значения могут состоять из цифр от 0
до 9.  Ниже приведены некоторые примеры:

@example
@group
459
23901
8
12
@end group
@end example

Существуют различные типы целочисленных данных, для коротких целых, длинных
целых чисел, целых чисел и целых чисел без знака.  Вы можете заставить целую
константу быть длинным типом и/или целым числом без знака, добавив к
последовательности одну или несколько букв из следующего списка в конце
константы:
@table @code

@item u
@itemx U
Целочисленный тип без знака.

@item l
@itemx L
Длинный целочисленный тип.

@end table

 Например, @code{45U} является константой с типом значения
 @code{unsigned int (беззнаковое целочисленное)}.  Вы также можете
 комбинировать буквы: @code{45UL} - указывает тип значения константы как
 @code{беззнаковое длинное целочисленное}.  (Буквы могут быть использованы в
 любом порядке.)

Оба расширения ISO C99 и GNU C добавляют целочисленные типы
@code{long long int} (целочисленное двойной длинны) и
@code{unsigned long long int} (беззнаковое целочисленное двойной длинны).
Вы можете использовать два @samp{L}s, чтобы получить константу
@code{long long int}; и добавить @samp{U} тогда, кода константа является
@code{unsigned long long int}. Например: @code{45ULL}.


@node Character Constants
@subsection Character Constants
@cindex character constants
@cindex constants, character

Символьная константа характер, как правило, это один символ, заключенный в
одинарные кавычки, например, @code{'Q'}.  Символьная константа имеет тип
@code{int} по умолчанию.

Некоторые символы, такие как одиночная кавычка, не могут быть представлены
только самим буквальным символом.  Для представления таких символов, есть
несколько ``escape последовательностей'', которые вы можете использовать:


@table @code

@item \\
Символ обратной косой черты.

@item \?
Символ вопросительный знак.

@item \'
Символ одинарная кавычка.

@item \"
Символ двойные кавычки.

@item \a
Звуковое оповещение.

@item \b
Символ возврата на одну позицию.

@item \e
<ESC> символ.  (GNU расширение.)

@item \f
Перевод страницы.

@item \n
Символ новой строки.

@item \r
Возврат каретки.

@item \t
Горизонтальная табуляция.

@item \v
Вертикальная табуляция.

@item \o, \oo, \ooo
Восьмеричное число.

@item \xh, \xhh, \xhhh, @dots{}
Шестнадцатеричное число.

@end table

Чтобы использовать любую из этих управляющих последовательностей, заключите
последовательность в одинарные кавычки, и относитесь к этому, как будто это
обычный другой символ.  Например, буква м является @code{'м'} и символ новой
строки @code{'\n'}.

Восьмеричная escape-последовательность - это символ обратной косой черты, за
которым следует один, два или три восьмеричных цифры (от 0 до 7).  Так,
например, 101 восьмеричный эквивалент 65, который является ASCII-символом
@code{'A'}.  Таким образом, символьная константа @code{'101'} является тем
же внутренним значением что и символьная константа @code{'A'}.

Шестнадцатеричная escape-последовательность состоит из символа обратной косой
черты, за которым следует @code{x} и неограниченное количество
шестнадцатеричных цифр (цифры от 0 до 9, и буквы от @code{a} до @code{f} и
от @code{A} до @code{F}).

В то время как длина строки возможных шестнадцатеричных цифр не ограничена,
количество символьных констант в любом заданном наборе символов ограничено.
(Широко используется расширенный набор ASCII символов, он например, имеет
в составе только 256 символов.)  Если вы пытаетесь использовать
шестнадцатеричное значение, которое находится вне диапазона символов, вы
получите ошибку компиляции.


@node Real Number Constants
@subsection Константы Вещественных Чисел
@cindex floating point constants
@cindex constants, floating point
@cindex real number constants
@cindex constants, real number

Константа вещественного числа является значением, которое представляет собой
дробное (с плавающей точкой) число.  Она состоит из последовательности цифр,
которые представляет собой целое число (или) ``целую'' часть числа,
десятичную точку, и последовательность цифр, которая представляет собой
дробную часть числа.

Либо часть числа, целая или дробная часть, может быть опущена, но не обе
сразу.  Вот несколько примеров:


@example
@group
double a, b, c, d, e, f;

a = 4.7;

b = 4.;

c = 4;

d = .7;

e = 0.7;
@end group
@end example

@noindent
(В третьем операторе присваивания целая константа 4 автоматически
преобразуется из целочисленного значения до значения числа с плавающей
точкой.)

Константа вещественного числа, также может дополнятся @code{e} или @code{E}
целочисленными показателями.  Показатель может быть положительным или
отрицательным.


@example
@group
double x, y;

x = 5e2;   /* @r{@code{x} is 5 * 100, or 500.0.} */
y = 5e-2;  /* @r{@code{y} is 5 * (1/100), or 0.05.} */
@end group
@end example

Вы можете добавить букву в конце константы вещественного числа, чтобы
определить её тип.  Если добавить букву F (или f) к константе вещественоого
числа, то её тип будет @code{float}.  Если добавить букву L (или l), то её
тип станет @code{long double}.  Если вы не добавляете любые буквы, то её тип
будет @code{double}.


@node String Constants
@subsection Строковые Константы
@cindex string constants
@cindex string literals

Строковая константа представляет собой последовательность из нуля или более
символов, цифр и управляющих последовательностей, заключенных в двойные
кавычки.  Строковая константа имеет тип ``массив символов''.  Все строковые
константы содержат завершающий нулевой символ (@code{\0}) в качестве
последнего символа.  Строки хранятся в виде массива символов, без
неотъемлемого атрибута размера.  Завершающий нулевой символ позволяет
строковым функциям при обработке знать, где строка заканчивается.

Смежные строковые константы сцепляются (объединяются) в одну строку путём
добавления нулевого символа завершения к концу завершающей объединение
строки.

Строка не может содержать двойные кавычки, поскольку строка заключается в
двойные кавычки.  Чтобы включить символ двойной символ кавычки в строку,
используйте escape-последовательность @code{\"}.  Вы можете использовать
любую из escape-последовательностей в качестве символьных констант в строках.
Вот некоторые примеры строковых констант:

@example
@group
/* @r{Это одностроковая константа.} */
"Тутти Фрутти мороженое"

/* @r{Эти строковые константы будут сцеплены, так, как описано выше.} */
"Тутти " "Фрутти" " мороженное "

/* @r{Здесь используются две escape-последовательности.} */
"\"привет, мир!\""
@end group
@end example

@noindent
Если строка слишком длинная, чтобы поместиться на одной строке, вы можете
использовать обратную косую @code{\}, чтобы разбить его на отдельные строки.

@example
@group
"Сегодня особый бутерброд на ржаном хлебе \
с картофельными котлетами и вишневой содой."
@end group
@end example

@noindent
Смежные строки автоматически объединяются, так что вы можете иметь строковые
константы на нескольких строка, записывая их в виде отдельных, смежных,
строк. Например:

@example
@group
"Специальный завтрак - сендвич с солониной говядины на хлебе "
"из грубой ржаной муки и манной кашей из сельтерской воды."
@end group
@end example

@noindent
тоже самое от записи

@example
@group
"Специальный завтрак - сендвич с солониной говядины на хлебе \
из грубой ржаной муки и манной кашей из сельтерской воды."
@end group
@end example

Для того, чтобы вставить символ новой строки в строку, так чтобы, когда
строка печаталась, строка выводилась на двух различных строках, вы можете
использовать escape-последовательность новой строки @samp{\n}.

@example
printf ("картофельная\nкотлета");
@end example

@noindent
prints

@example
@group
картофельная
котлета
@end group
@end example

@c TJR: Удаление этого пункта, пока мы не можем определить наверняка,
@c что GCC ограничивает предел (в том числе ``no limit'') длины строковым
@c константам.
@c
@c Все системы ANSI C89 должны поддерживать строковые константы, по крайней
@c мере 509 символов после конкатенации смежных символов.  GCC, кажется, не
@c имеет фиксированного предела (строковые константы в сотню мегабайтов,
@c будут работать).

@c ANSI C89, sec 5.2.4.1, ``Translation Limits''.

@node Operators
@section Операторы
@cindex operators as lexical elements

Оператор является специальным маркером, который выполняет операцию, например,
сложения или вычитания, с одним, двумя или тремя операндах.  Описание всех
операторов можно найти в следующей главе.  @xref{Expressions and Operators}.


@node Separators
@section Сепараторы
@cindex separators

Сепаратор отделяет операторы.  Пробел (смотрите следующий раздел) является
сепаратором, но не для операторов.  Все остальные сепараторы - это
односимвольные операторы:

@example
( ) [ ] @{ @} ; , . :
@end example


@node White Space
@section Пробелы
@cindex white space

Пробел - это собирательный термин, использующийся для нескольких символов:
символ пробела, символ табуляции, символ новой строки, вертикальная табуляция
и символ перевода страницы.  Пробелы игнорируются (вне строковых и символьных
констант), и, следовательно, по желанию, за исключением случаев, когда они
используется для разделения операторов. Это значит, что

@example
@group
#include <stdio.h>

int
main()
@{
  printf( "привет, мир\n" );
  return 0;
@}
@end group
@end example

@noindent
and

@example
@group
#include <stdio.h> int main()@{printf("привет, мир\n");
return 0;@}
@end group
@end example

@noindent
функционально одна и та же программа.

Хотя вы должны использовать символы пробела для разделения нескольких
операторов, пробелы не требуется между операторами и операндами, ровно так
не требуется установка пробела между несколькими сепараторами и между тем,
что они разделяют.


@example
@group
/* @r{Все записи являются допустимыми.} */

x++;
x ++ ;
x=y+z;
x = y + z ;
x=array[2];
x = array [ 2 ] ;
fraction=numerator / *denominator_ptr;
fraction = numerator / * denominator_ptr ;
@end group
@end example

@noindent
Кроме того, там, где допускается один пробел, допускается также и любое
количество пробелов.

@example
@group
/* @r{Эти два утверждения функционально идентичны.} */
x++;

x
       ++       ;
@end group
@end example

В строковых константах, пробелы и табуляции не игнорируются; скорее, они
являются частью строки. Следовательно,

@example
"картофельная котлета"
@end example

@noindent
 это не то же самое

@example
"картофельная                         котлета"
@end example
