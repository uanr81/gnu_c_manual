
@c This is part of The GNU C Reference Manual
@c Copyright (C) 2003, 2004, 2006-2009 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.

@node Statements
@chapter Инструкции
@cindex statements

Инструкция вызывает действия и управляет потоком выполнения в программах.
Можно написать инструкцию, которая не будет делать вообще ничего, или делать
то, что бесполезно.

@menu
* Labels::
* Expression Statements::       
* The if Statement::     
* The switch Statement::  
* The while Statement::  
* The do Statement::     
* The for Statement::    
* Blocks::                      
* The Null Statement::          
* The goto Statement::   
* The break Statement::  
* The continue Statement::  
* The return Statement::  
* The typedef Statement::
@end menu

@node Labels
@section Метки
@cindex labels
@cindex labeled statements
@cindex statements, labeled

Можно использовать метки для идентификации места исходного кода для
использования в будущем оператором @code{goto} (@pxref{The goto Statement}).
Метка состоит из идентификатора (например, такого, которые используются для
имен переменных), с последующим двоеточием. Вот пример:

@example
@group
treet:
@end group
@end example

Имена меток не конфликтуют с другими идентификаторами:

@example
@group
int treet = 5;    /* @r{@code{treet} это переменная.} */
treet:            /* @r{@code{treet} это метка.} */
@end group
@end example

Стандартные мандаты ISO C, что за меткой следовало, по крайней мере, одно
выражение, возможно, пустой оператор (@pxref{The Null Statement}).  GCC будет
компилировать код, который не соответствует этому требованию, но это может
повлечь проблемы с переносимостью.


@node Expression Statements
@section Выражения Инструкций
@cindex expression statements
@cindex statements, expression

Можно превратить любое выражение в инструкцию, добавив точку с запятой в
конце выражения.  Вот некоторые примеры:

@example
@group
5;
2 + 2;
10 >= 9;
@end group
@end example

В каждом из них, все, что происходит - это вычисление каждого выражения.  Тем
не менее, они бесполезны, потому что они нигде не сохраняют результат, здесь
только происходит оценка выражений.  Компилятор может игнорировать подобные
инструкции.

Инструкции выражений тогда полезны, когда имеют побочный эффект, такой как
сохранение значения, вызов функции, или (это эзотерическое) вызов сбоя в
программе.  Вот несколько полезных примеров:

@example
@group
x++;
y = x + 25;
puts ("Привет, пользователь!");
*cucumber;
@end group
@end example

Последняя из этих инструкций, @code{*cucumber;}, потенциально может вызвать
сбой в программе, если значение @code{cucumber} одновременно не является
допустимым указателем и было объявлено не как @code{volatile}.

@comment ссылка `volatile'


@node The if Statement
@section Конструкция @code{if}
@cindex @code{if} statements
@cindex @code{else} statements

Можно использовать условную конструкцию @code{if}, чтобы выполнить часть
программы, на основе истинности заданного выражения.  Вот общий вид
конструкции @code{if}:

@example
@group
if (@var{тест})
  @var{тогда-часть}
else
  @var{иначе-часть}
@end group
@end example

Если выражение @var{тест} оценено в значение истинна, то выполняется
@var{тогда-часть} а @var{иначе-часть} нет.  Если выражение @var{тест}
оценено в значение ложь, то @var{тогда-часть} выполняется а
@var{тогда-часть} нет.  Выражение @code{else} не является обязательным.

Вот конкретный пример:

@example
@group
if (x == 10)
  puts ("x это 10");
@end group
@end example

Если выражение @code{x == 10} оценивается как истинна, то выполняется
инструкция @code{puts ("x это 10");}.  Если @code{x == 10}
оценивается в значение ЛОЖЬ, то инструкция @code{puts ("x это 10");} не
выполняется.  Ниже приведен пример использования с @code{else}:

@example
@group
if (x == 10)
  puts ("x это 10");
else
  puts ("x не 10");
@end group
@end example

Можно использовать ряд инструкций @code{if} для проверки нескольких условий:

@example
@group
if (x == 1)
  puts ("x это 1");
else if (x == 2)
  puts ("x это 2");
else if (x == 3)
  puts ("x это 3");
else
  puts ("x что-то другое");
@end group
@end example

Эта функция вычисляет и отображает дату Пасхи для заданного года @code{y}:

@example
void
датаПасхи (int y)
@{
  int n = 0;
  int g = (y % 19) + 1;
  int c = (y / 100) + 1;
  int x = ((3 * c) / 4) - 12;
  int z = (((8 * c) + 5) / 25) - 5;
  int d = ((5 * y) / 4) - x - 10;
  int e = ((11 * g) + 20 + z - x) % 30;

  if (((e == 25) && (g > 11)) || (e == 24))
    e++;

  n = 44 - e;

  if (n < 21)
    n += 30;

  n = n + 7 - ((d + n) % 7);

  if (n > 31)
    printf ("Пасха: %d Апрель %d", n - 31, y);
  else
    printf ("Пасха: %d Март %d", n, y);
@}
@end example

@node The switch Statement
@section Переключатель @code{switch}
@cindex @code{switch} statement

Можно использовать оператор @code{switch} для сравнения одного выражения с
другими, а затем выполнения ряда вспомогательных инструкций, основанных на
результате сравнения.  Вот общий вид переключателя @code{switch}:

@example
@group
switch (@var{тест})
  @{
    case @var{сравнитьТест-1}:
      @var{если-соответствует-сравнитьТест-1}
    case @var{сравнитьТест-2}:
      @var{если-соответствует-сравнитьТест-2}
    @dots{}
    default:
      @var{соответствие-по-умолчанию}
  @}
@end group
@end example

Инструкция @code{switch} сравнивает @var{тест} с каждым из выражений
вариантов @var{сравнитьТест-N}, пока не найдет то, которое удовлетворяет
@var{test}.  Затем выполняются вложенные инструкции выбранного варианта.  Все
сравниваемые выражения, должны быть целочисленного типа, и выражения
@var{сравнитьТест-N} должны быть константами целочисленного типа, как
константа целого числа (например, буквальное целое число или выражение,
построенное из литералов целых чисел).

При желании можно указать вариант по умолчанию.  Если @var{тест} нет
соответствия ни к одному из конкретных вариантов, перечисленных до варианта
по умолчанию, то выполняются инструкции варианта по умолчанию.  Традиционно,
вариант по умолчанию записывается в конце всех вариантов, но это не
требуется обязательно.


@example
@group
switch (x)
  @{
    case 0:
      puts ("x это 0");
      break;
    case 1:
      puts ("x это 1");
      break;
    default:
      puts ("x что-то другое");
      break;
  @}
@end group
@end example

Использование инструкции @code{break} в каждом из вариантов, приводит к
тому, что, в случае выиграша варианта, выполняются вложенные утверждения и
управление потоком выполнения передаётся после всей конструкции переключателя
@code{switch} в обход выполнения всех оставшихся инструкций переключателя:

@example
@group
int x = 0;
switch (x)
  @{
    case 0:
      puts ("x это 0");
    case 1:
      puts ("x это 1");
    default:
      puts ("x что-то другое");
  @}
@end group
@end example

@noindent
Выход этого примера без инструкции @code{break;}:

@example
@group
x is 0
x is 1
x is что-то другое
@end group
@end example

Это часто не желательно.  Инструкции @code{break;} в конце каждого варианта
перенаправляет поток выполнения программы в точку сразу после конструкции
переключателя @code{switch}.

В качестве расширения GNU C, можно также указать диапазон последовательных
целочисленных значений в одной метке @code{case}, как здесь:

@example
case @var{начало} ... @var{предел}:
@end example

@noindent
Это имеет тот же эффект, что и соответствующее число отдельных @code{case}
меток, по одному для каждого целого значения от @var{начало} до @var{предел}
включительно.

Эта функция особенно полезна для диапазонов кодов символов ASCII:

@example
case 'A' ... 'Z':
@end example

Будьте осторожны, не нужно добавлять пробелы вокруг @code{...}, иначе это
может быть разобрано неправильно, при использовании с целочисленными
значениями.  Например, если написать следующим образом:

@example
case 1 ... 5:
@end example

@noindent
вместо этого требуется писать так:

@example
case 1...5:
@end example

Распространено использовать конструкцию переключателя @code{switch} для
обработки различных возможных значений конструкции @code{errno}.  В этом
случае, для переносимости программы, нужно следить за макросами, которые
используют значение @code{errno}, которое на самом деле имеет такое же
значение, например как @code{EWOULDBLOCK} и @code{EAGAIN}.


@node The while Statement
@section Конструкция @code{while}
@cindex @code{while} statement

Конструкция @code{while} является инструкцией цикла с условием на входе в
начале цикла.  Вот общая форма конструкции @code{while}:

@example
@group
while (@var{тест})
  @var{инструкции}
@end group
@end example

Инструкция @code{while} вначале оценивает условие @var{тест}.  Если выражение
@var{тест} вычислено как истинна, выполняются @var{инструкции}, а затем
@var{тест} оценивается снова.  @var{инструкции} продолжают выполняться до тех
пор, пока условие @var{тест} оценивается как истина после каждого выполнения
@var{инструкции}.  

Этот пример печатает целые числа от нуля до девяти:

@example
@group
int counter = 0;
while (counter < 10)
  printf ("%d ", counter++);
@end group
@end example

Инструкция @code{break} может также вызвать выход из цикла @code{while}.

@node The do Statement
@section Конструкция @code{do}
@cindex @code{do} statement

Конструкция @code{do} является инструкцией цикла с условием в конце цикла.
Вот общая форма конструкции @code{do}:

@example
@group
do
  @var{инструкции}
while (@var{тест});
@end group
@end example

Конструкция @code{do} вначале выполняет @var{инструкции}.  После этого,
оценивается условие @var{тест}.  Если @var{тест} оценено в истину, то
выполняются @var{инструкции} снова.  @var{инструкции} продолжают выполняться
до тех пор, пока условие @var{тест} будет оцениватся в истину, после каждого
выполнения @var{инструкции}.  Этот пример также печатает целые числа от нуля
до девяти:

@example
@group
int x = 0;
do
  printf ("%d ", x++);
while (x < 10);
@end group
@end example

Инструкция @code{break} может также произвести выход из цикла @code{do}.

@node The for Statement
@section The @code{for} Statement
@cindex @code{for} statement

The @code{for} statement is a loop statement whose structure allows
easy variable initialization, expression testing, and variable
modification.  It is very convenient for making counter-controlled
loops.  Here is the general form of the @code{for} statement:

@example
for (@var{initialize}; @var{test}; @var{step})
  @var{statement}
@end example

The @code{for} statement first evaluates the expression @var{initialize}.
Then it evaluates the expression @var{test}.  If @var{test} is false, then
the loop ends and program control resumes after @var{statement}.  Otherwise,
if @var{test} is true, then @var{statement} is executed.  Finally,
@var{step} is evaluated, and the next iteration of the loop begins with
evaluating @var{test} again.

Most often, @var{initialize} assigns values to one or more variables,
which are generally used as counters,  @var{test} compares those
variables to a predefined expression, and @var{step} modifies those
variables' values.  Here is another example that prints the integers
from zero through nine:

@example
@group
int x;
for (x = 0; x < 10; x++)
  printf ("%d ", x);
@end group
@end example

First, it evaluates @var{initialize}, which assigns @code{x} the value
0.  Then, as long as @code{x} is less than 10, the value of @code{x}
is printed (in the body of the loop).  Then @code{x} is incremented in
the @var{step} clause and the test re-evaluated.

All three of the expressions in a @code{for} statement are optional, and any
combination of the three is valid.  Since the first expression is evaluated
only once, it is perhaps the most commonly omitted expression.  You could
also write the above example as:

@example
@group
int x = 1;
for (; x <= 10; x++)
  printf ("%d ", x);
@end group
@end example

@noindent
In this example, @code{x} receives its value prior to the beginning of the
@code{for} statement.

If you leave out the @var{test} expression, then the @code{for} statement
is an infinite loop (unless you put a @code{break} or @code{goto} statement
somewhere in @var{statement}).  This is like using @code{1} as
@var{test}; it is never false.

This @code{for} statement starts printing numbers at 1 and then
continues indefinitely, always printing @code{x} incremented by 1:

@example
@group
for (x = 1; ; x++)
  printf ("%d ", x);
@end group
@end example

If you leave out the @var{step} expression, then no progress is made
toward completing the loop---at least not as is normally expected with
a @code{for} statement.

This example prints the number 1 over and over, indefinitely:

@example
@group
for (x = 1; x <= 10;)
  printf ("%d ", x);
@end group
@end example

Perhaps confusingly, you cannot use the comma operator (@pxref{The
Comma Operator}) for monitoring multiple variables in a @code{for}
statement, because as usual the comma operator discards the result of
its left operand.  This loop:

@example
@group
int x, y;
for (x = 1, y = 10; x <= 10, y >= 1; x+=2, y--)
  printf ("%d %d\n", x, y);
@end group
@end example

@noindent Outputs:

@example
1 10
3 9
5 8
7 7
9 6
11 5
13 4
15 3
17 2
19 1
@end example

If you need to test two conditions, you will need to use the @code{&&}
operator:

@example
@group
int x, y;
for (x = 1, y = 10; x <= 10 && y >= 1; x+=2, y--)
  printf ("%d %d\n", x, y);
@end group
@end example

A @code{break} statement can also cause a @code{for} loop to exit.

Here is an example of a function that computes the summation of squares, given a 
starting integer to square and an ending integer to square:

@example
@group
int
sum_of_squares (int start, int end)
@{
  int i, sum = 0;
  for (i = start; i <= end; i++)
    sum += i * i;
  return sum;
@}
@end group
@end example

@node Blocks
@section Blocks
@cindex blocks
@cindex compound statements

A @dfn{block} is a set of zero or more statements enclosed in braces.
Blocks are also known as @dfn{compound statements}.  Often, a block is
used as the body of an @code{if} statement or a loop statement, to
group statements together.

@example
@group
for (x = 1; x <= 10; x++)
  @{
    printf ("x is %d\n", x);
    
    if ((x % 2) == 0)
      printf ("%d is even\n", x);
    else
      printf ("%d is odd\n", x);
  @}
@end group
@end example

You can also put blocks inside other blocks:

@example
@group
for (x = 1; x <= 10; x++)
  @{
    if ((x % 2) == 0)
      @{
        printf ("x is %d\n", x);
        printf ("%d is even\n", x);
      @}
    else
      @{
        printf ("x is %d\n", x);
        printf ("%d is odd\n", x);
      @}
  @}
@end group
@end example  

You can declare variables inside a block; such variables are local to
that block.  In C89, declarations must occur before other statements,
and so sometimes it is useful to introduce a block simply for this
purpose:

@comment scope reference  (locality)

@example
@group
@{
  int x = 5;
  printf ("%d\n", x);
@}
printf ("%d\n", x);   /* @r{Compilation error! @code{x} exists only}
                       @r{in the preceding block.} */
@end group
@end example


@node The Null Statement
@section The Null Statement
@cindex null statement
@cindex statement, null

The @dfn{null statement} is merely a semicolon alone.

@example
@group
;
@end group
@end example

A null statement does not do anything.  It does not store a value anywhere.
It does not cause time to pass during the execution of your program.

Most often, a null statement is used as the body of
a loop statement, or as one or more of the expressions in a @code{for}
statement.  Here is an example of a @code{for} statement that uses the
null statement as the body of the loop (and also calculates the integer
square root of @code{n}, just for fun):

@example
@group
for (i = 1; i*i < n; i++)
  ;
@end group
@end example

Here is another example that uses the null statement as the body
of a @code{for} loop and also produces output:

@example
@group
for (x = 1; x <= 5; printf ("x is now %d\n", x), x++)
  ;
@end group
@end example

A null statement is also sometimes used to follow a label that would
otherwise be the last thing in a block.


@node The goto Statement
@section The @code{goto} Statement
@cindex @code{goto} statement

You can use the @code{goto} statement to unconditionally jump to a different
place in the program.  Here is the general form of a @code{goto} statement:

@example
goto @var{label};
@end example

You have to specify a label to jump to; when the @code{goto} statement
is executed, program control jumps to that label.  @xref{Labels}.  Here
is an example:

@example
@group
goto end_of_program;
@dots{}
end_of_program:
@end group
@end example

The label can be anywhere in the same function as the @code{goto}
statement that jumps to it, but a @code{goto} statement cannot jump to a
label in a different function.

You @emph{can} use @code{goto} statements to simulate loop statements,
but we do not recommend it---it makes the program harder to read, and GCC
cannot optimize it as well.  You should use @code{for},
@code{while}, and @code{do} statements instead of @code{goto} statements,
when possible.

As an extension, GCC allows a goto statement to jump to an address
specified by a @code{void*} variable.  To make this work, you also
need to take the address of a label by using the unary operator
@code{&&} (not @code{&}).  Here is a contrived example:

@example
@group
enum Play @{ ROCK=0, PAPER=1, SCISSORS=2 @};
enum Result @{ WIN, LOSE, DRAW @};

static enum Result turn (void) 
@{
  const void * const jumptable[] = @{&&rock, &&paper, &&scissors@};
  enum Play opp;                /* @r{opponent's play} */
  goto *jumptable[select_option (&opp)];
 rock:
  return opp == ROCK ? DRAW : (opp == PAPER ? LOSE : WIN);
 paper:
  return opp == ROCK ? WIN  : (opp == PAPER ? DRAW : LOSE);
 scissors:
  return opp == ROCK ? LOSE : (opp == PAPER ? WIN  : DRAW);
@}
@end group
@end example

@c Here we should mention that programs should not jump over an
@c initializer with a goto (and elsewhere say the same for a case
@c label).  However, just now I can't find the section of the C89
@c standard that stipulates this.


@node The break Statement
@section The @code{break} Statement
@cindex @code{break} statement

You can use the @code{break} statement to terminate a @code{while}, @code{do},
@code{for}, or @code{switch} statement.  Here is an example:

@example
@group
int x;
for (x = 1; x <= 10; x++)
  @{
    if (x == 8)
      break;
    else
      printf ("%d ", x);
  @}
@end group
@end example

That example prints numbers from 1 to 7.  When @code{x} is incremented
to 8, @code{x == 8} is true, so the @code{break} statement is executed, 
terminating the @code{for} loop prematurely.

If you put a @code{break} statement inside of a loop or @code{switch}
statement which itself is inside of a loop or @code{switch} statement, the
@code{break} only terminates the innermost loop or @code{switch} statement.


@node The continue Statement
@section The @code{continue} Statement
@cindex @code{continue} statement

You can use the @code{continue} statement in loops to terminate an
iteration of the loop and begin the next iteration.  Here is an
example:

@example
@group
for (x = 0; x < 100; x++)
  @{
    if (x % 2 == 0)
      continue;
    else
      sum_of_odd_numbers + = x;
  @}
@end group
@end example

If you put a @code{continue} statement inside a loop which itself is
inside a loop, then it affects only the innermost loop.



@node The return Statement
@section The @code{return} Statement
@cindex @code{return} statement

You can use the @code{return} statement to end the execution of a function
and return program control to the function that called it.  Here is the
general form of the @code{return} statement:

@example
return @var{return-value};
@end example

@var{return-value} is an optional expression to return.  If the
function's return type is @code{void}, then it is invalid to return
an expression.  You can, however, use the @code{return} statement
without a return value.

If the function's return type is not the same as the type of
@var{return-value}, and automatic type conversion cannot be performed,
then returning @var{return-value} is invalid.

@comment Reference to type conversion

If the function's return type is not @code{void} and no return value
is specified, then the @code{return} statement is valid unless the
function is called in a context that requires a return value.  For
example:

@example
x = cosine (y);
@end example

In that case, the function @code{cosine} was called in a context that
required a return value, so the value could be assigned to @code{x}.

Even in contexts where a return value is not required, it is a bad idea
for a non-@code{void} function to omit the return value.  With GCC, you
can use the command line option @code{@w{-Wreturn}-type} to issue a warning
if you omit the return value in such functions.

Here are some examples of using the @code{return} statement, in both
a @code{void} and non-@code{void} function:

@example
@group
void
print_plus_five (int x)
@{
  printf ("%d ", x + 5);
  return;
@}
@end group
@end example

@example
@group
int
square_value (int x)
@{
  return x * x;
@}
@end group
@end example


@node The typedef Statement
@section The @code{typedef} Statement
@cindex @code{typedef} statement

You can use the @code{typedef} statement to create new names for data
types.  Here is the general form of the @code{typedef} statement:

@example
typedef @var{old-type-name} @var{new-type-name}
@end example

@var{old-type-name} is the existing name for the type, and may consist
of more than one token (e.g., @code{unsigned long int}).
@var{new-type-name} is the resulting new name for the type, and must
be a single identifier.  Creating this new name for the type does
not cause the old name to cease to exist.  Here are some examples:

@example
@group
typedef unsigned char byte_type;
typedef double real_number_type;
@end group
@end example

@noindent
In the case of custom data types, you can use @code{typedef} to make a
new name for the type while defining the type:

@example
@group
typedef struct fish
@{
  float weight;
  float length;
  float probability_of_being_caught;
@} fish_type;
@end group
@end example

@noindent
To make a type definition of an array, you first provide the type of the element, and
then establish the number of elements at the end of the type definition:

@example
@group
typedef char array_of_bytes [5];
array_of_bytes five_bytes = @{0, 1, 2, 3, 4@};
@end group
@end example

When selecting names for types, you should avoid ending your type names with
a @code{_t} suffix.  The compiler will allow you to do this, but the
POSIX standard reserves use of the @code{_t} suffix for standard library
type names.
