
@c This is part of The GNU C Reference Manual
@c Copyright (C) 2003, 2004, 2006-2009 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.

@node Statements
@chapter Инструкции
@cindex statements

Инструкция вызывает действия и управляет потоком выполнения в программах.
Можно написать инструкцию, которая не будет делать вообще ничего, или делать
то, что бесполезно.

@menu
* Labels::
* Expression Statements::       
* The if Statement::     
* The switch Statement::  
* The while Statement::  
* The do Statement::     
* The for Statement::    
* Blocks::                      
* The Null Statement::          
* The goto Statement::   
* The break Statement::  
* The continue Statement::  
* The return Statement::  
* The typedef Statement::
@end menu

@node Labels
@section Метки
@cindex labels
@cindex labeled statements
@cindex statements, labeled

Можно использовать метки для идентификации места исходного кода для
использования в будущем оператором @code{goto} (@pxref{The goto Statement}).
Метка состоит из идентификатора (например, такого, которые используются для
имен переменных), с последующим двоеточием. Вот пример:

@example
@group
treet:
@end group
@end example

Имена меток не конфликтуют с другими идентификаторами:

@example
@group
int treet = 5;    /* @r{@code{treet} это переменная.} */
treet:            /* @r{@code{treet} это метка.} */
@end group
@end example

Стандартные мандаты ISO C, что за меткой следовало, по крайней мере, одно
выражение, возможно, пустой оператор (@pxref{The Null Statement}).  GCC будет
компилировать код, который не соответствует этому требованию, но это может
повлечь проблемы с переносимостью.


@node Expression Statements
@section Выражения Инструкций
@cindex expression statements
@cindex statements, expression

Можно превратить любое выражение в инструкцию, добавив точку с запятой в
конце выражения.  Вот некоторые примеры:

@example
@group
5;
2 + 2;
10 >= 9;
@end group
@end example

В каждом из них, все, что происходит - это вычисление каждого выражения.  Тем
не менее, они бесполезны, потому что они нигде не сохраняют результат, здесь
только происходит оценка выражений.  Компилятор может игнорировать подобные
инструкции.

Инструкции выражений тогда полезны, когда имеют побочный эффект, такой как
сохранение значения, вызов функции, или (это эзотерическое) вызов сбоя в
программе.  Вот несколько полезных примеров:

@example
@group
x++;
y = x + 25;
puts ("Привет, пользователь!");
*cucumber;
@end group
@end example

Последняя из этих инструкций, @code{*cucumber;}, потенциально может вызвать
сбой в программе, если значение @code{cucumber} одновременно не является
допустимым указателем и было объявлено не как @code{volatile}.

@comment ссылка `volatile'


@node The if Statement
@section Конструкция @code{if}
@cindex @code{if} statements
@cindex @code{else} statements

Можно использовать условную конструкцию @code{if}, чтобы выполнить часть
программы, на основе истинности заданного выражения.  Вот общий вид
конструкции @code{if}:

@example
@group
if (@var{тест})
  @var{тогда-часть}
else
  @var{иначе-часть}
@end group
@end example

Если выражение @var{тест} оценено в значение истинна, то выполняется
@var{тогда-часть} а @var{иначе-часть} нет.  Если выражение @var{тест}
оценено в значение ложь, то @var{тогда-часть} выполняется а
@var{тогда-часть} нет.  Выражение @code{else} не является обязательным.

Вот конкретный пример:

@example
@group
if (x == 10)
  puts ("x это 10");
@end group
@end example

Если выражение @code{x == 10} оценивается как истинна, то выполняется
инструкция @code{puts ("x это 10");}.  Если @code{x == 10}
оценивается в значение ЛОЖЬ, то инструкция @code{puts ("x это 10");} не
выполняется.  Ниже приведен пример использования с @code{else}:

@example
@group
if (x == 10)
  puts ("x это 10");
else
  puts ("x не 10");
@end group
@end example

Можно использовать ряд инструкций @code{if} для проверки нескольких условий:

@example
@group
if (x == 1)
  puts ("x это 1");
else if (x == 2)
  puts ("x это 2");
else if (x == 3)
  puts ("x это 3");
else
  puts ("x что-то другое");
@end group
@end example

Эта функция вычисляет и отображает дату Пасхи для заданного года @code{y}:

@example
void
датаПасхи (int y)
@{
  int n = 0;
  int g = (y % 19) + 1;
  int c = (y / 100) + 1;
  int x = ((3 * c) / 4) - 12;
  int z = (((8 * c) + 5) / 25) - 5;
  int d = ((5 * y) / 4) - x - 10;
  int e = ((11 * g) + 20 + z - x) % 30;

  if (((e == 25) && (g > 11)) || (e == 24))
    e++;

  n = 44 - e;

  if (n < 21)
    n += 30;

  n = n + 7 - ((d + n) % 7);

  if (n > 31)
    printf ("Пасха: %d Апрель %d", n - 31, y);
  else
    printf ("Пасха: %d Март %d", n, y);
@}
@end example

@node The switch Statement
@section Переключатель @code{switch}
@cindex @code{switch} statement

Можно использовать оператор @code{switch} для сравнения одного выражения с
другими, а затем выполнения ряда вспомогательных инструкций, основанных на
результате сравнения.  Вот общий вид переключателя @code{switch}:

@example
@group
switch (@var{тест})
  @{
    case @var{сравнитьТест-1}:
      @var{если-соответствует-сравнитьТест-1}
    case @var{сравнитьТест-2}:
      @var{если-соответствует-сравнитьТест-2}
    @dots{}
    default:
      @var{соответствие-по-умолчанию}
  @}
@end group
@end example

Инструкция @code{switch} сравнивает @var{тест} с каждым из выражений
вариантов @var{сравнитьТест-N}, пока не найдет то, которое удовлетворяет
@var{test}.  Затем выполняются вложенные инструкции выбранного варианта.  Все
сравниваемые выражения, должны быть целочисленного типа, и выражения
@var{сравнитьТест-N} должны быть константами целочисленного типа, как
константа целого числа (например, буквальное целое число или выражение,
построенное из литералов целых чисел).

При желании можно указать вариант по умолчанию.  Если @var{тест} нет
соответствия ни к одному из конкретных вариантов, перечисленных до варианта
по умолчанию, то выполняются инструкции варианта по умолчанию.  Традиционно,
вариант по умолчанию записывается в конце всех вариантов, но это не
требуется обязательно.


@example
@group
switch (x)
  @{
    case 0:
      puts ("x это 0");
      break;
    case 1:
      puts ("x это 1");
      break;
    default:
      puts ("x что-то другое");
      break;
  @}
@end group
@end example

Использование инструкции @code{break} в каждом из вариантов, приводит к
тому, что, в случае выиграша варианта, выполняются вложенные утверждения и
управление потоком выполнения передаётся после всей конструкции переключателя
@code{switch} в обход выполнения всех оставшихся инструкций переключателя:

@example
@group
int x = 0;
switch (x)
  @{
    case 0:
      puts ("x это 0");
    case 1:
      puts ("x это 1");
    default:
      puts ("x что-то другое");
  @}
@end group
@end example

@noindent
Выход этого примера без инструкции @code{break;}:

@example
@group
x is 0
x is 1
x is что-то другое
@end group
@end example

Это часто не желательно.  Инструкции @code{break;} в конце каждого варианта
перенаправляет поток выполнения программы в точку сразу после конструкции
переключателя @code{switch}.

В качестве расширения GNU C, можно также указать диапазон последовательных
целочисленных значений в одной метке @code{case}, как здесь:

@example
case @var{начало} ... @var{предел}:
@end example

@noindent
Это имеет тот же эффект, что и соответствующее число отдельных @code{case}
меток, по одному для каждого целого значения от @var{начало} до @var{предел}
включительно.

Эта функция особенно полезна для диапазонов кодов символов ASCII:

@example
case 'A' ... 'Z':
@end example

Будьте осторожны, не нужно добавлять пробелы вокруг @code{...}, иначе это
может быть разобрано неправильно, при использовании с целочисленными
значениями.  Например, если написать следующим образом:

@example
case 1 ... 5:
@end example

@noindent
вместо этого требуется писать так:

@example
case 1...5:
@end example

Распространено использовать конструкцию переключателя @code{switch} для
обработки различных возможных значений конструкции @code{errno}.  В этом
случае, для переносимости программы, нужно следить за макросами, которые
используют значение @code{errno}, которое на самом деле имеет такое же
значение, например как @code{EWOULDBLOCK} и @code{EAGAIN}.


@node The while Statement
@section Конструкция @code{while}
@cindex @code{while} statement

Конструкция @code{while} является инструкцией цикла с условием на входе в
начале цикла.  Вот общая форма конструкции @code{while}:

@example
@group
while (@var{тест})
  @var{инструкции}
@end group
@end example

Инструкция @code{while} вначале оценивает условие @var{тест}.  Если выражение
@var{тест} вычислено как истинна, выполняются @var{инструкции}, а затем
@var{тест} оценивается снова.  @var{инструкции} продолжают выполняться до тех
пор, пока условие @var{тест} оценивается как истина после каждого выполнения
@var{инструкции}.  

Этот пример печатает целые числа от нуля до девяти:

@example
@group
int counter = 0;
while (counter < 10)
  printf ("%d ", counter++);
@end group
@end example

Инструкция @code{break} может также вызвать выход из цикла @code{while}.

@node The do Statement
@section Конструкция @code{do}
@cindex @code{do} statement

Конструкция @code{do} является инструкцией цикла с условием в конце цикла.
Вот общая форма конструкции @code{do}:

@example
@group
do
  @var{инструкции}
while (@var{тест});
@end group
@end example

Конструкция @code{do} вначале выполняет @var{инструкции}.  После этого,
оценивается условие @var{тест}.  Если @var{тест} оценено в истину, то
выполняются @var{инструкции} снова.  @var{инструкции} продолжают выполняться
до тех пор, пока условие @var{тест} будет оцениватся в истину, после каждого
выполнения @var{инструкции}.  Этот пример также печатает целые числа от нуля
до девяти:

@example
@group
int x = 0;
do
  printf ("%d ", x++);
while (x < 10);
@end group
@end example

Инструкция @code{break} может также произвести выход из цикла @code{do}.

@node The for Statement
@section Конструкция @code{for}
@cindex @code{for} statement

Конструкция @code{for} является инструкцией цикла, структура которой
позволяет легко производить инициализацию переменной, проверку условного
выражения и модификацию подконтрольной переменной.  Это очень удобно для
создания счетчика контролируемых циклов.  Вот общая форма конструкции
@code{for}:

@example
for (@var{инициализация}; @var{условие}; @var{шаг})
  @var{инструкция}
@end example

В конструкции @code{for} вначале единократно вычисляется выражение
@var{инициализация}. Затем вычисляется выражение @var{условие}.  Если
результат оценки выражения @var{условие} устанавливается в ложь, то цикл
завершается и программа продолжает выполнение, не вычисляя выражение
@var{инструкция}, уже после всей конструкции.  В противном случае, если
@var{условие} оценивается в истину, то вычисляется выражение
@var{инструкция}.  Наконец, оценивается выражение @var{шаг}, и следующая
итерация цикла начинается снова с оценки выражения @var{условие}.

Чаще всего, в выражении @var{инициализация} присваивается значения одной или
нескольким переменным, которые обычно используются в качестве счётчиков,
@var{условие} сравнивает значения этих переменных с заранее заданным
выражением, и выражение @var{шаг} модифицирует значения этих переменных.  Вот
еще один пример, который печатает целые числа от нуля до девяти:

@example
@group
int x;
for (x = 0; x < 10; x++)
  printf ("%d ", x);
@end group
@end example

Во-первых, выполняется инструкция @var{инициализация} - @code{x = 0;},
присваивается переменной @code{x} значение 0.  Затем, выполняется инструкция
@var{условие} - @code{x < 10;}, так как @code{x} меньше, чем 10, то значение
инструкции устанавливается в истину и выполняется инструкция
@code{инструкция} и @code{x} печатается (в теле цикла).  Затем @code{x}
увеличивается в инструкции @var{шаг} и цикл переходит снова к оценки
выражения @var{условие}.

Все три из выражений конструкции @code{for} не являются обязательными, и
любая комбинация из трёх является допустимой.  Так как первое выражение
вычисляется только один раз, наиболее часто это выражение опущено.  Также
можете написать приведенный выше пример, как:

@example
@group
int x = 1;
for (; x <= 10; x++)
  printf ("%d ", x);
@end group
@end example

@noindent
В этом примере, @code{x} получает свое значение до начала конструкции
@code{for}.

Если опущена инструкция @var{условие}, то конструкция @code{for} произведёт
бесконечный цикл (если не поставить инструкцию @code{break} или @code{goto}
где-то в инструкции @var{инструкции}).  Это похоже на использование в
качестве выражения @var{условие} константого значения @code{1}, что сделает
значение этого выражения всегда истина.

Эта конструкция @code{for} начинает печатать числа с 1, а затем продолжается
до бесконечности, всегда перед печатью @code{x} увеличивается на 1:

@example
@group
for (x = 1; ; x++)
  printf ("%d ", x);
@end group
@end example

Если опущенно выражение @var{шаг}, то не будет никакого процеса завершения
цикла --- по крайней мере, в разрезе нормального функционирования конструкции
@code{for}.

Этот пример печатает номер 1 снова и снова, бесконечно:

@example
@group
for (x = 1; x <= 10;)
  printf ("%d ", x);
@end group
@end example

Нельзя использовать оператор запятая (@pxref{The Comma Operator}) для
мониторинга нескольких переменных в конструкции @code{for}, потому что,
оператор запятая, отбрасывает результата оценки своего левого операнда.
Пример цикла:

@example
@group
int x, y;
for (x = 1, y = 10; x <= 10, y >= 1; x+=2, y--)
  printf ("%d %d\n", x, y);
@end group
@end example

@noindent Вывод:

@example
1 10
3 9
5 8
7 7
9 6
11 5
13 4
15 3
17 2
19 1
@end example

Если необходимо проверить два условия, нужно будет использовать оператор
@code{&&}:

@example
@group
int x, y;
for (x = 1, y = 10; x <= 10 && y >= 1; x+=2, y--)
  printf ("%d %d\n", x, y);
@end group
@end example

Инструкция @code{break} может также произвести выход из цикла @code{for}.

Ниже приведен пример функции, которая вычисляет сумму квадратов
последовательных чисел, заданных диапазоном от исходного числа, до
максимального допустимого значения этой суммы:

@example
@group
int
sum_of_squares (int start, int end)
@{
  int i, sum = 0;
  for (i = start; i <= end; i++)
    sum += i * i;
  return sum;
@}
@end group
@end example

@node Blocks
@section Блоки
@cindex blocks
@cindex compound statements

@dfn{Блок} представляет собой набор из нуля или более инструкций, заключенных
в фигурные скобки.  Блоки также известны как @dfn{составные инструкции}.
Часто, блок используется как тело конструкции @code{if} или конструкций
цикла, чтобы группировать инструкции вместе.

@example
@group
for (x = 1; x <= 10; x++)
  @{
    printf ("значение x это %d\n", x);
    
    if ((x % 2) == 0)
      printf ("%d это чётное\n", x);
    else
      printf ("%d это нечётное\n", x);
  @}
@end group
@end example

Также можно поместить блоки внутри других блоков:

@example
@group
for (x = 1; x <= 10; x++)
  @{
    if ((x % 2) == 0)
      @{
        printf ("x значение это %d\n", x);
        printf ("%d чётное число\n", x);
      @}
    else
      @{
        printf ("x значение это %d\n", x);
        printf ("%d не чётное число\n", x);
      @}
  @}
@end group
@end example  

Можно объявлять переменные внутри блока; такие переменные являются локальными
по отношению к этому блоку.  В C89, объявление переменных должно произойти до
использования их в инструкциях и поэтому иногда полезно ввести блок просто
для этой цели:

@comment scope reference  (locality)

@example
@group
@{
  int x = 5;
  printf ("%d\n", x);
@}
printf ("%d\n", x);   /* @r{Ошибка компиляции! @code{x} существует}
                       @r{только в предыдущем блоке.} */
@end group
@end example


@node The Null Statement
@section Инструкция Null
@cindex null statement
@cindex statement, null

@dfn{NULL инструкция} - просто одна точка с запятой.

@example
@group
;
@end group
@end example

Null инструкция ничего не делает.  Нигде не хранит значения.  Не вызывает
трату времени во время выполнения программы.

Чаще всего, пустой оператор используется как в теле инструкции цикла, или в
качестве одного или нескольких выражений инструкции @code{for}.  Вот пример
инструкции @code{for}, где используется инструкция @code{Null}, как тело
цикла (вычисляется целочисленный квадратный корень из значения @code{n},
просто для удовольствия):

@example
@group
for (i = 1; i*i < n; i++)
  ;
@end group
@end example

Вот еще один пример, который использует @code{Null} инструкцию в качестве
тела цикла @code{for}, а также производит вывод:

@example
@group
for (x = 1; x <= 5; printf ("x сейчас %d\n", x), x++)
  ;
@end group
@end example

Инструкция @code{Null} также используется следом за меткой, в противном
случае, метка была бы последней в блоке.


@node The goto Statement
@section Инструкция @code{goto}
@cindex @code{goto} statement

Можно использовать инструкцию @code{goto} для безоговорочного перехода в
другое место в программе.  Вот общий вид инструкции @code{goto}:

@example
goto @var{метка};
@end example

Указывается метка для перехода оператором @code{goto}, когда программа
достигает этой метки.  @xref{Labels}.  Вот пример:

@example
@group
goto end_of_program;
@dots{}
end_of_program:
@end group
@end example

Метка может распологаться в той же функции, что и инструкция @code{goto} и
передавать управление к нему, но инструкция @code{goto} не может перевести
выполнение к метке в другой функции.

Инструкцию @code{goto} @emph{можно} использовать  для ИМИТАЦИИ цикла, но не
рекомендуем так поступать --- это делает программу труднее для чтения, и GCC
не сможет оптимизировать такой код.  Нужно использовать инструкции для циклов
@code{for}, @code{while} и @code{do} вместо инструкции @code{goto}, когда
это возможно.

В качестве расширения, GCC позволяет инструкции @code{goto} осуществлять
переход к адресу, указанному в переменной @code{void*}.  Для того, чтобы
это совершить, нужно взять адрес метки с помощью одинарного оператора
@code{&&} (не @code{&}).  Вот надуманный пример:

@example
@group
enum Play @{ ROCK=0, PAPER=1, SCISSORS=2 @};
enum Result @{ WIN, LOSE, DRAW @};

static enum Result turn (void) 
@{
  const void * const jumptable[] = @{&&rock, &&paper, &&scissors@};
  enum Play opp;                /* @r{opponent's play} */
  goto *jumptable[select_option (&opp)];
 rock:
  return opp == ROCK ? DRAW : (opp == PAPER ? LOSE : WIN);
 paper:
  return opp == ROCK ? WIN  : (opp == PAPER ? DRAW : LOSE);
 scissors:
  return opp == ROCK ? LOSE : (opp == PAPER ? WIN  : DRAW);
@}
@end group
@end example

@c Здесь следует отметить, что в программе не должно быть перехода через
@c инструкцию @code{goto}(в других местах говорят то же самое для меток).
@c Однако, сейчас я не могу найти раздел стандарта C89, который
@c предусматривает это.


@node The break Statement
@section Инструкция @code{break}
@cindex @code{break} statement

Можно использовать инструкцию @code{break}, чтобы прервать выполнение
конструкций @code{while}, @code{do}, @code{for}, или @code{switch}.
Вот пример:

@example
@group
int x;
for (x = 1; x <= 10; x++)
  @{
    if (x == 8)
      break;
    else
      printf ("%d ", x);
  @}
@end group
@end example

Этот пример печатает числа от 1 до 7.  Когда @code{x} увеличивается до 8,
выражение условия @code{x == 8} возвращает результат истина и выполняется
инструкция @code{break}, завершающая выполнение инструкции цикла @code{for}
преждевременно.

Если присутствует инструкция @code{break} внутри инструкции цикла или
инструкции @code{switch}, которая сама находится внутри инструкции цикла или
инструкции @code{switch}, то инструкция  @code{break} сработывает только во
внутреннем цикле или @code{switch}.  (ВопросStatements739)


@node The continue Statement
@section Инструкция @code{continue}
@cindex @code{continue} statement

Можно использовать инструкцию @code{continue} в циклах для прекращения
текущей итерации цикла и перехода на следующую итерацию.  Вот пример:

@example
@group
for (x = 0; x < 100; x++)
  @{
    if (x % 2 == 0)
      continue;
    else
      sum_of_odd_numbers + = x;
  @}
@end group
@end example

Если поставить инструкцию @code{continue} внутри цикла, который сам находится
внутри цикла, то это повлияет только на внутренний цикл.



@node The return Statement
@section Инструкция @code{return}
@cindex @code{return} statement

Можно использовать инструкцию @code{return} для прекращения выполнения
функции и возврата управления программе из функцию, которая её вызвала.  Вот
общая форма инструкции @code{return}:

@example
return @var{возвращаемое-значение};
@end example

@var{возвращаемое-значение} является необязательным выражением для возврата.
Если тип возвращаемого знечения функцией объявлен как @code{void}, то функция
возвращает значение неопределено.  Можно, однако, использовать оператор
@code{return} без указания возвращаемого значения.

Если возвращаемый тип значения функции не совпадает с указанным типом
@var{возвращаемое-значение} и автоматическое преобразование типа не может
быть выполнено, то возвращаемое значение @var{возвращаемое-значение} является
неопределенно.

@comment ссылки преобразование типа

Если функция возвращает значение типа отличного от @code{void}, то инструкция
@code{return} допустима, если функция вызывается в контексте, который требует
возврата значения.  Например:

@example
x = cosine (y);
@end example

В этом случае функции @code{cosine} была вызвана в контексте требования
возврата значения, так что бы значение могло быть присвоено @code{x}.

Даже в условиях, когда не требуется использовать возвращаемое значение
функции, плохая идея при вызове функции с возвращаемым не-@code{void} типом
значения,  опускать это значение.  В GCC, можно использовать параметр
командной строки @code{@w{-Wreturn}-type} для выдачи предупреждений, если
опускается возвращаемое значение в вызове таких функций.

Вот некоторые примеры использования оператора @code{return}, как в функциях
с возвращаемым значением @code{void} и так и значениями с типом
не-@code{void}:

@example
@group
void
print_plus_five (int x)
@{
  printf ("%d ", x + 5);
  return;
@}
@end group
@end example

@example
@group
int
square_value (int x)
@{
  return x * x;
@}
@end group
@end example


@node The typedef Statement
@section Инструкция @code{typedef}
@cindex @code{typedef} statement

Можно использовать инструкцию @code{typedef} для создания новых имен для
типов данных.  Вот общая форма инструкции @code{typedef}:

@example
typedef @var{прежднее-имя-типа} @var{новое-имя-типа}
@end example

@var{прежднее-имя-типа} этого имя существующего типа данных, возможно
объявленного с использованием более чем одного спецификатора (например,
@code{unsigned long int}).  @var{новое-имя-типа} является полученным новым
именем для данного типа, и должно быть одним идентификатором.  Создание этого
нового имени для заданного типа не прекращает существование прежднего.  Вот
некоторые примеры:

@example
@group
typedef unsigned char byte_type;
typedef double real_number_type;
@end group
@end example

@noindent
В случае пользовательских типов данных, можно использовать @code{typedef}
для создания нового имени типа, сразу при при определении типа:

@example
@group
typedef struct fish
@{
  float weight;
  float length;
  float probability_of_being_caught;
@} fish_type;
@end group
@end example

@noindent
Для того, чтобы определить новый тип массива, вначале указывается тип
элементов массива, затем количество элементов и, в конце определения,
указывается имя нового типа:

@example
@group
typedef char array_of_bytes [5];
array_of_bytes five_bytes = @{0, 1, 2, 3, 4@};
@end group
@end example

При выборе имени для типа, нужно избегать завершение имен типов с суффиксом
@code{_t}.  Компилятор позволит это сделать, но POSIX резервирует
использование @code{_t} суффикса для имен типов стандартных библиотек.
