
@c This is part of The GNU C Reference Manual
@c Copyright (C) 2007-2016 Free Software Foundation, Inc.
@c See the file gnu-c-manual.texi for copying conditions.
@c author:tjr@gnu.org et al

@node Data Types
@chapter Типы Данных
@cindex data types
@cindex types

@menu
* Primitive Types::
* Enumerations::
* Unions::
* Structures::
* Arrays::
* Pointers::
* Incomplete Types::
* Type Qualifiers::
* Storage Class Specifiers::
* Renaming Types::
@end menu

@c ----------------------------------------------------------------------------
@node Primitive Types
@section Примитивные Типы Данных
@cindex primitive data types
@cindex data types, primitive
@cindex types, primitive

@menu
* Integer Types::
* Real Number Types::
* Complex Number Types::
@end menu

@node Integer Types
@subsection Целочисленные Типы
@cindex integer types
@cindex data types, integer
@cindex types, integer

Целочисленный тип данных имеет размер в диапазоне от, по меньшей мере, 8
битов, до по меньшей мере, 32 битов.  Стандарт C99 расширяет этот диапазон,
чтобы включать в себя целые числа, размеры которых, по меньшей мере, 64 бита.
Вы должны использовать целые типы для хранения значений целых чисел (и типа
данных @code{char} для хранения символов).  Минимальные размеры и диапазоны,
приведенны для этих типов; в зависимости от вашей компьютерной платформы, эти
размеры и диапазоны могут быть больше но никак не меньше.

В то время как эти диапазоны обеспечивают естественный порядок, стандарт не
требует, чтобы любые два типа имели различный диапазон.  Например, @code{int}
и @code{long} могут иметь один и тот же диапазон.  Стандарт позволяет даже
@code{signed char} и @code{long} иметь тот же диапазон, хотя такие платформы
очень необычны.

@itemize @bullet

@item @code{signed char}
@cindex @code{signed char} data type
@*
8-битный @code{signed char} тип данных может содержать целые значения в
диапазоне от @minus{}128 до 127.


@item @code{unsigned char}
@cindex @code{unsigned char} data type
@*
8-битный @code{unsigned char} тип данных может содержать целые значения в
диапазоне от 0 до 255.


@item @code{char}
@cindex @code{char} data type
@*
В зависимости от системы, тип данных @code{char} определяются как имеющий
один и тот же диапазон, либо @code{signed char}, либо @code{unsigned char}
типа данных (хотя это три различных типа, однако).  По соглашению, вы должны
использовать тип данных @code{char} специально для хранения ASCII символов
(например, @code{`m'}), в том числе управляющих последовательностей (таких
как @code{`\n'}).


@item @code{short int}
@cindex @code{short int} data type
@*
16-битный @code{short int} тип данных может содержать целые значения в
диапазоне от @minus{}32,768 до 32,767.  Вы можете также обратиться к этому
типу данных, как @code{short}, @code{signed short int}, или
@code{signed short}.

@item @code{unsigned short int}
@cindex @code{unsigned short int} data type
@*
16-битный @code{unsigned short int} тип данных может содержать целые значения
в диапазоне от 0 до 65,535.  Вы можете также обратиться к этому типу данных,
как к @code{unsigned short}.


@item @code{int}
@cindex @code{int} data type
@*
32-битный @code{int} тип данных может содержать целые значения в диапазоне от
@minus{}2,147,483,648 до 2,147,483,647.  Вы можете также обратиться к этому
типу данных, как к @code{signed int} или @code{signed}.

@item @code{unsigned int}
@cindex @code{unsigned int} data type
@*
32-битный @code{unsigned int} тип данных может содержать целые значения в
диапазоне от 0 до 4,294,967,295.  Вы можете также обратиться к этому типу
данных просто как к @code{unsigned}.


@item @code{long int}
@cindex @code{long int} data type
@*
32-битный @code{long int} тип данных может содержать целые значения в
диапазоне, по меньшей мере,  от @minus{}2,147,483,648 до 2,147,483,647.  (В
зависимости от вашей системы, этот тип данных может быть 64-бит, в этом
случае его диапазон идентичен типу @code{long long int} данных.).  Вы можете
также обратиться к этому типу данных, как к @code{long},
@code{signed long int}, или  к @code{signed long}.


@item @code{unsigned long int}
@cindex @code{unsigned long int} data type
@*
32-битный @code{unsigned long int} тип данных может содержать целые значения
в диапазоне, по меньшей мере, от 0 до 4,294,967,295.  (В зависимости от вашей
системы, этот тип данных может быть 64-бит, в этом случае его диапазон
идентичен типу @code{unsigned long long int} данных.).  Вы можете также
обратиться к этому типу данных, как к @code{unsigned long}.


@item @code{long long int}
@cindex @code{long long int} data type
@*
64-битный @code{long long int} тип данных может содержать целые значения в
диапазоне  от @w{@minus{}9,223,372,036,854,775,808} до
@w{9,223,372,036,854,775,807}.  Вы можете также обратиться к этому типу
данных, как к @code{long long}, @code{signed long long int} или
@code{signed long long}.  Этот тип не является частью C89, идёт как часть C99
и расширение GNU Cи.



@item @code{unsigned long long int}
@cindex @code{unsigned long long int} data type
@*
64-битный @code{unsigned long long int} тип данных может содержать целые
значения в диапазоне, по меньшей мере, от 0 до
@w{18,446,744,073,709,551,615}.  Вы можете также обратиться к этому типу
данных, как к @code{unsigned long long}.  Этот тип не является частью C89,
идёт как часть C99 и расширение GNU Cи.

@end itemize

Вот некоторые примеры объявления и определения целочисленных переменных:

@example
@group
int foo;
unsigned int bar = 42;
char quux = 'a';
@end group
@end example

@noindent
Первая строка объявляет целое с именем @code{foo}, но не определяет его
значение; оно остается не инициализированым, и его значение не следует
считать, как нечто конкретное.

@node Real Number Types
@subsection Типы Действительных Чисел
@cindex real number types
@cindex floating point types
@cindex data types, real number
@cindex data types, floating point
@cindex types, real number
@cindex types, floating point

Есть три типа данных, которые представляют дробные числа.  Хотя размеры и
диапазоны этих типов соответствуют в большинстве компьютерных систем,
используемых сегодня, исторически размеры этих типов варьируется от системы к
системе.  Таким образом, минимальные и максимальные значения сохраняются в
макроопределениях в библиотеке заголовочного файл @code{float.h}.  В этом
разделе, мы включаем имена макроопределений в месте их возможными значениями;
проверте @code{float.h} вашей системы для определенных чисел.

@itemize @bullet

@item @code{float}
@cindex @code{float} data type
@*
@code{float} тип данных является самым маленьким из трех типов с плавающей
точкой, если они различаются по размеру вообще.  Его минимальное значение
хранится в @code{FLT_MIN}, и не должно быть больше, чем @code{1e-37}.  Его
максимальное значение сохраняется в @code{FLT_MAX}, и должно быть не
менее @code{1e37}.


@item @code{double}
@cindex @code{double} data type
@*
@code{double} тип данных, по меньшей мере, столь же большой как и тип
@code{float}, но может быть большим.  Его минимальное значение хранится в
@code{DBL_MIN}, а его максимальное значение хранится в @code{DBL_MAX}.


@item @code{long double}
@cindex @code{long double} data type
@*
@code{long double} тип данных, по меньшей мере, столь же большой как и тип
@code{float}, и может быть большим.  Его минимальное значение хранится в
@code{LDBL_MIN}, а его максимальное значение хранится в @code{LDBL_MAX}.

@end itemize
@comment --Конец типов с плавающей точкой

@noindent
Все типы данных с плавающей запятой подписаны; пытаясь использовать
@code{unsigned float}, например, вызовет ошибку компиляции.

Вот некоторые примеры объявления и определения в переменных действительных
чисел:

@example
@group
float foo;
double bar = 114.3943;
@end group
@end example

@noindent
Первая строка объявляет переменную с типом чило с плавающей точкой и именем
@code{foo}, но не определяет её значение; она остается не инициализированой,
и её значение не следует учитывать как нечто конкретное.

Типы вещественного числа, представленные в Cи, являются числами с конечной
точностью, и, соответственно, не все действительные числа могут быть
представлены точно.  Большинство компьютерных систем, которые GCC
компилирует используют бинарное представление для действительных чисел,
которое не в состоянии точно представлять числа, такие, как, например, 4,2.
По этой причине, мы рекомендуем вам не сравнивать действительные числа для
точного равенства использовать оператор @code{==}, а проверить, что
действительные числа находятся в пределах допустимого отклонения.

Есть другие, более тонкие последствия этих неточных представлений; для
получения более подробной информации смотреть очерки бумаг Дэвида Голдберга
@cite{Что каждый компьютерный ученый должен знать о арифменике с плавающей
точкой} в секции 4.2.2 Дональда Кнута @cite{Искусство Компьютерного
Программирования}.


@node Complex Number Types
@subsection Типы Комплексные Числа
@cindex complex number types
@cindex data types, complex number
@cindex types, complex number

GCC ввел некоторые типы комплексных чисел как расширение C89.  Аналогичные
функции были введены в C99@footnote{C++ также имеет поддержку комплексных чисел, но она не совместима с типами ISO C99.}, но существует ряд отличий.
Сначала мы опишем стандартные типы комплексных чисел.

@menu
* Standard Complex Number Types::
* GNU Extensions for Complex Number Types::
@end menu

@node Standard Complex Number Types
@subsubsection Стандартные типы Комплексных Чисел
Комплексные типы были введены в C99.  Есть три комплексных типа:

@itemize @w{}
@item @code{float _Complex}
@item @code{double _Complex}
@item @code{long double _Complex}
@end itemize

Имена здесь начинаются с символом подчеркивания и заглавной буквой, чтобы
избежать конфликтов с идентификаторами уже существующих программ.
Стандартный файл заголовка @code{<complex.h>} C99 вводит некоторые
макросы, которые делают использование сложных типов проще.

@itemize @w{}
@item @code{complex}
@*
Расширяется до @code{_Complex}.  Это позволяет переменной быть объявленой
​​как @code{double complex}, что кажется более естественным.

@item @code{I}
@*
Константа типа @code{const float _Complex}, имеющая значение мнимой единицы
@math{i}.
@end itemize

@code{<complex.h>} заголовочный файл также объявляет ряд функций для
выполнения вычислений с комплексными числами, например, функциями
@code{creal} и @code{cimag} которые, соответственно, возвращают
действительные и мнимые части числа @code{double complex}.  Также
предусмотрены и другие функции, как показано в следующем примере:

@example
#include <complex.h>    
#include <stdio.h>  

void example (void) 
@{    
  complex double z = 1.0 + 3.0*I; 
  printf ("Phase is %f, modulus is %f\n", carg (z), cabs (z));        
@}  
@end example

@node GNU Extensions for Complex Number Types
@subsubsection GNU Расширение для Типов Комплексных Типов
GCC также введены комплексные типы, как расширение GNU для C89, но написание
отличается.  Комплексные типы с плавающей точкой в ​​расширении C89 GCC
являются:

@itemize @w{}
@item @code{__complex__ float}
@item @code{__complex__ double}
@item @code{__complex__ long double}
@end itemize

Расширение GCC' позволяет использовать комплексные типы, в отличии от типов
с плавающей точкой, для объявления целочисленных комплексных типов, так что
вы можете объявить комплексные символьные и комплексные целочисленные типы;
на самом деле @code{__complex__} может быть использован с любым из
примитивных типов данных.  Мы не дадим вам полный список всех возможностей,
но вот некоторые примеры:

@itemize @bullet

@item @code{__complex__ float}
@*
@code{__complex__ float} тип данных имеет два компонента: реальную часть и
мнимую часть, обе из которых относятся к типу данных @code{float}.


@item @code{__complex__ int}
@*
Тип данных @code{__complex__ int} также имеет два компонента: реальную часть
и мнимую часть, обе из которых относятся к типу данных @code{int}.

@end itemize
@comment --Конец списка типов __complex__

Для того, чтобы извлечь действительную часть комплексного числа, используйте
ключевое слово @code{__real__}, затем выражение.  Кроме того, используйте
@code{__imag__} чтобы извлечь мнимую часть.
 
@example
@group
__complex__ float a = 4 + 3i;

float b = __real__ a;          /* @r{@code{b} это 4.} */
float c = __imag__ a;          /* @r{@code{c} это 3.} */
@end group
@end example
 
Этот пример создает переменную @code{a} типа комплексное число с плавающей
точкой , и определяет её реальную часть, как 4 и мнимую часть, как 3.  Далее
действительная часть значения переменной присваивается переменной типа число
с плавающей точкой @code{b}, а мнимая часть этого значения, присваивается
переменной @code{c} типа числа с плавающей точкой.


@c --------------------------------------------------------------------------
@node Enumerations
@section Перечисления
@cindex enumerations
@cindex types, enumeration
@cindex data types, enumeration

Перечисление представляет собой тип пользовательских данных, используемый для
хранения постоянных целочисленных значений, и обращения к ним по именам.  По
умолчанию эти значения имеют тип @code{signed int}.  Однако, вы можете
использовать опцию компилятора GCC @code{-fshort-enums} для использования
типа наименьшего возможного числа, который будет использоваться вместо этого.
Оба эти поведения соответствуют стандарту C89, но смешанное использование
этих вариантов в рамках одной и той же программы может привести к
несовместимости.

@menu
* Defining Enumerations::       
* Declaring Enumerations::      
@end menu

@node Defining Enumerations
@subsection Определение Перечисления
@cindex defining enumerations
@cindex enumerations, defining

Определяется перечисление с помощью @code{enum} ключевого слова, за которым
следует имя перечисления (это необязательно), за которым следует список имен
констант (разделенных запятыми и заключены в фигурные скобки), и
заканчивается точкой с запятой.

@example
@group
enum фрукты @{виноград, вишня, лимон, киви@};
@end group
@end example

Этот пример определяет перечисление, @code{фрукты}, которое содержит четыре
постоянных целых значения, @code{виноград}, @code{вишня}, @code{лимон} и
@code{киви}, чьи значения по умолчанию, 0, 1, 2 и 3, соответственно.  Вы
также можете указать один или несколько значений в явном виде:

@example
@group
enum ешё_фрукты @{банан = -17, яблоко, черника, манго@};
@end group
@end example

Этот пример определяет @code{банан} как @minus{}17, а остальные значения
увеличиваются на 1: @code{яблоко} является @minus{}16, @code{черника}
является @minus{}15 и @code{манго} является @minus{}14.  Если не указано
иное, значение перечисления равно на один больше, чем предыдущее значение (и
первое значение по умолчанию равно 0).

Вы также можете обратиться к значению перечисления, определенное ранее в том
же перечислении:

@example
@group
enum вот_ещё_фрукты @{кумкват, малина, персик,
                     слива = персик + 2@};
@end group
@end example

В этом примере, @code{кумкват} устанавливается в 0, @code{малина} в 1,
@code{персик} в 2, и @code{слива} в 4.

Вы не можете использовать одно и тоже имя для перечисления @code{enum} как
@code{struct} или @code{union} в той же области.  (ВопросTypes439)

@node Declaring Enumerations
@subsection Объявление Перечисления
@cindex declaring enumerations
@cindex enumerations, declaring

Вы можете объявлять переменные типа перечисления как при определении
перечисления так и позже.  Этот пример объявляет одну переменную с именем
@code{мои_фрукты} типа @code{enum фрукты}, все в одном заявлении:

@example
@group
enum фрукты @{банан, яблоко, черника, манго@} мои_фрукты;
@end group
@end example

@noindent
в то время как в этом примере объявляется тип и переменная отдельно:

@example
@group
enum фрукты @{банан, яблоко, черника, манго@};
enum фрукты мои_фрукты;
@end group
@end example

(Конечно, вы не смогли бы объявить так, не объявив вначале перечисление
@code{фрукты}.)

Хотя такие переменные относятся к типу перечисления, вы можете присвоить им
любое значение, которое вы могли бы присвоить переменной типа  @code{int},
включая значение других перечислений.  Кроме того, любой переменной, которая
может быть назначено значение типа @code{int} может быть присвоено значение
из перечисления.

Тем не менее, вы не можете изменить значение в перечислении, как только оно
был определено; они являются константыми значениями.  Например, это не будет
работать:

@example
@group
enum фрукты @{банан, яблоко, черника, манго@};
банан = 15;  /* @r{Вы не можете сделать это!} */
@end group
@end example

Перечисления могут быть использованы в сочетании с оператором @code{switch},
потому что компилятор может предупредить вас, если вы не смогли обработать
одно из значений перечисления.  Используя пример выше, если ваш код
обрабатывает только @code{банан}, @code{яблоко} и @code{манго}, без
@code{черника}, GCC может генерировать предупреждение.

@c ----------------------------------------------------------------------------
@node Unions
@section Unions
@cindex unions
@cindex types, union
@cindex data types, union

Объединение представляет собой тип пользовательских данных, используемый для
хранения нескольких переменных в одном и том же пространстве памяти.  Хотя вы
можете получить доступ к любой из этих переменных в любое время, вы должны
читать только по одной из них в одно и то же время --- присвоения одного
значения перезаписывает значения другой.  (ВопросTypes503)


@menu
* Defining Unions::             
* Declaring Union Variables::   
* Accessing Union Members::     
* Size of Unions::              
@end menu

@node Defining Unions
@subsection Определение Объединения
@cindex defining unions
@cindex unions, defining

Вы определяете объединение, используя ключевое слово @code{union} с
последующим объявлением элементов объединения, заключенные в фигурные скобки.
Вы объявляете каждый элемент объединения так же, как вы обычно объявляете
переменную --- используя тип, данных за которым следует одно или несколько
имён переменных, разделенных запятыми, и заканчиваете точкой с запятой.
Затем заканчиваете определение объединения точкой с запятой после закрывающей
скобки.

Вы должны также включить имя для объединения между @code{union} ключевым
словом и открывающей скобкой.  Это синтаксически не обязательно, но если вы
не укажите имя, вы не можете обратиться к этому типу данных объединения в
дальнейшем в программе (без @code{typedef}, @pxref{The typedef Statement}).

Ниже приведен пример определения простого объединения для сохранения целого
числа и числа с плавающей точкой:

@example
@group
union числа
  @{
    int i;
    float f;
  @};
@end group
@end example

Это определяет объединение с именем @code{числа}, которое содержит два
элементачлена, @code{i} и @code{f}, которые имеют тип @code{int} и
@code{float} соответственно.


@node Declaring Union Variables
@subsection Объявление Переменных Объединения
@cindex declaring union variables
@cindex union variables, declaring

Вы можете объявлять переменные типа объединения, как при первоначальном
определении объединения, так и после его определения, если вы дали
объединению имя.

@menu
* Declaring Union Variables at Definition::  
* Declaring Union Variables After Definition::  
* Initializing Union Members::   
@end menu

@node Declaring Union Variables at Definition
@subsubsection Объявление Переменных Объединения при Определении
@cindex declaring union variables at definition
@cindex union variables, declaring at definition

Вы можете объявлять переменные типа объединения, когда вы определяете тип
объединения, помещая имена переменных после закрывающей скобки определения
объединения, но до завершающей точки с запятой.  Вы можете объявить более чем
одну такую ​​переменную, разделяя их запятыми.

@example
@group
union числа
  @{
    int i;
    float f;
  @} первое_число, второе_число;
@end group
@end example

Этот пример объявляет две переменные типа @code{union числа},
@code{первое_число} и @code{второе_число}.



@node Declaring Union Variables After Definition
@subsubsection Объявление Переменных Объединения После его Определения
@cindex declaring union variables after definition
@cindex union variables, declaring after definition

Вы можете объявлять переменные типа объединение после того, как вы
определили объединение, используя @code{union} ключевое слово и имя, которое
вы задали типу объединения, за которым следует одно или несколько имен
переменных, разделенных запятыми.


@example
@group
union числа
  @{
    int i;
    float f;
  @};
union числа первое_число, второе_число;
@end group
@end example

Этот пример объявляет две переменные типа @code{union числа},
@code{первое_число} и @code{второе_число}.


@node Initializing Union Members
@subsubsection Инициализация Членов Объединения
@cindex initializing union members
@cindex union members, initializing

Вы можете инициализировать первый элемент переменной объявления при его
объявлении:

@example
@group
union числа
  @{
    int i;
    float f;
  @};
union числа первое_число = @{ 5 @};
@end group
@end example

В этом примере элемент @code{i} в переменной @code{первое_число} получает
значение 5, а элемент @code{f} остаётся с недействительным значением.

Другой способ инициализации элемента объединения - это явно указать имя
нужного элемента для инициализации.  Таким образом, вы можете
инициализировать тот элемент который хотите, а не только первый.  Есть два
способа, которые можно использовать --- либо имя элемента с двоеточием, а
затем его значение, например:

@example
@group
union числа первое_число = @{ f: 3.14159 @};
@end group
@end example

@noindent
или предварить имя элемента объединения точкой и присвоить ему значение с
помощью оператора присваивания, как здесь:

@example
@group
union числа первое_число = @{ .f = 3.14159 @};
@end group
@end example

Вы также можете инициализировать элемент объединения при объявлении
переменной объединения во время её определения:

@example
@group
union числа
  @{
    int i;
    float f;
  @} первое_число = @{ 5 @};
@end group
@end example



@node Accessing Union Members
@subsection Доступ к Элементам Объединения
@cindex accessing union members
@cindex union members, accessing

Вы можете получить доступ к элементам переменной объединения с помощью
оператора доступа к элементу.  Вы помещаете имя переменной объединения на
левой стороне оператора, а имя элемента объединения с правой стороны.

@example
@group
union числа
  @{
    int i;
    float f;
  @};
union числа первое_число;
первое_число.i = 5;
первое_число.f = 3.9;
@end group
@end example

Обратите внимание, в этом примере, что переопределяются значения как элемента
@code{f} так и хранящееся в элементе @code{i}.  (ВопросTypes697)

@c Если элемент объединения доступен после того, как значение было сохранено
@c в другом элементе, поведение определяется реализацией, но этот документ не
@c определяет поведение. Существует исключение
@c хотя: если два члена являются структурами, и они имеют общую исходную
@c последовательность.

@node Size of Unions
@subsection Размер Объединений
@cindex size of unions
@cindex unions, size of

Размер объединения равен размеру его наибольшего элемента.  Рассмотрим первый
пример объединения из этого раздела:

@example
@group
union числа
  @{
    int i;
    float f;
  @};
@end group
@end example

@noindent Размер типа данных этого объединения такой же, как при определении
@code{sizeof (float)}, так самый большой тип у элементов этого объединения
это @code{float}.  Поскольку все элементы объединения расположены в одном
и том же пространстве памяти, размер типа данных объединения, не должен
расчитываться на возможность помещения суммы сразу всех типов элементов, а
должен быть достаточно большим, чтобы вместить самый большой из типов
содержащихся элементов. (ВопросTypes729)


@c --------------------------------------------------------------------------
@node Structures
@section Структуры
@cindex structures
@cindex types, structure
@cindex data types, structure

Структура - это определяемый программистом тип данных, состоящий из
переменных других типов данных (в том числе, возможно, другие типы структур).

@menu
* Defining Structures::         
* Declaring Structure Variables::  
* Accessing Structure Members::  
* Bit Fields::                  
* Size of Structures::          
@end menu

@node Defining Structures
@subsection Определение Структур
@cindex defining structures
@cindex structures, defining

Вы определяете структуру, используя ключевое слово @code{struct} с
последующим объявлением элементов структуры, заключенных в скобки.  Вы
объявляете каждый элемент структуры так же, как вы обычно объявляете
переменную --- используя тип данных за которым следует одно или несколько
имён переменных, разделенных запятыми, и заканчиваете точкой с запятой.
Затем завершение определения структуры с точкой с запятой после закрывающей
скобки.

Вы должны также включать включить имя структуры между @code{struct} ключевым
словом и открывающей скобкой.  Это необязательно, но если вы опустите имя, не
сможетемпотом обратиться к этому типу структуры данных (без @code{typedef},
@pxref{The typedef Statement}).

Ниже приведен пример определения простой структуры для хранения координат х и
у точки:

@example
@group
struct точка
  @{
    int x, y;
  @};
@end group
@end example

Это определяет тип структуры с именем @code{struct точка}, которая содержит
два элемента @code{x} и @code{y}, оба из которых имеют тип @code{int}.

Структуры (и объединения) могут содержать экземпляры других структур и
объединений, но, конечно, не самих себя.  Вполне возможно, для типов
структуры или объединения, содержать поле, которое является указателем на
тот же тип стркутуры (@pxref{Incomplete Types}).

@node Declaring Structure Variables
@subsection Объявление Переменных Структуры
@cindex declaring structure variables
@cindex structure variables, declaring

Можно объявлять переменные типа структуры, когда определяется тип структуры и
после её определения, если задано имя структуре.


@menu
* Declaring Structure Variables at Definition::  
* Declaring Structure Variables After Definition::  
* Initializing Structure Members::  
@end menu

@node Declaring Structure Variables at Definition
@subsubsection Объявление Переменной Структуры в Определении
@cindex declaring structure variables at definition
@cindex structure variables, declaring at definition

Можно объявлять переменные типа структуры, когда определяется тип структуры,
поместив имена переменных после закрывающей скобки определения структуры, но
до заключительной точки с запятой объявления.  можете объявить более чем одну
такую ​​переменную, разделив их запятыми.

@example
@group
struct точка
  @{
    int x, y;
  @} первая_точка, вторая_точка;
@end group
@end example

Этот пример объявляет две переменные типа @code{struct точка},
@code{первая_точка} и @code{вторая_точка}.



@node Declaring Structure Variables After Definition
@subsubsection Объявление Переменных Структур После Определения
@cindex declaring structure variables after definition
@cindex structure variables, declaring after definition

Можно объявлять переменные типа структуры после определения структуры,
используя ключевое слово @code{struct} и имя типа структуры, за которым
следует одно или несколько имен переменных, разделенных запятыми.


@example
@group
struct точка
  @{
    int x, y;
  @};
struct point первая_точка, вторая_точка;
@end group
@end example

Этот пример объявляет две переменные типа @code{struct точка},
@code{первая_точка} и @code{втора_точка}.


@node Initializing Structure Members
@subsubsection Инициализация Элементов Структуры
@cindex initializing structure members
@cindex structure members, initializing

Можно инициализировать элемент типа структуры при определеннии переменной
структуры, нужным значением.  

Если не инициализировать переменную структуры, эффект зависит от того, имеет
ли она статическое хранение (@pxref{Storage Class Specifiers}) или нет.  Если
да, то элементы с целочисленными типами инициализируются значением 0 а
элементы с типом указатель инициализируются значением NULL; в противном
случае, значение элементов структуры является неопределенным.

Один из способов, чтобы инициализировать структуру - это указать значения
разделённые запятыми внутри фигурных скобок.  Эти значения присваиваются
элементам структуры в том же порядке, в котором они объявлены в объявлении
структуры.


@example
@group
struct точка
  @{
    int x, y;
  @};
struct точка первая_точка = @{ 5, 10 @};
@end group
@end example

В этом примере элемент @code{x} структуры @code{первая_точка} получает
значение 5, а элемент структуры @code{y} получает значение 10.

Другой способ инициализации элементов - это указать имя элемента для
инициализации.  Таким образом, можно инициализировать элементы в любом
порядке, и даже оставить некоторые из них не инициализироваными.  Есть два
метода, которые можно использовать.  Первый метод доступен в C99 и как
расширение C89 в GCC:

@example
@group
struct точка первая_точка = @{ .y = 10, .x = 5 @};
@end group
@end example

Кроме того, можно опустить точку и использовать вместо этого двоеточие вместо
символа @samp{=}, хотя это расширение GNU C:

@example
@group
struct точка первая_точка = @{ y: 10, x: 5 @};
@end group
@end example

Можно инициализировать элементы переменной типа структура, при объявлении
переменной в процессе определения структуры:

@example
@group
struct точка
  @{
    int x, y;
  @} первая_точка = @{ 5, 10 @};
@end group
@end example

Кроме того, можно также опустить инициализацию некоторых элементов переменной
структуры:

@example
@group
struct точка
  @{
    int x, y;
    char *p;
  @};
struct pointy первая_точка = @{ 5 @};
@end group
@end example

Здесь @code{x} устанавливается в 5, @code{y} устанавливается в 0, и @code{p}
инициализируется NULL.  Здесь правило предписывает то, что @code{y} и
@code{p} инициализируются так же, как если бы они были статическими
переменными.
@c смотреть ANSI C89, секция 6.5.7, ``Инициализация''.


Вот еще один пример, который инициализирует элемент структуры, который
является сам переменной структуры:

@example
@group
struct точка
  @{
    int x, y;
  @};

struct прямоугольник
  @{
    struct точка верхняя_левая, правая_нижняя;
  @};

struct прямоугольник мой_прямоугольник = @{ @{0, 5@}, @{10, 0@} @};
@end group
@end example

Этот пример определяет структуру @code{прямоугольник} состоящую из двух
элементов переменных структуры @code{точка}.  Затем объявляется одна
переменная типа @code{struct прямоугольник} и инициализируются её элементы.
Поскольку ее элементы являются переменными с типом структура, используется
дополнительный набор скобок, окружающих элементы, которые принадлежат к
переменным структура @code{точка}.  Тем не менее, эти дополнительные скобки
не требуются обязательно; они используются чтобы человеку легче было читать
код.



@node Accessing Structure Members
@subsection Доступ к Элементам Структуры
@cindex accessing structure members
@cindex structure members, accessing

Можно получить доступ к членам переменной структуры с помощью оператора
доступа к элементу @code{ТОЧКА}.  Вы помещаете имя переменной структуры на
левой стороне оператора @code{ТОЧКА}, а имя элемента с правой стороны.

@example
@group
struct точка
  @{
    int x, y;
  @};

struct точка первая_точка;

первая_точка.x = 0;
первая_точка.y = 5;
@end group
@end example

Также можно получить доступ к элементу переменной структуры, которая сама
является элементом переменной структуры.

@example
@group
struct прямоугольник
  @{
    struct точка верхняя_левая, нижняя_правая;
  @};

struct прямоугольник мой_прямоугольник;

мой_прямоугольник.верхняя_левая.x = 0;
мой_прямоугольник.верхняя_левая.y = 5;

мой_прямоугольник.нижняя_правая.x = 10;
мой_прямоугольник.нижняя_правая.y = 0;
@end group
@end example



@node Bit Fields
@subsection Битовы Поля
@cindex bit fields
@cindex fields, bit

Можно создавать структуры с целочисленными элементами нестандартных размеров,
называемые @emph{битовыми полями}.  Можно сделать это, указав целочисленный
элемент (@code{int}, @code{char}, @code{long int}@:), как обычно, и вставив
далее двоеточие, а затем число бит, которое элемент должен занимать и затем
завершающую точку с запятой.

@example
@group
struct карта
  @{
    unsigned int масть : 2;
    unsigned int старшенство : 4;
  @};
@end group
@end example

Этот пример определяет тип структуры с двумя битовыми полями, @code{масть} и
@code{старшенство}, которые занимают 2 и 4 бита соответственно. @code{suit} может содержать значение от 0 до 3, и @code{старшинство} может содержать
значение от 0 до 15.  Обратите внимание, что эти битовые поля были объявлены
как тип @code{unsigned int}; если бы они были определенены обычно как
целочисленные, то их диапазон был бы от @minus{}2 до 1 и от @minus{}8 до 7,
соответственно.

В более общем смысле, диапазон беззнакового битового поля из @math{N} бит
составляет от 0 до @math{2^N - 1}, а диапазон знакового битового поля
составляет @math{N} бит от @math{-(2^N) / 2} до @math{((2^N) / 2) - 1}.

@c ??? Хотите исследовать это дальше...

@c Избегайте использование подписанных битовых полей размера в 1 бит, так как
@c это интерпретация знакового одного бита (то есть, определяется установлен
@c знак числа или нет) реализации.  GCC реализует его как знаковый бит.

@c @c @c По крайней мере, это делается на платформе которую я опробовал.
@c Не уверенности относительно других платформ.

Битовые поля могут быть указаны без имени, в целях контроля, какие биты
используются фактически внутри содержащего блока.  Однако, эффект от этого
не очень переносим, и это редко бывает полезным.  Можно установить битовое
поле размером в 0, что указывает, что последующие битовые поля - это не
дополнительные битовые поля и должны быть упакованы в блок, содержащий
предыдущее битовое поле.  Это также как правило, не полезно.

Нет возможности взять адрес битового поля сиспользованием оператора взятия
адреса @code{&} (@pxref{Pointer Operators}).  (ВопросTypes1062)

@node Size of Structures
@subsection Размер Cтруктур
@cindex size of structures
@cindex structures, size of

Размер типа структуры равен сумме размеров всех её членов, и возможно,
включая дополненин, чтобы обеспечить типу структуры выравнивание до
определенной границы байта.  Детали различаются в зависимости от компьютерной
платформы, но будет нетипичным, увидеть структуры дополненные до выравнивания
на четырёх- или восемь байтовых границах.  Это делается для того, чтобы
ускорить доступ в памяти к экземплярам типа структуры. (ВопросTypes1074)

В качестве расширения GNU, GCC позволяет создавать структуры без каких-либо
элементов.  Такие структуры имеют нулевой размер.

Если требуется явно опустить заполнение для типов структур (что, в свою
очередь, уменьшает скорость доступа к структурам в памяти), то GCC
обеспечивает несколько способов отключения упаковки.  Быстрый и простой
способ заключается в использовании опции @code{-fpack-struct} компилятора.
Для получения более подробной информации об отключенмм упаковку, пожалуйста,
обратитесь к руководству GCC, которое соответствует вашей версии компилятора.

@c -------------------------------------------------------------------------
@node Arrays
@section Массивы
@cindex arrays
@cindex types, array
@cindex data types, array

Массив представляет собой структуру данных, которая позволяет хранить один
или несколько элементов в памяти последовательно.  В Cи, элементы массива
индексируются с нулевого значения индекса, а не с единицы.

@menu
* Declaring Arrays::
* Initializing Arrays::
* Accessing Array Elements::
* Multidimensional Arrays::
* Arrays as Strings::
* Arrays of Unions::
* Arrays of Structures::
@end menu


@node Declaring Arrays
@subsection Объявление Массивов
@cindex declaring arrays
@cindex arrays, declaring

Объявляется массив, указанием типа данных для его элементов, его имени и
количества элементов которые он может хранить.  Вот пример, который
объявляет массив, который может хранить десять целых чисел:

@example
@group
int мой_массив[10];
@end group
@end example


Для стандартного кода Cи, количество элементов в массиве, должно быть
указано положительным значением.

В качестве расширения GNU, число элементов может быть нулевым.  Нулевая длина
массивы являются полезна в качестве последнего элемента структуры, который
на самом деле является заголовком для объекта переменной длинны:

@example
@group
struct line
@{
  int length;
  char contents[0];
@};

@{
  struct line *this_line = (struct line *)
    malloc (sizeof (struct line) + this_length);
  this_line -> length = this_length;
@}
@end group
@end example

Другое расширение GNU позволяет объявить размер массива с помощью переменных,
а не только с помощью констант.  Например, вот определение функции, которое
объявляет массив, используя свой параметр, как значение количества элементов
массива:

@example
@group
int
my_function (int number)
@{
  int my_array[number];
  @dots{};
@}
@end group
@end example


@node Initializing Arrays
@subsection Инициализация Массивов
@cindex initializing arrays
@cindex arrays, initializing

Можно инициализировать элементы массива при его объявлении, перечисляя
значения инициализации, разделенных запятыми, в фигурных скобок.  Вот пример:

@example
@group
int my_array[5] = @{ 0, 1, 2, 3, 4 @};
@end group
@end example

Не нужно явно инициализировать все элементы массива.  Например, этот код
инициализирует первые три элемента массива, как указано, а все остальные
инициализирует значением по умолчанию, в этом случае равного нулю:

@example
@group
int my_array[5] = @{ 0, 1, 2 @};
@end group
@end example

При использовании стандарта ISO C99 или C89 с расширениями GNU, можно
инициализировать элементы массива не по порядку, указывая индекс массива для
инициализации.  Чтобы достич этого, дополнительно включаетя индекс массива в
скобках, и, возможно, оператор присваивания, перед значением. Вот пример:

@example
@group
int мой_массив[5] = @{ [2] 5, [4] 9 @};
@end group
@end example
@c
@noindent
Или, используя оператор присваивания:

@example
@group
int мой_массив[5] = @{ [2] = 5, [4] = 9 @};
@end group
@end example

@noindent
Оба этих примера эквивалентны:

@example
int мой_массив[5] = @{ 0, 0, 5, 0, 9 @};
@end example


При использовании расширений GNU, можно инициализировать диапазон элементов
значением, указав первые и последние индексы, в виде
@code{ [@var{first}] ... [@var{last}] }.  Вот пример:

@example
@group
int новый_массив[100] = @{ [0 ... 9] = 1, [10 ... 98] = 2, 3 @};
@end group
@end example

Это инициализирует элементы с индексами от 0 до 9 в значение 1, элементы
с индексом от 10 до 98 в значение 2, а элемент 99 в значение 3.  (Также можноявно написать @code{[99] = 3}).  Кроме того, обратите внимание, что
@emph{должны быть} пробелы с обеих сторон выражения @samp{...}.

Если инициализировать каждый элемент массива, то не нужно указывать размер
массива; его размер определяется числом элементов инициализации.  Вот пример:

@example
@group
int мой_массив[] = @{ 0, 1, 2, 3, 4 @};
@end group
@end example

Хотя здесь явно не указывается, что массив состоит из пяти элементов,
используется @code{мой_массив[5]} инициализируя пять элементов, основываясь
на фактическое колличество.

С другой стороны, если указать, какие элементы инициализируются, то размер
массива равен наибольшему значению индекса инициализированного элемента плюс
один.  Например:

@example
@group
int мой_массив[] = @{ 0, 1, 2, [99] = 99 @};
@end group
@end example

В этом примере, только четыре элемента инициализации, но последний 
инициализированный элемент массива имеет индекс 99, таким образом, массив
состоит из 100 элементов.


@node Accessing Array Elements
@subsection Доступ к Элементам Массива
@cindex accessing array elements
@cindex array elements, accessing

Можно получить доступ к элементам массива, указав имя массива, а затем индекс
элемента, заключенный в квадратные скобки.  Следует помнить, что элементы
массива нумеруются, начиная с нуля.  Вот пример:

@example
@group
my_array[0] = 5;
@end group
@end example

Это присваивает значение 5 первому элементу в массиве, в нулевой позиции.
Можно рассматривать отдельные элементы массива, как переменные любого типа
данных из которых состоит массив.  Например, если есть массив, заполненный
данными типа структура, можно получить доступ к элементам структуры, так:
(ВопросTypes1277)

@example
@group
struct точка
@{
  int x, y;
@};
struct точка точка_массив[2] = @{ @{4, 5@}, @{8, 9@} @};
точка_массив[0].x = 3;
@end group
@end example



@node Multidimensional Arrays
@subsection Многомерные Массивы
@cindex multidimensional arrays
@cindex arrays, multidimensional

Можно создавать многомерные массивы или ``массивы массивов''.  Делается это,
добавлением дополнительного набора скобок и указания длинны массива для
каждого вложенного массива, если нужно указать колличество элементов, которое
массив будет иметь.  Например, ниже объявление для двумерного массива,
который содержит пять элементов в каждом элементе (массив из двух элементов
массивов, каждый из которых, сам состоит из пяти элементов массива):

@example
@group
int двух_уровневый_массив[2][5] @{ @{1, 2, 3, 4, 5@}, @{6, 7, 8, 9, 10@} @};
@end group
@end example

Доступ к элементу многомерного массива осуществляется путём указания
желаемого индекса обоих массивов:

@example
@group
двух_уровневый_массив[1][3] = 12;
@end group
@end example

В нашем примере, @code{двух_уровневый_массив[0]} это сам массив.  Элемент
@code{двух_уровневый_массив[0][2]} за которым следует
@code{двух_уровневый_массив[0][3]}, а не @code{двух_уровневый_массив[1][2]}.

@node Arrays as Strings
@subsection Строки как Массивы
@cindex arrays as strings
@cindex strings, arrays as

Можно использовать массив символов для хранения строки
(@pxref{String Constants}).
Массив может содержать и буквенные и небуквенные символы.

@cindex string arrays, declaring
@cindex declaring string arrays
Когда объявляется массив, можно указать количество элементов, которые он
будет иметь.  Это число будет максимальным количеством символов, которые
может содержать строка, включая нулевой символ завершения строки.  Если
выбирается этот вариант, то не нужно инициализировать массив при его
объявлении.  Кроме того, можно просто инициализировать массив значением, и
тогда его размер будет точно достаточно большим, чтобы вместить все строки,
который использовались для его инициализации.

@cindex string arrays, initializing
@cindex initializing string arrays
Есть два различных способа инициализации массива.  Можно указать список
символов, разделенных запятыми и заключенных в фигурные скобки, или можно
указать строку, заключённую в двойные кавычки.

Вот несколько примеров:

@example
@group
char синий[26];
char желтый[26] = @{'ж', 'е', 'л', 'т', 'ы', 'й', '\0'@};
char оранжевый[26] = "оранжевый";
char серый[] = @{'с', 'е', 'р', 'ы', 'й', '\0'@};
char лосось[] = "лосось";
@end group
@end example

В каждом из этих случаев нулевой символ @code{\0} всегда завершает строку,
даже если он явно не указано.  (Обратите внимание, что если инициализировать
строку, используя массив отдельных символов, то нулевой символ
@emph{требуется} указывать.  Он может появится произвольно, но это редкий
случай, и не следует на него полагаться.)


После инициализации, нельзя присвоить массиву новый строковый литерал с
помощью оператора присваивания.  Например, это @emph{не сработает}:

@example
@group
char лемон[26] = "заварной крем";
лемон = "соус стейк";      /* @r{Ошибка!} */
@end group
@end example

@noindent
Однако, есть функции в библиотеке GNU C, которые выполняют операции (в том
числе копирования) на строковых массивах.  Можете изменить один символ за
один раз, с помощью доступа к отдельным элементам строки, как и с любым
другим массивом:

@example
@group
char имя[] = "юля";
имя[0] = 'а';
@end group
@end example

Возможно явно указать количество элементов в массиве, а затем
инициализировать его, используя строку, которая имеет больше символов, чем
колличество элементов в массиве.  Это не хорошая идея.  Заданная превышающая
по длинне строка @emph{не} переопределит ранее заданный размер массива, и
при компиляции сгенерируется предупреждение.  Поскольку исходный размер
массива не изменяется, та часть строки, которая превышает исходный размер
записывается в смежные ячейки памяти, которые не были выделена для этого.


@node Arrays of Unions
@subsection Массивы Объединений
@cindex arrays of unions
@cindex unions, arrays of

Можно создать массив типа объединение так же, как и массив примитивного типа
данных.

@example
@group
union числа
  @{
    int i;
    float f;
  @};
union числа массив_чисел [3];
@end group
@end example

Этот пример создает 3-элементный массив типа @code{union числа} в переменной,
с именем @code{массив_чисел}.  Также можно инициализировать первый элемент
массива @code{числа}:

@example
@group
union числа массив_чисел [3] = @{ @{3@}, @{4@}, @{5@} @};
@end group
@end example

@noindent Дополнительные внутренние скобки не являются обязательными.

После инициализации, можно получить доступ к элементам объединения в массиве
с помощью оператора доступа к элементу @code{точка (.)}.  Имя массива и номер
элемента (заключенного в скобках) слева от оператора, а имя элемента справа.

@example
@group
union числа массив_чисел [3];
массив_чисел[0].i = 2;
@end group
@end example

@node Arrays of Structures
@subsection Массивы Структур
@cindex arrays of structures
@cindex structures, arrays of

Можно создать массив типа структура так же, как и массив примитивного типа
данных.

@example
@group
struct точка
  @{
    int x, y;
  @};
struct точка массив_точек [3];
@end group
@end example

Этот пример создает 3-элементный массив типа @code{struct точка} в переменной
с именем @code{массив_точек}.  Также можно инициализировать значениями
элементы структур массива:

@example
@group
struct точка массив_точек [3] = @{ @{2, 3@}, @{4, 5@}, @{6, 7@} @};
@end group
@end example

Как и в случае инициализации структур, которые содержат элементы структуры,
установка дополнительных внутренних скобок не является обязательным.  Но,
если используются дополнительные фигурные скобки, то можно частично
инициализировать некоторые структуры в массиве или полностью инициализировать
остальные по желанию:

@example
@group
struct точка массив_точек [3] = @{ @{2@}, @{4, 5@}, @{6, 7@} @};
@end group
@end example

В этом примере первому элементу массива устанавливается только значение
структуры элементe @code{x}.  Фигурные скобки, указывают присвоить значение 4
элементу @code{x} второго элемента массива, @emph{не} элементу @code{y}
первого элемента, как это было бы в случае без указания фигурных скобок.

После инициализации, можно получить доступ к элементам массива, элементам
структуры с помощью оператора доступа к элементу @code{точка (.)}.  Имя
массива и номер элемента (заключенный в скобках) устанавливается слева от
оператора, а имя элемента справа.

@example
@group
struct точка массив_точек [3];
массив_точек[0].x = 2;
массив_точек[0].y = 3;
@end group
@end example

@c --------------------------------------------------------------------------
@node Pointers
@section Указатели
@cindex pointers
@cindex types, pointer
@cindex data types, pointer

Указатели хранят адреса памяти сохраннённых констант или переменных.  Для
любого типа данных, включая как примитивные типы, так и определяемые типы,
можно создать указатель, который содержит адрес памяти экземпляра этого типа.

@menu
* Declaring Pointers::
* Initializing Pointers::
* Pointers to Unions::
* Pointers to Structures::
@end menu

@node Declaring Pointers
@subsection Объявление Указателей
@cindex declaring pointers
@cindex pointers, declaring

Указатель объявляется указанием его имени и типа данных.  Тип данных
указывает на то, какой тип имеет переменная по этому адресу в памяти для
указателя.

Для того, чтобы объявить указатель, включают (@pxref{Pointer Operators})
оператор косвенного обращения перед идентификатором.  Вот общая форма
декларации указателя:

@example
@var{тип-данных} * @var{имя};
@end example

@noindent
Пробел не является обязательным вокруг оператора косвенного обращения:

@example
@group
@var{тип-данных} *@var{имя};
@var{тип-данных}* @var{имя};
@end group
@end example

Вот пример того, чтобы объявить указатель содержащий адрес переменной типа
@code{int}:

@example
@group
int *ip;
@end group
@end example

Будьте осторожны: при объявлении нескольких указателей в одном операторе,
нужно явно объявить каждую переменную как указатель, с помощью оператора
разыменования (он же косвенного обращения):

@example
@group
int *один, *два;  /* @r{Два указателя.} */
int *один, два;   /* @r{Указатель на переменную с типом @code{int} и
                  целочисленная переменная.} */
@end group
@end example


@node Initializing Pointers
@subsection Инициализация Указателей
@cindex initializing pointers
@cindex pointers, initializing

Можно инициализировать указатель, при его объявлении, присвоив ему адрес
переменной.  Например, следующий код объявляет переменную @code{int} @samp{i}
и указатель, который инициализируется адресом @samp{i}:

@example
@group
int i;
int *ip = &i;
@end group
@end example

Обратите внимание на использование оператора взятие адреса
(@pxref{Pointer Operators}), используемого для получения адреса памяти
переменной.  После того, как объявлен указатель, @emph{не} требуется
использовать оператор разыменования с именем указателя при назначении ему
нового адреса.  Наоборот, это значение используется для того, что бы изменить
значение переменной, на адрес которой он указывает, а не значение самого
указателя.  Например:

@example
@group
int i, j;
int *ip = &i;  /* @r{@samp{ip} теперь содержит адрес @samp{i}.} */
ip = &j;       /* @r{@samp{ip} теперь содержит адрес @samp{j}.} */
*ip = &i;      /* @r{@samp{j} теперь содержит адрес @samp{i}.} */
@end group
@end example

Значение, хранящееся в указателе является целым числом: местоположение в
пространстве памяти компьютера.  Если есть желание, можно присвоить значение
указателю в явном виде с помощью литералов целых чисел, приведя указатель к
соответствующему типу.  Тем не менее, не рекомендуется такая практика, если
нет жёсткого контроля над тем, что хранится в памяти, и точно знаете, что
происходит.  Слишком легко случайно перезапись то, что не требовалося.
В большинстве случаев применения этой техники также делает код
непереносимым.

Важно отметить, что если не инициализировать указатель адресом какого-либо
существующего объекта, это не отразится нигде, и вероятно, приведёт к сбою
программы, при попытки использовать его (формально, такого рода проявления
называют @dfn{неопределенное поведение}).

@node Pointers to Unions
@subsection Указатели на Объединения
@cindex pointers to unions
@cindex unions, pointers to

Можно создать указатель типа объединение так же, как и указатель на
примитивный тип данных.

@example
@group
union числа
  @{
    int i;
    float f;
  @};
union числа первый_набор = @{4@};
union числа *числа_указатель = &первый_набор;
@end group
@end example

Этот пример создаёт новый тип объединения, @code{union числа} и объявляет
(и инициализирует первый элемент) переменную этого типа с именем
@code{первый_набор}.  Наконец, объявляется указатель типа @code{union числа},
и дает ему адрес @code{первый_набор}.

Можно получить доступ к членам переменной объединения через указатель, но
вы не можете больше использовать обычный оператор доступа к элементу.  Вместо
этого, требуется использовать оператор косвенного доступа к элементу
(@pxref{Member Access Expressions}).  Продолжая предыдущий пример, следующий
пример будет менять значение первого элемента @code{первый_набор}:

@example
@group
number_ptr -> i = 450;
@end group
@end example

Теперь элемент @code{i} в @code{первый_набор} содержит 450.


@node Pointers to Structures
@subsection Указатели на Структуры
@cindex pointers to structures
@cindex structures, pointers to

Можно создать указатель с типом структура так же, как и указатель на
примитивный тип данных.

@example
@group
struct рыба
  @{
    float длинна, ширина;
  @};
struct рыба лосось = @{4.3, 5.8@};
struct рыба *рыба_указатель = &лосось;
@end group
@end example

Этот пример создает новый тип структуры, @code{struct рыба} и заявляет (и
инициализирует) переменную этого типа с именем @code{лосось}.  Наконец,
объявляется указатель типа @code{struct рыба}, и даётся ему адрес переменной
@code{лосось}.

Можно получить доступ к элементам переменной структуры через указатель, но
нельзя больше использовать обычный оператор доступа к элементу.  Вместо этого
требуется использовать оператор косвенного доступа к элементу
(@pxref{Member Access Expressions}).  Продолжая предыдущий пример, следующий
пример изменит значения элемента @code{лосось}:

@example
@group
рыба_указатель -> длинна = 5.1;
рыба_указатель -> ширина = 6.2;
@end group
@end example

Теперь элементы @code{длинна} и @code{ширина} в @code{лосось} являются 5,1 и
6,2, соответственно.


@c --------------------------------------------------------------------------

@node Incomplete Types
@section Неполные Типы
@cindex incomplete types
@cindex types, incomplete
@cindex structures, incomplete
@cindex enumerations, incomplete
@cindex unions, incomplete

Можно определить структуры, объединения и перечисления без перечисления их
элементов (или значений, в случае перечислений).  Это производит неполный
тип.  Можно объявлять переменные неполных типов и создавать и работать с
указателями на эти типы.

@example
@group
struct точка;
@end group
@end example

В какой-то момент позже в вашей программе потребуется завершить этот тип.
Это можно сделать, определив его, как обычно:

@example
@group
struct точка
  @{
    int x, y;
  @};
@end group
@end example

Этот метод обычно используется для связанных списков:

@example
@group
struct отдельный_связанный_список
  @{
    struct отдельный_связанный_список *следующий;
    int x;
    /* здесь возможно другие элементы */
  @};
struct отдельный_связанный_список *список_начало;
@end group
@end example


@c ----------------------------------------------------------------------------
@node Type Qualifiers
@section Квалификаторы Типов
@cindex type qualifiers
@cindex qualifiers, type
@cindex @code{const} type qualifier
@cindex @code{volatile} type qualifier
@c ANSI C89, section 6.5.3. ``Type Qualifiers''.
Есть два типа квалификаторов, которые можно ДОБАВЛЯТЬ при объявлении
переменных, которые влияют на доступ к ней: @code{const} и @code{volatile}.

@code{const} определяет переменную только для чтения; после её инициализации,её значение не может быть изменено.

@example
const float pi = 3.14159f;
@end example

@noindent
В дополнение к предупреждениям компилятора, которые сигнализируют о изменении
константных значений, объявления переменных с квалификатором @code{const}
помогает компилятору в оптимизации кода.

@code{volatile} явно сообщает компилятору, что переменная будет менять своё
значение, и то что рассматривается безполезным для компилятора, например
доступ к переменной (например, с помощью указателей), не должно им
оптимизироваться.  Можно использовать объявления переменных с квалификатором
@code{volatile} для хранения данных, которые обновляются с помощью функций
обратного вызова или обработчиков сигналов.
@ref{Sequence Points and Signal Delivery}.

@example
volatile float текущаяТемпература = 40.0;
@end example

@c ----------------------------------------------------------------------------
@node Storage Class Specifiers
@section Спецификаторы Классов Хранения
@cindex storage class specifiers
@cindex specifiers, storage class
@cindex @code{auto} storage class specifier
@cindex @code{extern} storage class specifier
@cindex @code{register} storage class specifier
@cindex @code{static} storage class specifier

Есть четыре спецификатора классов хранения, которыми можно ДОПОЛНЯТЬ
объявления переменных, которые изменяют, как переменные хранятся в памяти:
@code{auto}, @code{extern}, @code{register}, и @code{static}.

Можно использовать спецификатор @code{auto} для переменных, которые являются
локальными для функции, и значение которых должно быть отброшены после
возврата из функции, в которой переменные были объявлены.  Это поведение по
умолчанию для переменных, объявленных внутри функций.

@example
@group
void
foo (int значение)
@{
  auto int x = значение;
  @dots{}
  return;
@}
@end group
@end example

Спецификатор @code{register} почти идентичен @code{auto} по назначению, за
исключением того, что он также указывает компилятору, что переменная будет
активно использоваться, и, если это возможно, должна храниться в регистре.
Нельзя использовать оператор взятия адреса, чтобы получить адрес переменной,
объявленной с спецификатором @code{register}.  Это означает, что не
получиться обратиться к элементам массива, объявленного с классом хранения
@code{register}.  На самом деле единственное, где пригодится испоьзование
такого массива, это измерение его размера с помощью @code{sizeof}.  GCC
обычно делает правильный выбор о том, какие значения требуется хранить в
регистрах, и поэтому квалификатор @code{register} не часто используется.

Спецификатор @code{static}, по существу, отрабатывает противоположно
@code{auto}: при применении к переменным внутри функции или блока, эти
переменные сохраняют свое значение даже тогда, когда функция или блок
закончены.  Это известно как @dfn{длительное статическое зранение}.

@example
@group
int
sum (int x)
@{
  static int sumSoFar = 0;
  sumSoFar = sumSoFar + x;
  return sumSoFar;
@}
@end group
@end example

@noindent
Можно также объявить переменную (или функцию) на верхнем уровне (то есть, не
внутри функции) используя спецификатор @code{static}; такие переменные видны
(глобальные переменные) для текущего исходного файла (но не для других
исходных файлов).  Это к сожалению даёт двойной смысл спецификатору
@code{static}; это второе значение известно как @dfn{статическая связь}.
Две функции или переменные, имеющие статическую связь в отдельных файлах
полностью изолированы; ни одна из них не видна за пределами файла, в котором
она объявлена.

Неинициализированные переменные, объявленные с испльзованием спецификатора
@code{extern} получают стандартные значения по умолчанию @code{0}, @code{0.0}
или @code{NULL}, в зависимости от типа переменной.  Неинициализированные
переменные, которые объявлены с использованием спецификатора @code{auto} или
@code{register} (в том числе когда используется спецификатор по умолчанию
@code{auto}) остаются неинициализированным, и, следовательно, не следует
рассматривать то, что хранит неинициализированная переменная.

@code{extern} полезно для объявления переменных, которые должны быть видимыми
для всех исходных файлов, которые входят в проект.  Нельзя инициализировать
переменную в объявлении с использовании спецификатора @code{extern}, так как
фактически не выделяется место для хранения переменной во время её
объявления.  Нужно использовать объявление с использованием спецификатора
@code{extern} (обычно в заголовочном файле, который включается другими
исходными файлами, которые должны получить доступ к переменной) где не
требуется фактическое выделения места для переменной и использовать
не-@code{extern} объявления в противном случае.  Объявления @code{extern}
может повторяться несколько раз.

@example
@group
extern int номерКлиента;

@dots{}

int номерКлиента = 0;
@end group
@end example

@xref{Program Structure and Scope}, для дополнительное информации.

@c --------------------------------------------------------------------------
@node Renaming Types
@section Переименование Типов
@cindex renaming types
@cindex types, renaming

Иногда это удобно, чтобы дать новое имя типу.  Можно сделать это с помощью
оператора @code{typedef}.  @xref{The typedef Statement}, для получения
дополнительной информации.
