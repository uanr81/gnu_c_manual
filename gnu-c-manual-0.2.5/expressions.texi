@c ??? Это может быть хорошей идеей, чтобы превратить каждый пример выражения
@c в небольшую программу, которая печатает выходные и, таким образом,
@c показывает, что выражение делает.

@c Это является частью GNU C Reference Manual
@c Copyright (C) 2007-2016 Free Software Foundation, Inc.
@c Смотрите файл gnu-c-manual.texi условия копирования.

@node Expressions and Operators
@chapter Выражения и Операторы

@menu
* Expressions::
* Assignment Operators::
* Incrementing and Decrementing::
* Arithmetic Operators::
* Complex Conjugation::
* Comparison Operators::
* Logical Operators::
* Bit Shifting::
* Bitwise Logical Operators::
* Pointer Operators::
* The sizeof Operator::
* Type Casts::
* Array Subscripts::
* Function Calls as Expressions::
* The Comma Operator::
* Member Access Expressions::
* Conditional Expressions::
* Statements and Declarations in Expressions::
* Operator Precedence::
* Order of Evaluation::
@end menu

@node Expressions
@section Выражения
@cindex expressions

@dfn{Выражение} состоит, по меньшей мере, из одного операнда и содержит ноль
или более операторов.  Операнды - это типизированные объекты, такие как
константы, переменные и вызовы функций, которые возвращают значение.  Вот
некоторые примеры:

@example
@group
47
2 + 2
cosine(3.14159) /* @r{Мы предполагаем, это возвращает значение с плавающей
точкой.} */
@end group
@end example

Круглые скобки для группировки подвыражений:

@example
( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )
@end example

@noindent
Вложенные выражения вычисляются первыми.  В приведенном выше примере,
вначале оцениваются выражения @code{3 + 10} и @code{2 * 6}, затем оцениваются
полученные выражения @code{13} и @code{12}, соответственно.  Затем @code{12}
вычитается из @code{13}, в результате чего получается @code{1}.  Наконец,
@code{1} умножается на @code{2}, в результате чего появляется @code{2}.
Самые внешние круглые скобки в примере не являются обязательными.

@cindex operators

@dfn{Оператор} определяет операцию, которая будет выполняться над его
операндом(ами).  Операторы могут иметь один, два или три операнда, в
зависимости от оператора.

@node Assignment Operators
@section Операторы Присваивания
@cindex assignment operators
@cindex operators, assignment

Операторы присваивания сохраняют значения в переменных.  Си обеспечивает
несколько вариантов операторов присваивания.

Стандартный оператор присваивания @code{=} просто сохранит значение правого
операнда в переменную, указанную в левом операнде.  Как и со всеми
операторами присваивания, левый операнд (обычно называемый как
``lvalue (левое значение)'') не может быть буквальным или постоянным
значением.

@example
@group
int x = 10;
float y = 45.12 + 2.0;
int z = (2 * (3 + function () ));

struct foo @{
  int bar;
  int baz;
@} quux = @{3, 4@};
@end group
@end example

@noindent
Обратите внимание, что, в отличие от других операторов присваивания,
описанных ниже, можно использовать простой оператор присваивания для
хранения значений структурного типа.

Составные операторы присваивания выполняют операцию с участием как левого,
так и правый операнда, затем присваивают полученное выражение левому
операнду.  Вот список составных операторов присваивания и краткое описание
того, что они делают:

@itemize

@item
@code{+=}

Складывает два операнда вместе, затем присваивает результат сложения левому
операнду.

@item
@code{-=}

Вычитает правый операнд из левого операнда, затем присваивает результат
вычитания левому операнду.

@item
@code{*=}

Перемножает два операнда, затем присваивает результат умножения левому
операнду.

@item
@code{/=}

Делит левый операнд на правый операнд, присваивает результат деления левому
операнду.

@item
@code{%=}

Выполняет деление по модулю деление двух операндов, присваивает результат
деления левому операнду.

@item
@code{<<=}

Выполненяет операцию сдвига влево с левым операндом, сдвигая на число битов,
заданное с помощью правого операнда, присваивает результат сдвига левому
операнду.

@item
@code{>>=}

Выполняет операцию сдвига вправо с левым операндом, сдвигая на число битов,
заданное с помощью правого операнда, и присваивает результат сдвига левому
операнду.

@item
@code{&=}

Выполняет поразрядную операцию @code{И} для двух операндов, и присваивает
результат операции левому операнду.

@item
@code{^=}

Выполняет поразрядную операцию @code{исключающего ИЛИ} для двух операндов,
и присваивает результат операции левому операнду.

@item
@code{|=}

Выполняет поразрядную операцию @code{ИЛИ} для двух операндов,
и присваивает результат операции левому операнду.

@end itemize
@comment  __End из соединения назначений списка операторов

Ниже приведен пример использования одного из составных операторов
присваивания:

@example
x += y;
@end example

@noindent
Поскольку нет никаких влияющих побочных эффектов при оценки переменной
@code{x} как lvalue (левого значения), приведенный выше код дает тот же
результат, что и код:

@example
x = x + y;
@end example


@c GNU C Extension -- temporarily commented out for manual 0.1
@c @node Generalized Lvalues
@c @subsubsection Generalized Lvalues
@c @cindex compound expressions as lvalues
@c @cindex expressions, compound, as lvalues
@c @cindex conditional expressions as lvalues
@c index expressions, conditional, as lvalues
@c @cindex casts as lvalues
@c @cindex generalized lvalues
@c @cindex lvalues, generalized
@c @cindex extensions, @code{?:}
@c @cindex @code{?:} extensions
@c 
@c Составные выражения, условные выражения и сдвиги разрешены, как lvalues
@c (левые значения) при ​​условии, что их операнды  также lvalues.  Это
@c означает, что можно взять их адрес или хранимое значение в них.
@c 
@c Например, можно присвоить значение выражения соединения, при условии, что @c последнее выражение в последовательности является именованным.  Эти два
@c выражения эквивалентны:
@c 
@c @example
@c (a, b) += 5
@c a, (b += 5)
@c @end example
@c 
@c Кроме того, можно взять адрес выражения соединения.  Таким образом, эти
@c два выражения эквивалентны:
@c 
@c @example
@c &(a, b)
@c a, &b
@c @end example
@c 
@c Условное выражение является допустимым, если их именованный тип не
@c является недействительным, и если оба и второй и третий операнды являются
@c действительными lvalues (левыми выражениями).  Например, эти два выражения
@c эквивалентны:
@c 
@c @example
@c (a ? b : c) = 5
@c (a ? b = 5 : (c = 5))
@c @end example
@c 
@c Составной тип является допустимым, если его именованный операнд является
@c именным.  Простое назначение которого сторона left-hand представляет
@c собой отливка работает путем преобразования в стороне right-hand первой
@c указанного типа, а затем к типу внутренней стороны выражения left-hand.
@c После этого сохраняется, значение преобразуется обратно к указанному типу,
@c чтобы стать значением задания.  Таким образом, если @code{a} имеет тип
@c @code{char *}, следующие два выражения эквивалентны:
@c (ВопросExpressions 244)
@c 
@c @example
@c (int)a = 5
@c (int)(a = (char *)(int)5)
@c @end example
@c 
@c Назначение-с-арифметической операции, такие как @code{+=}, приложенного к
@c литым выполняет арифметические операции, используя тип полученного из
@c литой, а затем продолжается, как и в предыдущем случае. Таким образом,
@c эти два выражения эквивалентны:
@c 
@c @example
@c (int)a += 5
@c (int)(a = (char *)(int) ((int)a + 5))
@c @end example

@c Вы не можете взять адрес именующее гипсе, потому что использование его
@c адреса не будет работать слаженно.  Предположим, что @code{&(int)f} были
@c разрешены, где @code{f} имеет тип @code{float}. Тогда следующий оператор
@c попытается сохранить целое битового шаблона, где число с плавающей точкой
@c принадлежит:
@c 
@c @example
@c *&(int)f = 1;
@c @end example
@c 
@c Это совершенно отличается от того, что @code{(int)f = 1} будет делать ---
@c что бы преобразовать 1 с плавающей точкой и хранить его.  Вместо того,
@c чтобы причина этого несоответствия, мы считаем, что лучше запретить
@c использование @code{&} на гипсе.
@c 
@c Если вы действительно хотите указатель @code{int *} с адресом @code{f},
@c вы можете просто написать @code{(int *)&f}.

@node Incrementing and Decrementing
@section Увеличение и Уменьшение
@cindex increment operator
@cindex decrement operator
@cindex operator, increment
@cindex operator, decrement

Оператор инкремента @code{++} добавляет 1 (еденицу) к своему операнду.
Операнд должен быть либо переменной одного из примитивных типов данных,
указателем или переменной перечисления.  Можжно применить оператор
инкремента либо до, либо после операнда. вот несколько примеров:

@example
@group
char w = '1';
int x = 5;
char y = 'B';
float z = 5.2;
int *p = &x;

++w;   /* @r{@code{w} теперь символ `2' (не число 2).} */
x++;   /* @r{@code{x} теперь 6.} */
++y;   /* @r{@code{y} теперь `C' (в системах ASCII).} */
z++;   /* @r{@code{z} теперь 6.2.} */
++p;   /* @r{@code{p} теперь @code{&x} + @code{sizeof(int)}.} */
@end group
@end example

@noindent
(Обратите внимание, что увеличивающийся указатель имеет смысл только если
есть основания полагать, что новое значение указателя будет допустимым
адресом памяти.)

Префиксное приращение, добавляет 1 к операнду перед вычислением операнда.
Постфиксное приращение добавляет 1 после того, как операнд вычислен.  В
предыдущих примерах, изменение положения оператора не будет иметь никакого
значения.  Однако, бывают случаи, когда это имеет значение:

@example
@group
int x = 5;
printf ("%d \n", x++); /* @r{Распечатает @code{x}, а затем увеличит его.} */
/* @r{Вывод 5, хотя переменная @code{x} теперь равна 6.} */
printf ("%d \n", ++x); /* @r{Приращение к @code{x}, а затем печать его.} */
/* @r{Вывод и переменная @code{x} теперь равна 7.} */
@end group
@end example

@noindent
Вывод приведенного выше примера:

@example
@group
5
7
@end group
@end example

Кроме того, можно вычесть 1 из операнда с помощью оператора декремента:

@example
@group
int x = 5;

x--; /* @r{@code{x} теперь 4.} */
@end group
@end example

@noindent
Понятия префикс и постфикс, применяются также и с оператором инкремента.

@node Arithmetic Operators
@section Арифметические Операторы
@cindex arithmetic operators
@cindex operators, arithmetic

Си обеспечивает операторы для стандартных арифметических операций: сложения,
вычитания, умножения деления, деление по модулю и отрицание.  Использование
этих операторов просто; вот несколько примеров:

@example
@group
/* @r{Сложение.} */
x = 5 + 3;
y = 10.23 + 37.332;
quux_pointer = foo_pointer + bar_pointer;
@end group
@end example

@example
@group
/* @r{Вычитание.} */
x = 5 - 3;
y = 57.223 - 10.903;
quux_pointer = foo_pointer - bar_pointer;
@end group
@end example

@noindent
Можно складывать и вычитать указатели памяти, но нельзя перемножать и делить
их.

@example
@group
/* @r{Умножение.} */
x = 5 * 3;
y = 47.4 * 1.001;
@end group
@end example

@example
@group
/* @r{Деление.} */
x = 5 / 3;
y = 940.0 / 20.2;
@end group
@end example

@noindent
Целочисленное деление положительных значений обрезает по направлению к нулю,
так что 5/3 равен 1.  Однако, если один из операндов является отрицательным,
то направление округления зависит от реализации.
@ref{Signed Integer Division} для информации о переполнении в знаковом
целочисленном делении.

@c Нужно указать GCC, как ему вести себя, если операнд отрицателен.


Оператор деление по модулю @code{%} используется, чтобы получить остаток от
деления его двух операндов.  Операнды устанавливаются по обе стороны от
оператора, и имеет значение, какой операнд на какой стороне: @code{3 % 5} или
@code{5 % 3} имеют разный результат.  Операнды должны быть выражениями
примитивного типа данных.

@example
@group
/* @r{Деление по модулю.} */
x = 5 % 3;
y = 74 % 47;
@end group
@end example

@noindent
Деление по модулю возвращает остаток, полученный после выполнения деления
целых чисел двух операндов.  Операнды должны быть примитивного целого типа.

@example
@group
/* @r{Отрицание.} */
int x = -5;
float y = -3.14159;
@end group
@end example

Если операнд используемый с оператором отрицания имеет беззнаковый тип
данных, то результат не станет отрицательным, а будет иметь максимальное
значение беззнакового типа данных, за вычетом значения операнда.

Многие системы используют в коде арифметику с дополнением до двух, и на таких
системах самое отрицательное значение, знакового типа, может находится дальше
от нуля, чем самое положительное значение.  Например, на одной платформе, эта
программа:

@example
@group
#include <limits.h>
#include <stdio.h>

int main (int argc, char *argv[]) 
@{
  int x;
  x = INT_MAX;
  printf("INT_MAX  = %d\n", x);
  x = INT_MIN;
  printf("INT_MIN  = %d\n", x);
  x = -x;
  printf("-INT_MIN = %d\n", x);
  return 0;
@}
@end group
@end example

Производит этот вывод:

@example
@group
INT_MAX  = 2147483647
INT_MIN  = -2147483648
-INT_MIN = -2147483648
@end group
@end example

Можно также применить положительный оператор для числового выражения:

@example
int x = +42;
@end example

@noindent
Числовые значения считаются положительными, если явно не сделать его
отрицательным, поэтому этот оператор не оказывает никакого влияния на работу
программы.

@node Complex Conjugation
@section Комплексное Сопряжение
@cindex complex conjugation
@cindex conjugation
 
В качестве расширения GNU, можно использовать оператор комплексного
сопряжения @code{~}, выполняет комплексное сопряжение на операнде --- то
есть, он меняет знак мнимой составляющей.  Операнд должен быть выражением
типа комплесного числа.  Вот пример:
 
@example
@group
__complex__ int x = 5 + 17i;
 
printf ("%d  \n", (x * ~x));
@end group
@end example
 
Так как мнимое число @math{(a + bi)} умноженное на его сопряжённое число
равное @math{a^2 + b^2}, приведенное выше выражение @code{printf} выведет на
печатать число 314, которое получилось из выражения @math{25 + 289}.

@node Comparison Operators
@section Операторы Сравнения
@cindex comparison operators
@cindex operators, comparison

Можно использовать операторы сравнения для определения того, как два операнда
соотносятся друг с другом: они равны друг другу, один больше, чем другой,
один меньше другого, и так далее.  При использовании любого из операторов
сравнения, результат всегда равен 1 или 0, то есть является истинной или
ложью, соответственно.

(In the following code examples, the variables @code{x} and @code{y} stand
for any two expressions of arithmetic types, or pointers.)

The equal-to operator @code{==} tests its two operands for equality.
The result is 1 if the operands are equal, and 0 if the operands are not equal.

@example
@group
if (x == y)
  puts ("x is equal to y");
else
  puts ("x is not equal to y");
@end group
@end example

The not-equal-to operator @code{!=} tests its two operands for inequality.
The result is 1 if the operands are not equal, and 0 if the operands
@emph{are} equal.

@example
@group
if (x != y)
  puts ("x is not equal to y");
else
  puts ("x is equal to y");
@end group
@end example

Comparing floating-point values for exact equality or inequality can
produce unexpected results.  @ref{Real Number Types} for more
information.

You can compare function pointers for equality or inequality; the
comparison tests if two function pointers point to the same function
or not.

Beyond equality and inequality, there are operators you can use to test
if one value is less than, greater than, less-than-or-equal-to, or
greater-than-or-equal-to another value.  Here are some code samples that
exemplify usage of these operators:

@example
@group
if (x < y)
  puts ("x is less than y");
@end group
@end example

@example
@group
if (x <= y)
  puts ("x is less than or equal to y");
@end group
@end example

@example
@group
if (x > y)
  puts ("x is greater than y");
@end group
@end example

@example
@group
if (x >= y)
  puts ("x is greater than or equal to y");
@end group
@end example


@node Logical Operators
@section Logical Operators
@cindex logical operators

Logical operators test the truth value of a pair of operands.  Any
nonzero expression is considered true in C, while an expression that
evaluates to zero is considered false.

The logical conjunction operator @code{&&} tests if two expressions
are both true.  If the first expression is false, then the second
expression is not evaluated.

@example
@group
if ((x == 5) && (y == 10))
  printf ("x is 5 and y is 10");
@end group
@end example

The logical disjunction operator @code{||} tests if at least one of
two expressions it true.  If the first expression is true, then the
second expression is not evaluated.

@example
@group
if ((x == 5) || (y == 10))
   printf ("x is 5 or y is 10");
@end group
@end example

You can prepend a logical expression with a negation operator
@code{!} to flip the truth value:

@example
@group
if (!(x == 5))
  printf ("x is not 5");
@end group
@end example

Since the second operand in a logical expression pair is not necessarily
evaluated, you can write code with perhaps unintuitive results:

@example
@group
if (foo && x++)
  bar();
@end group
@end example

@noindent
If @code{foo} is ever zero, then not only would @code{bar} not be called,
but @code{x} would not be incremented.  If you intend to increment @code{x}
regardless of the value of @code{foo}, you should do so outside of the
conjunction expression.


@node Bit Shifting
@section Bit Shifting
@cindex bit shifting
@cindex shifting

You use the left-shift operator @code{<<} to shift its first operand's bits
to the left.  The second operand denotes the number of bit places to shift.
Bits shifted off the left side of the value are discarded; new bits added
on the right side will all be 0.

@example
@group
x = 47;    /* @r{47 is 00101111 in binary.} */
x << 1;    /* @r{00101111 << 1 is 01011110.} */
@end group
@end example

Similarly, you use the right-shift operator @code{>>} to shift its
first operand's bits to the right. Bits shifted off the right side are
discarded; new bits added on the left side are @emph{usually} 0, but
if the first operand is a signed negative value, then the added bits will
be either 0 @emph{or} whatever value was previously in the leftmost bit
position.

@example
@group
x = 47;   /* @r{47 is 00101111 in binary.} */
x >> 1;   /* @r{00101111 >> 1 is 00010111.} */
@end group
@end example

For both @code{<<} and @code{>>}, if the second operand is greater
than the bit-width of the first operand, or the second operand is
negative, the behavior is undefined.

You can use the shift operators to perform a variety of interesting
hacks.  For example, given a date with the day of the month numbered
as @code{d}, the month numbered as @code{m}, and the year @code{y}, you
can store the entire date in a single number @code{x}:

@example
int d = 12;
int m = 6;
int y = 1983;
int x = (((y << 4) + m) << 5) + d;
@end example

@noindent
You can then extract the original day, month, and year out of @code{x}
using a combination of shift operators and modular division:

@example
d = x % 32;
m = (x >> 5) % 16;
y = x >> 9;
@end example

@node Bitwise Logical Operators
@section Bitwise Logical Operators
@cindex bitwise logical operators
@cindex logical operators, bitwise

C provides operators for performing bitwise conjunction, inclusive disjunction,
exclusive disjunction, and negation (complement).

Biwise conjunction examines each bit in its two operands, and when two
corresponding bits are both 1, the resulting bit is 1.  All other resulting
bits are 0.  Here is an example of how this works, using binary numbers:

@example
11001001 & 10011011 = 10001001
@end example

Bitwise inclusive disjunction examines each bit in its two operands,
and when two corresponding bits are both 0, the resulting bit is 0.  All
other resulting bits are 1.

@example
11001001 | 10011011 = 11011011
@end example

Bitwise exclusive disjunction examines each bit in its two operands, and when
two corresponding bits are different, the resulting bit is 1.  All other resulting
bits are 0.

@example
11001001 ^ 10011011 = 01010010
@end example

Bitwise negation reverses each bit in its operand:

@example
~11001001 = 00110110
@end example

In C, you can only use these operators with operands of an integer (or character)
type, and for maximum portability, you should only use the bitwise negation operator
with unsigned integer types.  Here are some examples of using these operators in
C code:

@example
@group
unsigned int foo = 42;
unsigned int bar = 57;
unsigned int quux;

quux = foo & bar;
quux = foo | bar;
quux = foo ^ bar;
quux = ~foo;
@end group
@end example

@node Pointer Operators
@section Pointer Operators
@cindex pointer operators

You can use the address operator @code{&} to obtain the memory address of
an object.

@example
@group
int x = 5;
int *pointer_to_x = &x;
@end group
@end example

It is not necessary to use this operator to obtain the address of
a function, although you can:

@example
@group
extern int foo (void);
int (*fp1) (void) = foo; /* fp1 points to foo */
int (*fp2) (void) = &foo; /* fp2 also points to foo */
@end group
@end example

Function pointers and data pointers are not compatible, in the sense
that you cannot expect to store the address of a function into a data
pointer, and then copy that into a function pointer and call it
successfully.  It might work on some systems, but it's not a portable
technique.

As a GNU extension to C89, you can also obtain the address of a label
with the label address operator @code{&&}.  The result is a
@code{void*} pointer which can be used with @code{goto}.  @xref{The
goto Statement}.

Given a memory address stored in a pointer, you can use the indirection
operator @code{*} to obtain the value stored at the address. (This is called
@dfn{dereferencing} the pointer.)

@example
@group
int x = 5;
int y;
int *ptr;

ptr = &x;    /* @r{@code{ptr} now holds the address of @code{x}.} */

y = *ptr;    /* @r{@code{y} gets the value stored at the address}
                @r{stored in @code{ptr}.} */
@end group
@end example

@noindent
Avoid using dereferencing pointers that have not been initialized to
a known memory location.


@node The sizeof Operator
@section The sizeof Operator
@cindex sizeof operator

You can use the @code{sizeof} operator to obtain the size (in bytes)
of the data type of its operand.  The operand may be an actual type
specifier (such as @code{int} or @code{float}), as well as any valid
expression.  When the operand is a type name, it must be enclosed in
parentheses.  Here are some examples:

@example
@group
size_t a = sizeof(int);
size_t b = sizeof(float);
size_t c = sizeof(5);
size_t d = sizeof(5.143);
size_t e = sizeof a;
@end group
@end example

The result of the @code{sizeof} operator is of a type called @code{size_t},
which is defined in the header file @code{<stddef.h>}.  @code{size_t} is
an unsigned integer type, perhaps identical to @code{unsigned int} or
@code{unsigned long int}; it varies from system to system.

The @code{size_t} type is often a convenient type for a loop index,
since it is guaranteed to be able to hold the number of elements in
any array; this is not the case with @code{int}, for example.

The @code{sizeof} operator can be used to automatically compute the
number of elements in an array:

@example
@group
#include <stddef.h>
#include <stdio.h>

static const int values[] = @{ 1, 2, 48, 681 @};
#define ARRAYSIZE(x) (sizeof x/sizeof x[0])

int main (int argc, char *argv[]) 
@{
    size_t i;
    for (i = 0; i < ARRAYSIZE(values); i++) 
    @{
        printf("%d\n", values[i]);
    @}
    return 0;
@}
@end group
@end example

There are two cases where this technique does not work.  The first is
where the array element has zero size (GCC supports zero-sized
structures as a GNU extension).  The second is where the array is in
fact a function parameter (@pxref{Function Parameters}).

@node Type Casts
@section Type Casts
@cindex type casts
@cindex casts

You can use a type cast to explicitly cause an expression to be of a specified
data type.  A type cast consists of a type specifier enclosed in parentheses,
followed by an expression.  To ensure proper casting, you should also enclose
the expression that follows the type specifier in parentheses.  Here is
an example:

@example
@group
float x;
int y = 7;
int z = 3;
x = (float) (y / z);
@end group
@end example

In that example, since @code{y} and @code{z} are both integers, integer
division is performed, and even though @code{x} is a floating-point
variable, it receives the value 2.  Explicitly casting the result
of the division to @code{float} does no good, because the computed
value of @code{y/z} is already 2.

To fix this problem, you need to convert one of the operands to a
floating-point type before the division takes place:

@example
@group
float x;
int y = 7;
int z = 3;
x = (y / (float)z);
@end group
@end example

@noindent Here, a floating-point value close to 2.333@dots{} is assigned to @code{x}.

Type casting only works with scalar types (that is, integer,
floating-point or pointer types).  Therefore, this is not allowed:

@example
@group
struct fooTag @{ /* members ... */ @};
struct fooTag foo;
unsigned char byteArray[8];

foo = (struct fooType) byteArray; /* @r{Fail!} */
@end group
@end example

@node Array Subscripts
@section Array Subscripts
@cindex array subscripts

You can access array elements by specifying the name of the array, and the
array subscript (or index, or element number) enclosed in brackets.  Here is
an example, supposing an integer array called @code{my_array}:

@example
@group
my_array[0] = 5;
@end group
@end example

The array subscript expression @code{A[i]} is defined as being
identical to the expression @code{(*((A)+(i)))}.  This means that many
uses of an array name are equivalent to a pointer expression.  It also
means that you cannot subscript an array having the @code{register}
storage class.

@node Function Calls as Expressions
@section Function Calls as Expressions
@cindex function calls, as expressions

A call to any function which returns a value is an expression.

@example
@group
int function(void);
@dots{}
a = 10 + function();
@end group
@end example


@node The Comma Operator
@section The Comma Operator
@cindex comma operator

You use the comma operator @code{,} to separate two (ostensibly related) expressions.
For instance, the first expression might produce a value that is used by the second
expression:
@c This works because there is a sequence point after the evaluation
@c of the left hand side.
@example
@group
x++, y = x * x;
@end group
@end example

More commonly, the comma operator is used in @code{for} statements, like
this:

@example
@group
/* @r{Using the comma operator in a @code{for} statement.} */

for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
  @{
    @dots{}
  @}
@end group
@end example

@noindent
This lets you conveniently set, monitor, and modify multiple control
expressions for the @code{for} statement.

A comma is also used to separate function parameters; however, this
is @emph{not} the comma operator in action.   In fact, if the comma
operator is used as we have discussed here in a function call, then
the compiler will
interpret that as calling the function with an extra parameter.

If you want to use the comma operator in a function argument, you need
to put parentheses around it.  That's because commas in a function
argument list have a different meaning: they separate arguments.
Thus,

@example
foo (x,  y=47,  x,  z);
@end example

@noindent
is interpreted as a function call with four arguments, but

@example
foo (x,  (y=47,  x),  z);
@end example

@noindent
is a function call with just three arguments.  (The second argument is
@code{(y=47, x)}.)

@node Member Access Expressions
@section Member Access Expressions
@cindex member access expressions

You can use the member access operator @code{.} to access the members
of a structure or union variable.  You put the name of the structure
variable on the left side of the operator, and the name of the
member on the right side.

@example
@group
struct point
@{
  int x, y;
@};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
@end group
@end example

@cindex indirect member access operator
You can also access the members of a structure or union variable via
a pointer by using the indirect member access operator @code{->}.
@code{x->y} is equivalent to @code{(*x).y}.

@example
@group
struct fish
  @{
    int length, weight;
  @};

struct fish salmon;

struct fish *fish_pointer = &salmon;

fish_pointer->length = 3;
fish_pointer->weight = 9;
@end group
@end example 

@xref{Pointers}.


@node Conditional Expressions
@section Conditional Expressions
@cindex conditional expressions
@cindex expressions, conditional
@cindex ternary operator

You use the conditional operator to cause the entire conditional
expression to evaluate to either its second or its third operand, based
on the truth value of its first operand.  Here's an example:

@example
a ? b : c
@end example

If expression @code{a} is true, then expression @code{b} is evaluated
and the result is the value of @code{b}.  Otherwise, expression
@code{c} is evaluated and the result is @code{c}.  

Expressions @code{b} and @code{c} must be compatible.   That is, they
must both be 

@enumerate
@item arithmetic types
@item compatible @code{struct} or @code{union} types
@item pointers to compatible types (one of which might be the NULL pointer)
@end enumerate 

Alternatively, one operand is a pointer and the other is a
@code{void*} pointer.

Here is an example

@example
a = (x == 5) ? y : z;
@end example

Here, if @code{x} equals 5, then @code{a} will receive
the value of @code{y}.  Otherwise, @code{a} will receive the value of
@code{z}.  This can be considered a shorthand method for writing a simple
@code{if}@dots{}@code{else} statement.  The following example will
accomplish the same task as the previous one:

@example
@group
if (x == 5)
    a = y;
else
    a = z;
@end group
@end example

If the first operand of the conditional operator is true, then the third
operand is never evaluated.  Similarly, if the first operand is false,
then the second operand is never evaluated.  The first operand is always
evaluated.


@c GNU C Extension

@node Statements and Declarations in Expressions
@section Statements and Declarations in Expressions
@cindex statements inside expressions
@cindex declarations inside expressions
@cindex expressions containing statements
@cindex macros, statements in expressions

As a GNU C extension, you can build an expression using compound
statement enclosed in parentheses.  This allows you to included
loops, switches, and local variables within an expression.

Recall that a compound statement (also known as a block) is a sequence of
statements surrounded by braces.  In this construct, parentheses go around
the braces.  Here is an example:

@example
@group
(@{ int y = function (); int z;
    if (y > 0) z = y;
   else z = - y;
   z; @})
@end group
@end example

That is a valid (though slightly more complex than necessary) expression
for the absolute value of @code{function ()}.

The last thing in the compound statement should be an expression
followed by a semicolon; the value of this subexpression serves as the
value of the entire construct.  (If you use some other kind of statement
last within the braces, the construct has type @code{void}, and thus
effectively no value.)

This feature is especially useful in making macro definitions ``safe'' (so
that they evaluate each operand exactly once).  For example, the
``maximum'' function is commonly defined as a macro in standard C as
follows:

@example
#define max(a,b) ((a) > (b) ? (a) : (b))
@end example

@noindent
@cindex side effects, macro argument
But this definition computes either @code{a} or @code{b} twice, with bad
results if the operand has side effects.  In GNU C, if you know the
type of the operands (here let's assume @code{int}), you can define
the macro safely as follows:

@example
#define maxint(a,b) \
  (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @})
@end example

If you don't know the type of the operand, you can still do this, but you
must use @code{typeof} expressions or type naming.

@comment Add reference to typeof

Embedded statements are not allowed in constant expressions, such as
the value of an enumeration constant, the width of a bit field, or
the initial value of a static variable.


@node Operator Precedence
@section Operator Precedence
@cindex operator precedence
@cindex precedence, operator

When an expression contains multiple operators, such as @code{a + b *
f()}, the operators are grouped based on rules of @dfn{precedence}.
For instance, the meaning of that expression is to call the function
@code{f} with no arguments, multiply the result by @code{b}, then add
that result to @code{a}.  That's what the C rules of operator
precedence determine for this expression.

The following is a list of types of expressions, presented in order of
highest precedence first.  Sometimes two or more operators have equal
precedence; all those operators are applied from left to right
unless stated otherwise.

@enumerate

@item
Function calls, array subscripting, and membership access operator
expressions.

@item
Unary operators, including logical negation, bitwise complement,
increment, decrement, unary positive, unary negative, indirection
operator, address operator, type casting, and @code{sizeof}
expressions.  When several unary operators are consecutive,
the later ones are nested within the earlier ones: @code{!-x}
means @code{!(-x)}.

@item
Multiplication, division, and modular division expressions.

@item
Addition and subtraction expressions.

@item
Bitwise shifting expressions.

@item
Greater-than, less-than, greater-than-or-equal-to, and less-than-or-equal-to@*
expressions.

@item
Equal-to and not-equal-to expressions.

@item
Bitwise AND expressions.

@item
Bitwise exclusive OR expressions.

@item
Bitwise inclusive OR expressions.

@item
Logical AND expressions.

@item
Logical OR expressions.

@item
Conditional expressions (using @code{?:}).  When used as
subexpressions, these are evaluated right to left.

@item
All assignment expressions, including compound assignment.  When multiple
assignment statements appear as subexpressions in a single larger expression,
they are evaluated right to left.

@item
Comma operator expressions.

@end enumerate

@c ??? Lots more examples are needed here!

@c ??? You need to explain when parentheses are strongly
@c recommended in order to make the structure clear.

The above list is somewhat dry and is apparently straightforward, but
it does hide some pitfalls.  Take this example:

@example
foo = *p++;
@end example

Here @code{p} is incremented as a side effect of the expression, but
@code{foo} takes the value of @code{*(p++)} rather than @code{(*p)++},
since the unary operators bind right to left.   There are other
examples of potential surprises lurking behind the C precedence
table.  For this reason if there is the slightest risk of the reader
misunderstanding the meaning of the program, you should use
parentheses to make your meaning clear.

@node Order of Evaluation
@section Order of Evaluation

In C you cannot assume that multiple subexpressions are evaluated in
the order that seems natural.  For instance, consider the expression
@code{++a * f()}.  Does this increment @code{a} before or after
calling the function @code{f}?  The compiler could do it in either
order, so you cannot make assumptions.

This manual explains the semantics of the C language in the abstract.
However, an actual compiler translates source code into specific
actions in an actual computer, and may re-order operations for the
sake of efficiency.  The correspondence between the program you write
and the things the computer actually does are specified in terms of
@emph{side effects} and @emph{sequence points}.

@menu
* Side Effects::
* Sequence Points::
* Sequence Points Constrain Expressions::
* Sequence Points and Signal Delivery::
@end menu

@node Side Effects
@subsection Side Effects

@cindex side effect
A @dfn{side effect} is one of the following:
@enumerate
@item accessing a @code{volatile} object
@item modifying an object
@item modifying a file
@item a call to a function which performs any of the above side effects
@end enumerate

These are essentially the externally-visible effects of running a
program.   They are called side effects because they are effects of
expression evalation beyond the expression's actual resulting value.

The compiler is allowed to perform the operations of your program in
an order different to the order implied by the source of your program, 
provided that in the end all the necessary side effects actually take
place. The compiler is also allowed to entirely omit some operations;
for example it's allowed to skip evaluating part of an expression if
it can be certain that the value is not used and evaluating that part
of the expression won't produce any needed side effects.

@node Sequence Points
@subsection Sequence Points

Another requirement on the compiler is that side effects should take
place in the correct order.  In order to provide this without
over-constraining the compiler, the C89 and C90 standards specify a
list of sequence points.  A @dfn{sequence point} is one of the
following:

@cindex sequence point
@enumerate
@c authority: C99 standard, annex C
@item a call to a function (after argument evaluation is complete)
@item the end of the left-hand operand of the and operator @code{&&}
@item the end of the left-hand operand of the or operator @code{||}
@item the end of the left-hand operand of the comma operator @code{,}
@item the end of the first operand of the ternary operator @code{a ? b : c}
@item the end of a full declarator
@footnote{a full declarator is a declaration of a function or an object which is not part of another object}
@item the end of an initialisation expression 
@item the end of an expression statement (i.e. an expression followed by @code{;})
@item the end of the controlling expression of an @code{if} or @code{switch} statement
@item the end of the controlling expression of a @code{while} or @code{do} statement
@item the end of any of the three controlling expressions of a @code{for} statement
@item the end of the expression in a return statement
@item immediately before the return of a library function
@item after the actions associated with an item of formatted I/O (as
used for example with the @code{strftime} or the @code{printf} and
@code{scanf} famlies of functions).
@item immediately before and after a call to a comparison function (as
called for example by @code{qsort})
@end enumerate

@c authority: C99 standard, section 5.1.2.3
At a sequence point, all the side effects of previous expression
evaluations must be complete, and no side effects of later evaluations
may have taken place.

@c authority: C89 standard, section 5.1.2.3
@c this description was not included in C99, I assume because of the 
@c introduction of whole-program optimisation
This may seem a little hard to grasp, but there is another way to
consider this.  Imagine you wrote a library (some of whose functions
are external and perhaps others not) and compiled it, allowing someone
else to call one of your functions from their code.  The definitions
above ensure that, at the time they call your function, the data they
pass in has values which are consistent with the behaviour specified
by the abstract machine, and any data returned by your function has a
state which is also consistent with the abstract machine.  This
includes data accessible via pointers (i.e. not just function
parameters and identifiers with external linkage).

The above is a slight simplification, since compilers exist that
perform whole-program optimisation at link time.  Importantly however,
although they might perform optimisations, the visible side effects of
the program must be the same as if they were produced by the abstract
machine.

@node Sequence Points Constrain Expressions
@subsection Sequence Points Constrain Expressions

@c authority: C89 section 6.3, C99 section 6.5
The code fragment 
@example
i = i + 1;
@end example 
is quite normal and no doubt occurs in many programs.  However, the
quite similar code fragment
@example
i = ++i + 1;
@end example 
is a little harder to understand; what is the final value of @code{i}?
The C standards (both C89 and C99) both forbid this construct in 
conforming programs.  

Between two sequence points, 
@enumerate
@item an object may have its stored value modified at most once by the
evaluation of an expression
@item the prior value of the object shall be read only to determine
the value to be stored.
@end enumerate

The first of these two conditions forbids expressions like 
@code{foo(x=2, ++x)}.  The second condition forbids expressions like
@code{a[i++] = i}.

@c with an appropriate list of counterexamples such as f(x++, x++).

@table @code
@item int x=0; foo(++x, ++x)
Not allowed in a conforming program; modifies @code{x} twice before
argument evaluation is complete. 
@item int x=0; bar((++x,++x))
Allowed; the function @code{bar} takes one argument (the value 2
is passed here), and there is a sequence point at the comma operator.
@item *p++ || *p++
Allowed; there is a sequence point at @code{||}.
@item int x = 1, y = x++;
Allowed; there is a sequence point after the full declarator of @code{x}.
@item x=2; x++;
Allowed; there is a sequence point at the end of the first expression
statement.
@item if (x++ > MAX) x = 0;
Allowed; there is a sequence point at the end of the controlling
expression of the @code{if}@footnote{However if for example @code{MAX} is
@code{INT_MAX} and @code{x} is of type @code{int}, we clearly have a
problem with overflow.  @xref{Overflow}.}.
@item (x=y) ? ++x : x--;
Allowed; there is a sequence point before the @code{?}, and only one
of the two following expressions is evaluated.
@item int *p=malloc(sizeof(*p)), *q=p;  *p=foo(); bar((*p)++,(*q)++);
Not allowed; the object at @code{p} is being modified twice
before the evaluation of the arguments to @code{bar} is complete.  The
fact that this is done once via @code{p} and once via @code{q} is
irrelevant, since they both point to the same object.
@end table

Let's go back to the example we used to introduce the problem of the
order of evaluation, @code{++a * f()}.   Suppose the code actually
looks like this:

@example
@group
static int a = 1;

static int f (void)
@{
  a = 100;
  return 3;
@}

int foo (void)
@{
   return ++a * f();
@}
@end group
@end example

Is this code allowed in a standard-conforming program?  Although the
expression in @code{foo} modifies @code{a} twice, this is not a
problem.  Let's look at the two possible cases.

@table @asis
@item The right operand @code{f()} is evaluated first
Since @code{f} returns a value other than void, it must contain a
@code{return} statement.   Therefore, there is a sequence point at the
end of the return expression.  That comes between the modification to
@code{a} that @code{f} makes and the evaluation of the left operand.
@item The left operand @code{++a} is evaluated first
First, @code{a} is incremented.   Then the arguments to @code{f} are
evaluated (there are zero of them).  Then there is a sequence point
before @code{f} is actually called.
@end table

@c C99 does not state explicitly that there is a sequence point after
@c argument evaluation if a function call contains zero arguments.
So, we see that our program is standard-conforming.  Notice that the
above argument does not actually depend on the details of the body of
the function @code{f}.  It only depends on the function containing
something ending in a sequence point -- in our example this is a
return statement, but an expression statement or a full declarator
would do just as well.

@cindex unspecified behaviour
However, the result of executing this code depends on the order of
evaluation of the operands of @code{*}.  If the left-hand operand is
evaluated first, @code{foo} returns 6.  Otherwise, it returns 303.
The C standard does not specify in which order the operands should be
evaluated, and also does not require an implementation either to
document the order or even to stick to one order.  The effect of this
code is @dfn{unspecified}, meaning that one of several specific
things will happen, but the C standards do not say which.



@node Sequence Points and Signal Delivery
@subsection Sequence Points and Signal Delivery

Signals are mainly documented in the GNU C Library manual rather than
this document, even though the C standards consider the compiler and
the C library together to be ``the implementation''.

@c [This scene-setting is probably too long. - jay@gnu.org]
@c
@c Your C program can be notified of asynchronous events by the
@c @dfn{signal} mechanism.  There are a few dozen different possible
@c signals; these include for example @code{SIGINT}, which tells your
@c program that the user pressed the keyboard interrupt key, and
@c @code{SIGFPE} which tells your program that an arithmetic overflow has
@c occurred.  Signals can be asyncronous, for example @code{SIGINT}
@c generally arises outside your program, or normally synchronous like
@c @code{SIGFPE} or @code{SIGABRT} (which indicates your program called
@c the @code{abort} function, directly or indirectly).  Signals can also
@c be sent using the @code{kill} and @code{raise} functions.
@c 
@c All signals have a default effect, usually to terminate the program.
@c However, you can set up a @dfn{signal handler} -- a funciton to be
@c called when a specified signal is delivered.


When a signal is received, this will happen between sequence points.
Side effects on @code{volatile} objects prior to the previous sequence
point will have occurred, but other updates may not have occurred
yet.  This even applies to straight assignments, such as @code{x=0;},
because the code generated for that statement may require more than
one instruction, meaning that it can be interrupted part-way through
by the delivery of a signal.

The C standard is quite restrictive about what data access can occur
within a signal handler.  They can of course use @code{auto}
variables, but in terms of reading or writing other objects, they must
be @code{volatile sig_atomic_t}.  The @code{volatile} type qualifier
ensures that access to the variable in the other parts of the program
doesn't span sequence points and the use of the @code{sig_atomic_t}
type ensures that changes to the variable are atomic with respect to
signal delivery.

The POSIX standard also allows a small number of library functions to
be called from a signal handler.  These functions are referred to as
the set of @dfn{async-signal-safe} functions.  If your program is
intended to run on a POSIX system but not on other systems, you can
safely call these from your signal handler too.

