@c ??? Это может быть хорошей идеей, чтобы превратить каждый пример выражения
@c в небольшую программу, которая печатает выходные и, таким образом,
@c показывает, что выражение делает.

@c Это является частью GNU C Reference Manual
@c Copyright (C) 2007-2016 Free Software Foundation, Inc.
@c Смотрите файл gnu-c-manual.texi условия копирования.

@node Expressions and Operators
@chapter Выражения и Операторы

@menu
* Expressions::
* Assignment Operators::
* Incrementing and Decrementing::
* Arithmetic Operators::
* Complex Conjugation::
* Comparison Operators::
* Logical Operators::
* Bit Shifting::
* Bitwise Logical Operators::
* Pointer Operators::
* The sizeof Operator::
* Type Casts::
* Array Subscripts::
* Function Calls as Expressions::
* The Comma Operator::
* Member Access Expressions::
* Conditional Expressions::
* Statements and Declarations in Expressions::
* Operator Precedence::
* Order of Evaluation::
@end menu

@node Expressions
@section Выражения
@cindex expressions

@dfn{Выражение} состоит, по меньшей мере, из одного операнда и содержит ноль
или более операторов.  Операнды - это типизированные объекты, такие как
константы, переменные и вызовы функций, которые возвращают значение.  Вот
некоторые примеры:

@example
@group
47
2 + 2
cosine(3.14159) /* @r{Мы предполагаем, это возвращает значение с плавающей
точкой.} */
@end group
@end example

Круглые скобки для группировки подвыражений:

@example
( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )
@end example

@noindent
Вложенные выражения вычисляются первыми.  В приведенном выше примере,
вначале оцениваются выражения @code{3 + 10} и @code{2 * 6}, затем оцениваются
полученные выражения @code{13} и @code{12}, соответственно.  Затем @code{12}
вычитается из @code{13}, в результате чего получается @code{1}.  Наконец,
@code{1} умножается на @code{2}, в результате чего появляется @code{2}.
Самые внешние круглые скобки в примере не являются обязательными.

@cindex operators

@dfn{Оператор} определяет операцию, которая будет выполняться над его
операндом(ами).  Операторы могут иметь один, два или три операнда, в
зависимости от оператора.

@node Assignment Operators
@section Операторы Присваивания
@cindex assignment operators
@cindex operators, assignment

Операторы присваивания сохраняют значения в переменных.  Си обеспечивает
несколько вариантов операторов присваивания.

Стандартный оператор присваивания @code{=} просто сохранит значение правого
операнда в переменную, указанную в левом операнде.  Как и со всеми
операторами присваивания, левый операнд (обычно называемый как
``lvalue (левое значение)'') не может быть буквальным или постоянным
значением.

@example
@group
int x = 10;
float y = 45.12 + 2.0;
int z = (2 * (3 + function () ));

struct foo @{
  int bar;
  int baz;
@} quux = @{3, 4@};
@end group
@end example

@noindent
Обратите внимание, что, в отличие от других операторов присваивания,
описанных ниже, можно использовать простой оператор присваивания для
хранения значений структурного типа.

Составные операторы присваивания выполняют операцию с участием как левого,
так и правый операнда, затем присваивают полученное выражение левому
операнду.  Вот список составных операторов присваивания и краткое описание
того, что они делают:

@itemize

@item
@code{+=}

Складывает два операнда вместе, затем присваивает результат сложения левому
операнду.

@item
@code{-=}

Вычитает правый операнд из левого операнда, затем присваивает результат
вычитания левому операнду.

@item
@code{*=}

Перемножает два операнда, затем присваивает результат умножения левому
операнду.

@item
@code{/=}

Делит левый операнд на правый операнд, присваивает результат деления левому
операнду.

@item
@code{%=}

Выполняет деление по модулю деление двух операндов, присваивает результат
деления левому операнду.

@item
@code{<<=}

Выполненяет операцию сдвига влево с левым операндом, сдвигая на число битов,
заданное с помощью правого операнда, присваивает результат сдвига левому
операнду.

@item
@code{>>=}

Выполняет операцию сдвига вправо с левым операндом, сдвигая на число битов,
заданное с помощью правого операнда, и присваивает результат сдвига левому
операнду.

@item
@code{&=}

Выполняет поразрядную операцию @code{И} для двух операндов, и присваивает
результат операции левому операнду.

@item
@code{^=}

Выполняет поразрядную операцию @code{исключающего ИЛИ} для двух операндов,
и присваивает результат операции левому операнду.

@item
@code{|=}

Выполняет поразрядную операцию @code{ИЛИ} для двух операндов,
и присваивает результат операции левому операнду.

@end itemize
@comment  __End из соединения назначений списка операторов

Ниже приведен пример использования одного из составных операторов
присваивания:

@example
x += y;
@end example

@noindent
Поскольку нет никаких влияющих побочных эффектов при оценки переменной
@code{x} как lvalue (левого значения), приведенный выше код дает тот же
результат, что и код:

@example
x = x + y;
@end example


@c GNU C Extension -- temporarily commented out for manual 0.1
@c @node Generalized Lvalues
@c @subsubsection Generalized Lvalues
@c @cindex compound expressions as lvalues
@c @cindex expressions, compound, as lvalues
@c @cindex conditional expressions as lvalues
@c index expressions, conditional, as lvalues
@c @cindex casts as lvalues
@c @cindex generalized lvalues
@c @cindex lvalues, generalized
@c @cindex extensions, @code{?:}
@c @cindex @code{?:} extensions
@c 
@c Составные выражения, условные выражения и сдвиги разрешены, как lvalues
@c (левые значения) при ​​условии, что их операнды  также lvalues.  Это
@c означает, что можно взять их адрес или хранимое значение в них.
@c 
@c Например, можно присвоить значение выражения соединения, при условии, что @c последнее выражение в последовательности является именованным.  Эти два
@c выражения эквивалентны:
@c 
@c @example
@c (a, b) += 5
@c a, (b += 5)
@c @end example
@c 
@c Кроме того, можно взять адрес выражения соединения.  Таким образом, эти
@c два выражения эквивалентны:
@c 
@c @example
@c &(a, b)
@c a, &b
@c @end example
@c 
@c Условное выражение является допустимым, если их именованный тип не
@c является недействительным, и если оба и второй и третий операнды являются
@c действительными lvalues (левыми выражениями).  Например, эти два выражения
@c эквивалентны:
@c 
@c @example
@c (a ? b : c) = 5
@c (a ? b = 5 : (c = 5))
@c @end example
@c 
@c Составной тип является допустимым, если его именованный операнд является
@c именным.  Простое назначение которого сторона left-hand представляет
@c собой отливка работает путем преобразования в стороне right-hand первой
@c указанного типа, а затем к типу внутренней стороны выражения left-hand.
@c После этого сохраняется, значение преобразуется обратно к указанному типу,
@c чтобы стать значением задания.  Таким образом, если @code{a} имеет тип
@c @code{char *}, следующие два выражения эквивалентны:
@c (ВопросExpressions 244)
@c 
@c @example
@c (int)a = 5
@c (int)(a = (char *)(int)5)
@c @end example
@c 
@c Назначение-с-арифметической операции, такие как @code{+=}, приложенного к
@c литым выполняет арифметические операции, используя тип полученного из
@c литой, а затем продолжается, как и в предыдущем случае. Таким образом,
@c эти два выражения эквивалентны:
@c 
@c @example
@c (int)a += 5
@c (int)(a = (char *)(int) ((int)a + 5))
@c @end example

@c Вы не можете взять адрес именующее гипсе, потому что использование его
@c адреса не будет работать слаженно.  Предположим, что @code{&(int)f} были
@c разрешены, где @code{f} имеет тип @code{float}. Тогда следующий оператор
@c попытается сохранить целое битового шаблона, где число с плавающей точкой
@c принадлежит:
@c 
@c @example
@c *&(int)f = 1;
@c @end example
@c 
@c Это совершенно отличается от того, что @code{(int)f = 1} будет делать ---
@c что бы преобразовать 1 с плавающей точкой и хранить его.  Вместо того,
@c чтобы причина этого несоответствия, мы считаем, что лучше запретить
@c использование @code{&} на гипсе.
@c 
@c Если вы действительно хотите указатель @code{int *} с адресом @code{f},
@c вы можете просто написать @code{(int *)&f}.

@node Incrementing and Decrementing
@section Увеличение и Уменьшение
@cindex increment operator
@cindex decrement operator
@cindex operator, increment
@cindex operator, decrement

Оператор инкремента @code{++} добавляет 1 (еденицу) к своему операнду.
Операнд должен быть либо переменной одного из примитивных типов данных,
указателем или переменной перечисления.  Можжно применить оператор
инкремента либо до, либо после операнда. вот несколько примеров:

@example
@group
char w = '1';
int x = 5;
char y = 'B';
float z = 5.2;
int *p = &x;

++w;   /* @r{@code{w} теперь символ `2' (не число 2).} */
x++;   /* @r{@code{x} теперь 6.} */
++y;   /* @r{@code{y} теперь `C' (в системах ASCII).} */
z++;   /* @r{@code{z} теперь 6.2.} */
++p;   /* @r{@code{p} теперь @code{&x} + @code{sizeof(int)}.} */
@end group
@end example

@noindent
(Обратите внимание, что увеличивающийся указатель имеет смысл только если
есть основания полагать, что новое значение указателя будет допустимым
адресом памяти.)

Префиксное приращение, добавляет 1 к операнду перед вычислением операнда.
Постфиксное приращение добавляет 1 после того, как операнд вычислен.  В
предыдущих примерах, изменение положения оператора не будет иметь никакого
значения.  Однако, бывают случаи, когда это имеет значение:

@example
@group
int x = 5;
printf ("%d \n", x++); /* @r{Распечатает @code{x}, а затем увеличит его.} */
/* @r{Вывод 5, хотя переменная @code{x} теперь равна 6.} */
printf ("%d \n", ++x); /* @r{Приращение к @code{x}, а затем печать его.} */
/* @r{Вывод и переменная @code{x} теперь равна 7.} */
@end group
@end example

@noindent
Вывод приведенного выше примера:

@example
@group
5
7
@end group
@end example

Кроме того, можно вычесть 1 из операнда с помощью оператора декремента:

@example
@group
int x = 5;

x--; /* @r{@code{x} теперь 4.} */
@end group
@end example

@noindent
Понятия префикс и постфикс, применяются также и с оператором инкремента.

@node Arithmetic Operators
@section Арифметические Операторы
@cindex arithmetic operators
@cindex operators, arithmetic

Си обеспечивает операторы для стандартных арифметических операций: сложения,
вычитания, умножения деления, деление по модулю и отрицание.  Использование
этих операторов просто; вот несколько примеров:

@example
@group
/* @r{Сложение.} */
x = 5 + 3;
y = 10.23 + 37.332;
quux_pointer = foo_pointer + bar_pointer;
@end group
@end example

@example
@group
/* @r{Вычитание.} */
x = 5 - 3;
y = 57.223 - 10.903;
quux_pointer = foo_pointer - bar_pointer;
@end group
@end example

@noindent
Можно складывать и вычитать указатели памяти, но нельзя перемножать и делить
их.

@example
@group
/* @r{Умножение.} */
x = 5 * 3;
y = 47.4 * 1.001;
@end group
@end example

@example
@group
/* @r{Деление.} */
x = 5 / 3;
y = 940.0 / 20.2;
@end group
@end example

@noindent
Целочисленное деление положительных значений обрезает по направлению к нулю,
так что 5/3 равен 1.  Однако, если один из операндов является отрицательным,
то направление округления зависит от реализации.
@ref{Signed Integer Division} для информации о переполнении в знаковом
целочисленном делении.

@c Нужно указать GCC, как ему вести себя, если операнд отрицателен.


Оператор деление по модулю @code{%} используется, чтобы получить остаток от
деления его двух операндов.  Операнды устанавливаются по обе стороны от
оператора, и имеет значение, какой операнд на какой стороне: @code{3 % 5} или
@code{5 % 3} имеют разный результат.  Операнды должны быть выражениями
примитивного типа данных.

@example
@group
/* @r{Деление по модулю.} */
x = 5 % 3;
y = 74 % 47;
@end group
@end example

@noindent
Деление по модулю возвращает остаток, полученный после выполнения деления
целых чисел двух операндов.  Операнды должны быть примитивного целого типа.

@example
@group
/* @r{Отрицание.} */
int x = -5;
float y = -3.14159;
@end group
@end example

Если операнд используемый с оператором отрицания имеет беззнаковый тип
данных, то результат не станет отрицательным, а будет иметь максимальное
значение беззнакового типа данных, за вычетом значения операнда.

Многие системы используют в коде арифметику с дополнением до двух, и на таких
системах самое отрицательное значение, знакового типа, может находится дальше
от нуля, чем самое положительное значение.  Например, на одной платформе, эта
программа:

@example
@group
#include <limits.h>
#include <stdio.h>

int main (int argc, char *argv[]) 
@{
  int x;
  x = INT_MAX;
  printf("INT_MAX  = %d\n", x);
  x = INT_MIN;
  printf("INT_MIN  = %d\n", x);
  x = -x;
  printf("-INT_MIN = %d\n", x);
  return 0;
@}
@end group
@end example

Производит этот вывод:

@example
@group
INT_MAX  = 2147483647
INT_MIN  = -2147483648
-INT_MIN = -2147483648
@end group
@end example

Можно также применить положительный оператор для числового выражения:

@example
int x = +42;
@end example

@noindent
Числовые значения считаются положительными, если явно не сделать его
отрицательным, поэтому этот оператор не оказывает никакого влияния на работу
программы.

@node Complex Conjugation
@section Комплексное Сопряжение
@cindex complex conjugation
@cindex conjugation
 
В качестве расширения GNU, можно использовать оператор комплексного
сопряжения @code{~}, выполняет комплексное сопряжение на операнде --- то
есть, он меняет знак мнимой составляющей.  Операнд должен быть выражением
типа комплесного числа.  Вот пример:
 
@example
@group
__complex__ int x = 5 + 17i;
 
printf ("%d  \n", (x * ~x));
@end group
@end example
 
Так как мнимое число @math{(a + bi)} умноженное на его сопряжённое число
равное @math{a^2 + b^2}, приведенное выше выражение @code{printf} выведет на
печатать число 314, которое получилось из выражения @math{25 + 289}.

@node Comparison Operators
@section Операторы Сравнения
@cindex comparison operators
@cindex operators, comparison

Можно использовать операторы сравнения для определения того, как два операнда
соотносятся друг с другом: они равны друг другу, один больше, чем другой,
один меньше другого, и так далее.  При использовании любого из операторов
сравнения, результат всегда равен 1 или 0, то есть является истинной или
ложью, соответственно.

(В следующих примерах кода, переменные @code{x} and @code{y} содержат любые
два выражения арифметического типа или указателя.)

Оператор равенства @code{==} тестирует свои два операнда на равенство.
Результат равен 1, если операнды равны, и 0, если операнды не равны.

@example
@group
if (x == y)
  puts ("x равен y");
else
  puts ("x не равен y");
@end group
@end example

Оператор неравенства @code{!=} тестирует свои два операнда на неравенство.
Результат равен 1, если операнды не равны, и 0, если операнды @emph{являются}
равными.

@example
@group
if (x != y)
  puts ("x не равен y");
else
  puts ("x равен y");
@end group
@end example

Сравнение значений с плавающей точкой для точного равенства или неравенства
может привести к неожиданным результатам.  @ref{Real Number Types} для
получения дополнительной информации.

Можно сравнивать указатели на функции для равенства или неравенства;
сравнение проверяет, указывают ли указатели на одну и ту же функцию или нет.

Помимо равенства и неравенства, есть операторы, которые можно использовать
для тестирования того, меньше, больше, меньше или равной, больше или равно
одно значение другого значения.  Вот некоторые примеры кода, которые
иллюстрируют использование этих операторов:

@example
@group
if (x < y)
  puts ("x меньше y");
@end group
@end example

@example
@group
if (x <= y)
  puts ("x меньше или равно y");
@end group
@end example

@example
@group
if (x > y)
  puts ("x больше y");
@end group
@end example

@example
@group
if (x >= y)
  puts ("x больше или равно y");
@end group
@end example


@node Logical Operators
@section Логические Операторы
@cindex logical operators

Логические операторы проверяют значение истинности пары операндов.  Любое
выражение отлично от нуля считается истинным в Си, в то время как выражение,
значение которого является ноль считается ложным.

Логический оператор @code{И} - @code{&&} проверяет, если два выражения
истинны.  Если первое выражение ложно, то второе выражение не вычисляется.

@example
@group
if ((x == 5) && (y == 10))
  printf ("x равно 5 и y равно 10");
@end group
@end example

Логический оператор @code{или} - @code{||} проверяет, если хотя бы одно из
двух выражений истинным.  Если первое выражение истинно, то второе выражение
не вычисляется.

@example
@group
if ((x == 5) || (y == 10))
   printf ("x равно 5 или y равно 10");
@end group
@end example

Можете предварять логическое выражение оператором отрицания @code{не} -
@code{!}, который переворачивает значение истинности:

@example
@group
if (!(x == 5))
  printf ("x не равно 5");
@end group
@end example

Так как второй операнд в паре логического выражения не обязательно
вычисляется, возможно написать код с неинтуитивными результатами:

@example
@group
if (foo && x++)
  bar();
@end group
@end example

@noindent
В случае когда оценка @code{foo} не будет равна нулю, то не только произойдёт
вызов @code{bar}, но и значение @code{x} будет увеличино.  Если требуется
увеличивать @code{x} независимо от значения @code{foo}, нужно сделать
приращение за пределами выражения @code{И}.


@node Bit Shifting
@section Битовый Сдвиг
@cindex bit shifting
@cindex shifting

Использование оператора @code{<<} сдвиг влево, сдвинет биты своего первого
операнда влево.  Второй операнд обозначает количество битовых мест для
сдвига.  Биты, сдвинутые на левой стороне значения отбрасываются; новые биты,
добавленные на правой стороне все будет установлены в 0.

@example
@group
x = 47;    /* @r{47 это 00101111 в двоичном представлении.} */
x << 1;    /* @r{00101111 << 1 после сдвига равно 01011110.} */
@end group
@end example

Точно так же оператор @code{>>} сдвига вправо, сдвинет биты своего первого
операнда вправо.  Биты смещённые с правой стороны отбрасываются; новые биты,
добавленные на левой стороне @emph{обычно} устанавливаются в 0, но если
первый операнд является знаковым отрицательным значением, то добавленные биты
будут либо 0 @emph{либо} любым другим значением, которое ранее было в
самой крайней левой позиции бита.

@example
@group
x = 47;   /* @r{47 это 00101111 в двоичном представлении.} */
x >> 1;   /* @r{00101111 >> 1 после сдвига вправо теперь 00010111.} */
@end group
@end example

Для обоих операторов @code{<<} и @code{>>}, если второй операнд больше
битовой ширины первого операнда или второй операнд является отрицательным,
поведение операторов не определено.

Можно использовать операторы сдвига для выполнения множества интересных
трюков.  Например, для работы с датой - учитывая дату с днём ​​месяца
пронумерованной в @code{d}, месяца пронцмерованного @code{m}, и года
пронумерованного @code{y}, можно хранить всю дату в одном числе @code{x}:

@example
int d = 12;
int m = 6;
int y = 1983;
int x = (((y << 4) + m) << 5) + d;
@end example

@noindent
Можно теперь извлечь исходный день, месяц и год из @code{x}, используя
комбинацию операторов сдвига и модульного деления:

@example
d = x % 32;
m = (x >> 5) % 16;
y = x >> 9;
@end example

@node Bitwise Logical Operators
@section Побитовые Логические Операторы
@cindex bitwise logical operators
@cindex logical operators, bitwise

Cи предоставляет операторы для выполнения побитового соединения @code{И},
@code{ИЛИ}, @code{исключающего ИЛИ} и @code{НЕ} (дополнения).

Побитовое соединение @code{И} анализирует каждый бит двух операндов, и
когда два соответствующих бита установлены в 1, результирующий бит
устанавливается в 1.  Во всех остальных случаях, результирующий бит
устанавливается в 0.  Ниже приведен пример того, как это работает, используя
двоичные числа:

@example
11001001 & 10011011 = 10001001
@end example

Побитовое соединение @code{ИЛИ} анализирует каждый бит в двух операндах, и
когда два соответствующих биты установлены в 0, то результирующий бит
устанавливается в 0.  Во всех остальных случаях, результирующий бит
устанавливается в 1.

@example
11001001 | 10011011 = 11011011
@end example

Побитовое соединение @code{исключающее ИЛИ} анализирует каждый бит в двух
операндах, и когда два соответствующих бита отличны по установленному
значению, то результирующий бит устанавливается в 1.  Во всех остальных
случаях, результирующий бит устанавливается в 0.

@example
11001001 ^ 10011011 = 01010010
@end example

Побитовое соединение @code{НЕ} меняет значение каждого бита в операнде на
противоположное:

@example
~11001001 = 00110110
@end example

В Cи, эти операторы можно использовать только с операндами целочисленного
типа (или символьного), а также для обеспечения максимальной переносимости
следует использовать только оператор побитового отрицания с беззнаковыми
целочисленными типами.  Вот некоторые примеры использования этих операторов
в коде Cи:

@example
@group
unsigned int foo = 42;
unsigned int bar = 57;
unsigned int quux;

quux = foo & bar;
quux = foo | bar;
quux = foo ^ bar;
quux = ~foo;
@end group
@end example

@node Pointer Operators
@section Операторы Указателей
@cindex pointer operators

Можно использовать оператор взятия адреса @code{&} для получения адреса
памяти объекта.

@example
@group
int x = 5;
int *pointer_to_x = &x;
@end group
@end example

Не следует использовать этот оператор, чтобы получить адрес функции, хотя
можно так:

@example
@group
extern int foo (void);
int (*fp1) (void) = foo; /* fp1 указатель на foo */
int (*fp2) (void) = &foo; /* fp2 также указывает на foo */
@end group
@end example

Указатели на функции и указатели на данные не совместимы, в том смысле, что
не получиться сохранить адрес функции в указателе на данные, а затем
скопировать этот указатель в указатель на функцию и вызвать потом функцию
успешно.  Это может работать на некоторых системах, но это непереносимая
техника.

В качестве расширения GNU для C89, можно также получить адрес метки используя
оператор взятия адреса метки @code{&&}.  Результатом будет указатель
@code{void*}, который может быть использован оператором @code{goto}.
@xref{The goto Statement}.

Учитывая адрес памяти, хранящийся в указателе, можно использовать оператор
косвенного обращения (разыменования) @code{*}, чтобы получить значение,
хранящееся по адресу.  (Это называется @dfn{разыменованием} указателя.)

@example
@group
int x = 5;
int y;
int *ptr;

ptr = &x;    /* @r{@code{ptr} теперь хранит адрес @code{x}.} */

y = *ptr;    /* @r{@code{y} получает значение, хранящееся по адресу}
                @r{которое сохранено в @code{ptr}.} */
@end group
@end example

@noindent
Избегайте использование разыменования указателей, которые не были
инициализированы в известную ячейку памяти.


@node The sizeof Operator
@section Оператор Получения Размера
@cindex sizeof operator

Можно использовать оператор @code{sizeof}, чтобы получить размер (в байтах)
операнда содержащего тип данных.  Операнд может быть указан с фактическим
спецификатором типа (например, @code{int} или @code{float}), а также быть
любым допустимым выражением.  Когда операнд является именем типа, он должен
быть заключен в скобки.  Вот некоторые примеры:

@example
@group
size_t a = sizeof(int);
size_t b = sizeof(float);
size_t c = sizeof(5);
size_t d = sizeof(5.143);
size_t e = sizeof a;
@end group
@end example

Результат оператора @code{sizeof} имеет имя типа @code{size_t}, которое
определено в файле заголовка @code{<stddef.h>}.  @code{size_t} является
беззнаковым целочисленным типом, может быть идентичен @code{unsigned int} или
@code{unsigned long int}, что меняется от системы к системе.

@code{size_t} тип часто бывает удобным типом для индексации цикла, так как
это позволяет иметь возможность удерживать значение количества элементов в
любом массиве, что не получиться при использовании индексации например с
типом @code{int}.

Оператор @code{sizeof} может использоваться для автоматического вычисления
количества элементов в массиве:

@example
@group
#include <stddef.h>
#include <stdio.h>

static const int values[] = @{ 1, 2, 48, 681 @};
#define ARRAYSIZE(x) (sizeof x/sizeof x[0])

int main (int argc, char *argv[]) 
@{
    size_t i;
    for (i = 0; i < ARRAYSIZE(values); i++) 
    @{
        printf("%d\n", values[i]);
    @}
    return 0;
@}
@end group
@end example

Есть два случая, когда этот метод не работает.  Во-первых, когда элемент
массива имеет нулевой размер  (GCC поддерживает структуры нулевого размера
как расширение GNU).  Во-вторых, если массив фактически является параметром
функции (@pxref{Function Parameters}).

@node Type Casts
@section Приведение Типов
@cindex type casts
@cindex casts

Можно использовать приведение типа, чтобы явно указать, что выражение
относится к определенному типу данных.  Такое приведение состоит из
спецификатора типа, заключенного в скобках, за которым следует выражение.
Для обеспечения правильного приведения,  нужно также заключить выражение,
которое следует за спецификатором типа в скобках. Вот пример:

@example
@group
float x;
int y = 7;
int z = 3;
x = (float) (y / z);
@end group
@end example

В этом примере, поскольку @code{y} и @code{z} оба являются целыми числами,
выполняется целочисленное деление, @code{x} это переменная с плавающей
точкой и принимает вычисленное выражение деления - значение 2.  Здесь явное
приведение результата деления к типу @code{float} не делает ничего хорошего,
потому что вычисленное значение @code{y/z} уже усечено до 2.

Чтобы устранить эту проблему, необходимо преобразовать тип одного из
операндов опрации деления в тип с плавающей точкой до выполнения деления:

@example
@group
float x;
int y = 7;
int z = 3;
x = (y / (float)z);
@end group
@end example

@noindent Здесь, значение с плавающей точкой, близкое к 2.333@dots{},
присваивается @code{x}.

Приведение типа работает только со скалярными типами (то есть с
целочисленными типами, типими числа с плавающей точкой и типами указатель).
Таким образом, это допустимо:

@example
@group
struct fooTag @{ /* коллекция ... */ @};
struct fooTag foo;
unsigned char byteArray[8];

foo = (struct fooType) byteArray; /* @r{Ошибка!} */
@end group
@end example

@node Array Subscripts
@section Индексация Массива
@cindex array subscripts

Можно получить доступ к элементам массива, указав имя массива и индекс
массива (или индекс или номер элемента), заключенного в квадратные скобки.
Ниже приведен пример целочисленного массива с именем @code{my_array}:

@example
@group
my_array[0] = 5;
@end group
@end example

Выражение индекс массива @code{A[i]} определяется как идентично выражению
@code{(*((A)+(i)))}.  Это означает, что многие виды использования имени
массива эквивалентно выражению с указателем.  Это также означает, что нельзя
индексировать массив, имеющий класс хранения @code{register}.

@node Function Calls as Expressions
@section Вызовы Функций как Выражения
@cindex function calls, as expressions

Вызов любой функции, которая возвращает значение, является выражением.

@example
@group
int function(void);
@dots{}
a = 10 + function();
@end group
@end example


@node The Comma Operator
@section Оператор Запятая
@cindex comma operator

Можно использовать оператор запятая @code{,} для разделения двух (якобы
связанных) выражений.  Например, первое выражение может задавать значение,
которое используется вторым выражением:
@c Это работает, потому что существует точка последовательности после оценки
@c левой стороны выражения.
@example
@group
x++, y = x * x;
@end group
@end example

Чаще всего, оператор запятая используется в конструкции оператора @code{for},
как здесь:

@example
@group
/* @r{Использование оператора запятая в @code{for} конструкции.} */

for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
  @{
    @dots{}
  @}
@end group
@end example

@noindent
Это позволяет удобно устанавливать, контролировать и изменять несколько
управлящих выражений конструкции @code{for}.

Запятая также используется для разделения параметров функции; Однако, это
@emph{не} оператор запятая в действии.  В самом деле, если оператор запятой
использовать как мы уже обсуждали здесь, в вызове функции, то компилятор
будет интерпретировать это как вызов функции с дополнительным параметром.

Если требуется использовать запятую в качестве аргумента функции, нужно
поставить скобки вокруг неё.  Это потому, что запятая в списке аргументов
функции имеет другой смысл: она разделяет аргументы.  Таким образом,

@example
foo (x,  y=47,  x,  z);
@end example

@noindent
интерпретируется как вызов функции с четырьмя аргументами, но

@example
foo (x,  (y=47,  x),  z);
@end example

@noindent
Это вызов функции с использованием трёх аргументов.  (Второй аргумент
это - выражение @code{(y=47, x)}.)

@node Member Access Expressions
@section Доступ к Членам Выражения
@cindex member access expressions

Можно использовать оператор @code{.} для доступа через переменную к элементу
структуры или объединения.  Имя переменной структуры располагается с левой
стороны, а и имя члена коллекции с правой стороны оператора.

@example
@group
struct point
@{
  int x, y;
@};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
@end group
@end example

@cindex indirect member access operator
Также можно получить доступ через переменную к членам структуры или
объединения с помощью указателя, используя опреатор косвенного доступа к
члену структуры @code{->}.  Выражение @code{x->y} эквивалентно выражению
@code{(*x).y}.

@example
@group
struct fish
  @{
    int length, weight;
  @};

struct fish salmon;

struct fish *fish_pointer = &salmon;

fish_pointer->length = 3;
fish_pointer->weight = 9;
@end group
@end example 

@xref{Pointers}.


@node Conditional Expressions
@section Условные Выражения
@cindex conditional expressions
@cindex expressions, conditional
@cindex ternary operator

Можно использовать условный оператор, чтобы выполнить оценку или его второго
операнда либо третьего, на основании значения истинности первого операнда.
Вот пример:

@example
a ? b : c
@end example

Если выражение @code{a} истинно, то вычисляется выражение @code{b} и
результатом всего выражения является оцененное значение выражения @code{b}.
В противном случае, вычисляется выражение @code{c} и результатом всего
выражения будет вычисленное значение выражения @code{c}.

Выражения @code{b} and @code{c} должны быть совместимыми.  То есть, они оба
должны быть 

@enumerate
@item арифметическими типами
@item совместимыми структурами @code{struct} или типами @code{union}
@item указателями на совместимые типы (один из которых может быть указателем NULL)
@end enumerate 

В качестве альтернативы, один операнд является указателем, а другой является
указателем @code{void*}.

Вот пример

@example
a = (x == 5) ? y : z;
@end example

Здесь, если @code{x} равен 5, то @code{a} получит значение @code{y}.  В
противном случае, @code{a} получит значение @code{z}.  Это можно
рассматривать как метод стенографии для написания простого заявления
@code{if}@dots{}@code{else}.  Следующий пример выполнения той же задачи, как
и в предыдущем:

@example
@group
if (x == 5)
    a = y;
else
    a = z;
@end group
@end example

Если первый операнд условного оператора является оценивается в истину, то
третий операнд никогда не оценивается.  Аналогичным образом, если первый
операнд оценен в ложь, тогда второй операнд никогда не оценивается.  Первый
операнд всегда оценивается.


@c GNU C Рачширения

@node Statements and Declarations in Expressions
@section Выражения в Объявлениях
@cindex statements inside expressions
@cindex declarations inside expressions
@cindex expressions containing statements
@cindex macros, statements in expressions

В качестве расширения GNU Cи, можо построить выражение с помощью составного
оператора, заключенного в круглых скобках.  Это позволяет включать в
выражения циклы, указатели и локальные переменные.

Напомним, что составной оператор (также известный как блок) представляет
собой последовательность операторов заключённую в фигурные скобки.  В этой
конструкции круглые скобки заключают в себя фигурные скобки.  Вот пример:

@example
@group
(@{ int y = function (); int z;
    if (y > 0) z = y;
   else z = - y;
   z; @})
@end group
@end example

Это является допустимым (хотя и несколько более сложным, чем это необходимо)
выражением для абсолютного значения функции @code{function ()}.

Последним элементом в составном операторе должно быть выражение, за которым
следует оператор точки с запятой; значение этого подвыражения служит
заключительным значением всей конструкции.  (Если используется какой-то
другой тип в качестве последнего составного оператора в фигурных скобках,
конструкция возвращает значение типа @code{void}, и, таким образом, не имеет
возвращаемого значения.)

Эта функция особенно полезна для ``безопасного'' объявления макроса (так
что каждый операнд был оценен ровно один раз).  Например, функция ``maximum''
обычно определяется как макрос в стандартном Cи следующим образом:

@example
#define max(a,b) ((a) > (b) ? (a) : (b))
@end example

@noindent
@cindex side effects, macro argument
Но это определение вычисляет либо @code{a} либо @code{b} дважды, с
искажёнными зультатами, если вычисление операнда имеет побочные эффекты.  В
GNU Cи, если известен тип операндов (здесь давайте предположим @code{int}),
можно определить безопасный макрос следующим образом:

@example
#define maxint(a,b) \
  (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @})
@end example

Если тип операнда не известен, можно сделать это, использовав @code{typeof}
для выражения или именованного типа.

@comment Описание для typeof

Встроенный оператор @code{typeof} не допускается  использовать для
константных выражений, таких как константное значение перечисления, размер
битового поля или начальное значение статической переменной.


@node Operator Precedence
@section Приоритет Операторов
@cindex operator precedence
@cindex precedence, operator

Если выражение содержит несколько операторов, такое как @code{a + b * f()},
операторы группируются на основе правил @dfn{приоритета}.  Например, действия
этого выражения состоит из вызова функции @code{f} без аргументов, умножения
её результата выполнения на @code{b} и затем добавление к получившемуся
результату @code{a}.  Вот как правила приоритета операторов Cи, определят
последовательность оценки этого выражения.

Ниже приведен список типов выражений, представленных в порядке, начиная с
наивысшего приоритета.  Иногда два или более оператора имеют одинаковый
приоритет, тогда все эти операторы выполняются по очереди слева направо, если
не явно не задано иное.

@enumerate

@item
Оператор вызова функции, индексации массива и выражение доступа к члену
структуры.

@item
Унарные операторы, в том числе логическое отрицание, побитовое дополнение,
инкрементация, декрементация, унарный плюс, унарный минус, оператор
косвенного обращения, оператор взятия адреса, приведения типов и
@code{sizeof} выражения.  Когда несколько унарных операторов указаны подряд,
идущие позже, вычисляются раньше чем идущие впереди них: @code{!-x} означает
@code{!(-x)}.

@item
Multiplication, division, and modular division expressions.

@item
Выражения сложения и вычитания.

@item
Выражения поразрядного сдвига.

@item
Выражения Большее чем, меньше чем, больше или равно чем, меньше или равно чем@.

@item
Выражения проверки равенства и неравенства.

@item
Побитовые выражения @code{AND (И)}.

@item
Побитовые выражения @code{^ (Исключающее ИЛИ)}.

@item
Побитовые выражения @code{OR (ИЛИ)}.

@item
Логические выражения @code{AND (И)}.

@item
Логические выражения @code{OR (ИЛИ)}.

@item
Условные выражения (использование @code{?:}).  При использовании в качестве
подвыражений, они оцениваются справа налево.

@item
Все выражения присваивания, в том числе составное присваивание.  Когда
несколько операторов присваивания появляются как подвыражения в составе
одного большого выражения, они вычисляются справа налево.

@item
Выражения оператора запятая.

@end enumerate

@c ??? Здесь нужно больше примеров!

@c ??? Нужно объяснить, когда круглые скобки настоятельно рекомендуется
@c для явного определения порядка вычисления.

Приведенный выше перечень несколько суховат и, по-видимому прост и не
покажет скрытых некоторых подводных камней.  Возьмём такой пример:

@example
foo = *p++;
@end example

Здесь @code{p} увеличиваются как побочный эффект выражения, но @code{foo}
принимает значение @code{*(p++)}, а не @code{(*p)++}, так как унарные
операторы выполняются справа налево.  Есть и другие примеры потенциальных
сюрпризов, скрывающихся за завесом приоритета вычисления операторов Cи.  По
этой причине, если есть малейший риск непонимания читателем смысла программы,
нужно использовать круглые скобки, чтобы ясно задать смысл выражения.

@node Order of Evaluation
@section Порядок Вычисления

В Cи нельзя предполагать, что несколько подвыражений вычисляются в порядке,
который кажется естественным.  Например, рассмотрим выражение
@code{++a * f()}.  Означает ли это приращение @code{a} до или после вызова
функции @code{f}?  Компилятор может сделать это в любом порядке, так что
нельзя сделать точное предположение.

Это руководство объясняет абстрактную семантику языка Cи.  Однако реальный
компилятор преобразует исходный код в конкретные действия на реальном
компьютере, и может изменить порядок операций в интересах эффективности.
Соответствие между написанным текстом программы и тем какие действия на самом
деле выполнит компьютер определяются в терминах @emph{побочных эффектов} и
@emph{точек последовательности}.

@menu
* Side Effects::
* Sequence Points::
* Sequence Points Constrain Expressions::
* Sequence Points and Signal Delivery::
@end menu

@node Side Effects
@subsection Побочные Эффекты

@cindex side effect
К @dfn{побочному эффекту} относится одно из следующих действий:
@enumerate
@item доступ к объекту @code{volatile}
@item изменение объекта
@item изменение файла
@item вызов функции, выполняющая один из указанных выше побочных эффектов
@end enumerate

По существу, это внешне видимые эффекты запуска программы.  Они называются
побочными эффектами, потому что они являются следствием @code{оценки}
выражения за пределами фактического результирующего значения выражения.

Компилятор может выполнять операции вашей программы в порядке, отличающийся
от порядка, вытекающего из исходного кода вашей программы, при условии, что
в конце концов отработают все необходимые побочные эффекты.  Компилятору
также позволено полностью опустить некоторые операции; например, он может
пропустить часть оценки выражения, если он уверен, что значение не
используется, и оценка этой части выражения не будет производить никаких
необходимых побочных эффектов.

@node Sequence Points
@subsection Точки Последовательности

Еще одно требование от компилятора является то, что побочные эффекты должны
проявляться в правильном порядке.  Для того, чтобы обеспечить это без
чрезмерного ограничения компилятора, стандарты C89 и C90 указывают список
точек последовательности.  @dfn{Точка последовательности} представляется
одним из следующих действий:

@cindex sequence point
@enumerate
@c authority: С99 стандарт, приложение С
@item вызов функции (после завершения оценки аргумента)
@item конец левостороннего операнда и оператор @code{&&}
@item the end of the left-hand operand of the or operator @code{||}
@item the end of the left-hand operand of the comma operator @code{,}
@item the end of the first operand of the ternary operator @code{a ? b : c}
@item the end of a full declarator
@footnote{a full declarator is a declaration of a function or an object which is not part of another object}
@item the end of an initialisation expression 
@item the end of an expression statement (i.e. an expression followed by @code{;})
@item the end of the controlling expression of an @code{if} or @code{switch} statement
@item the end of the controlling expression of a @code{while} or @code{do} statement
@item the end of any of the three controlling expressions of a @code{for} statement
@item the end of the expression in a return statement
@item immediately before the return of a library function
@item after the actions associated with an item of formatted I/O (as
used for example with the @code{strftime} or the @code{printf} and
@code{scanf} famlies of functions).
@item immediately before and after a call to a comparison function (as
called for example by @code{qsort})
@end enumerate

@c authority: C99 standard, section 5.1.2.3
At a sequence point, all the side effects of previous expression
evaluations must be complete, and no side effects of later evaluations
may have taken place.

@c authority: C89 standard, section 5.1.2.3
@c this description was not included in C99, I assume because of the 
@c introduction of whole-program optimisation
This may seem a little hard to grasp, but there is another way to
consider this.  Imagine you wrote a library (some of whose functions
are external and perhaps others not) and compiled it, allowing someone
else to call one of your functions from their code.  The definitions
above ensure that, at the time they call your function, the data they
pass in has values which are consistent with the behaviour specified
by the abstract machine, and any data returned by your function has a
state which is also consistent with the abstract machine.  This
includes data accessible via pointers (i.e. not just function
parameters and identifiers with external linkage).

The above is a slight simplification, since compilers exist that
perform whole-program optimisation at link time.  Importantly however,
although they might perform optimisations, the visible side effects of
the program must be the same as if they were produced by the abstract
machine.

@node Sequence Points Constrain Expressions
@subsection Sequence Points Constrain Expressions

@c authority: C89 section 6.3, C99 section 6.5
The code fragment 
@example
i = i + 1;
@end example 
is quite normal and no doubt occurs in many programs.  However, the
quite similar code fragment
@example
i = ++i + 1;
@end example 
is a little harder to understand; what is the final value of @code{i}?
The C standards (both C89 and C99) both forbid this construct in 
conforming programs.  

Between two sequence points, 
@enumerate
@item an object may have its stored value modified at most once by the
evaluation of an expression
@item the prior value of the object shall be read only to determine
the value to be stored.
@end enumerate

The first of these two conditions forbids expressions like 
@code{foo(x=2, ++x)}.  The second condition forbids expressions like
@code{a[i++] = i}.

@c with an appropriate list of counterexamples such as f(x++, x++).

@table @code
@item int x=0; foo(++x, ++x)
Not allowed in a conforming program; modifies @code{x} twice before
argument evaluation is complete. 
@item int x=0; bar((++x,++x))
Allowed; the function @code{bar} takes one argument (the value 2
is passed here), and there is a sequence point at the comma operator.
@item *p++ || *p++
Allowed; there is a sequence point at @code{||}.
@item int x = 1, y = x++;
Allowed; there is a sequence point after the full declarator of @code{x}.
@item x=2; x++;
Allowed; there is a sequence point at the end of the first expression
statement.
@item if (x++ > MAX) x = 0;
Allowed; there is a sequence point at the end of the controlling
expression of the @code{if}@footnote{However if for example @code{MAX} is
@code{INT_MAX} and @code{x} is of type @code{int}, we clearly have a
problem with overflow.  @xref{Overflow}.}.
@item (x=y) ? ++x : x--;
Allowed; there is a sequence point before the @code{?}, and only one
of the two following expressions is evaluated.
@item int *p=malloc(sizeof(*p)), *q=p;  *p=foo(); bar((*p)++,(*q)++);
Not allowed; the object at @code{p} is being modified twice
before the evaluation of the arguments to @code{bar} is complete.  The
fact that this is done once via @code{p} and once via @code{q} is
irrelevant, since they both point to the same object.
@end table

Let's go back to the example we used to introduce the problem of the
order of evaluation, @code{++a * f()}.   Suppose the code actually
looks like this:

@example
@group
static int a = 1;

static int f (void)
@{
  a = 100;
  return 3;
@}

int foo (void)
@{
   return ++a * f();
@}
@end group
@end example

Is this code allowed in a standard-conforming program?  Although the
expression in @code{foo} modifies @code{a} twice, this is not a
problem.  Let's look at the two possible cases.

@table @asis
@item The right operand @code{f()} is evaluated first
Since @code{f} returns a value other than void, it must contain a
@code{return} statement.   Therefore, there is a sequence point at the
end of the return expression.  That comes between the modification to
@code{a} that @code{f} makes and the evaluation of the left operand.
@item The left operand @code{++a} is evaluated first
First, @code{a} is incremented.   Then the arguments to @code{f} are
evaluated (there are zero of them).  Then there is a sequence point
before @code{f} is actually called.
@end table

@c C99 does not state explicitly that there is a sequence point after
@c argument evaluation if a function call contains zero arguments.
So, we see that our program is standard-conforming.  Notice that the
above argument does not actually depend on the details of the body of
the function @code{f}.  It only depends on the function containing
something ending in a sequence point -- in our example this is a
return statement, but an expression statement or a full declarator
would do just as well.

@cindex unspecified behaviour
However, the result of executing this code depends on the order of
evaluation of the operands of @code{*}.  If the left-hand operand is
evaluated first, @code{foo} returns 6.  Otherwise, it returns 303.
The C standard does not specify in which order the operands should be
evaluated, and also does not require an implementation either to
document the order or even to stick to one order.  The effect of this
code is @dfn{unspecified}, meaning that one of several specific
things will happen, but the C standards do not say which.



@node Sequence Points and Signal Delivery
@subsection Sequence Points and Signal Delivery

Signals are mainly documented in the GNU C Library manual rather than
this document, even though the C standards consider the compiler and
the C library together to be ``the implementation''.

@c [This scene-setting is probably too long. - jay@gnu.org]
@c
@c Your C program can be notified of asynchronous events by the
@c @dfn{signal} mechanism.  There are a few dozen different possible
@c signals; these include for example @code{SIGINT}, which tells your
@c program that the user pressed the keyboard interrupt key, and
@c @code{SIGFPE} which tells your program that an arithmetic overflow has
@c occurred.  Signals can be asyncronous, for example @code{SIGINT}
@c generally arises outside your program, or normally synchronous like
@c @code{SIGFPE} or @code{SIGABRT} (which indicates your program called
@c the @code{abort} function, directly or indirectly).  Signals can also
@c be sent using the @code{kill} and @code{raise} functions.
@c 
@c All signals have a default effect, usually to terminate the program.
@c However, you can set up a @dfn{signal handler} -- a funciton to be
@c called when a specified signal is delivered.


When a signal is received, this will happen between sequence points.
Side effects on @code{volatile} objects prior to the previous sequence
point will have occurred, but other updates may not have occurred
yet.  This even applies to straight assignments, such as @code{x=0;},
because the code generated for that statement may require more than
one instruction, meaning that it can be interrupted part-way through
by the delivery of a signal.

The C standard is quite restrictive about what data access can occur
within a signal handler.  They can of course use @code{auto}
variables, but in terms of reading or writing other objects, they must
be @code{volatile sig_atomic_t}.  The @code{volatile} type qualifier
ensures that access to the variable in the other parts of the program
doesn't span sequence points and the use of the @code{sig_atomic_t}
type ensures that changes to the variable are atomic with respect to
signal delivery.

The POSIX standard also allows a small number of library functions to
be called from a signal handler.  These functions are referred to as
the set of @dfn{async-signal-safe} functions.  If your program is
intended to run on a POSIX system but not on other systems, you can
safely call these from your signal handler too.

