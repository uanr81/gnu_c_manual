@c ??? Это может быть хорошей идеей, чтобы превратить каждый пример выражения
@c в небольшую программу, которая печатает выходные и, таким образом,
@c показывает, что выражение делает.

@c Это является частью GNU C Reference Manual
@c Copyright (C) 2007-2016 Free Software Foundation, Inc.
@c Смотрите файл gnu-c-manual.texi условия копирования.

@node Expressions and Operators
@chapter Выражения и Операторы

@menu
* Expressions::
* Assignment Operators::
* Incrementing and Decrementing::
* Arithmetic Operators::
* Complex Conjugation::
* Comparison Operators::
* Logical Operators::
* Bit Shifting::
* Bitwise Logical Operators::
* Pointer Operators::
* The sizeof Operator::
* Type Casts::
* Array Subscripts::
* Function Calls as Expressions::
* The Comma Operator::
* Member Access Expressions::
* Conditional Expressions::
* Statements and Declarations in Expressions::
* Operator Precedence::
* Order of Evaluation::
@end menu

@node Expressions
@section Выражения
@cindex expressions

@dfn{Выражение} состоит, по меньшей мере, из одного операнда и содержит ноль
или более операторов.  Операнды - это типизированные объекты, такие как
константы, переменные и вызовы функций, которые возвращают значение.  Вот
некоторые примеры:

@example
@group
47
2 + 2
cosine(3.14159) /* @r{Мы предполагаем, это возвращает значение с плавающей
точкой.} */
@end group
@end example

Круглые скобки для группировки подвыражений:

@example
( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )
@end example

@noindent
Вложенные выражения вычисляются первыми.  В приведенном выше примере,
вначале оцениваются выражения @code{3 + 10} и @code{2 * 6}, затем оцениваются
полученные выражения @code{13} и @code{12}, соответственно.  Затем @code{12}
вычитается из @code{13}, в результате чего получается @code{1}.  Наконец,
@code{1} умножается на @code{2}, в результате чего появляется @code{2}.
Самые внешние круглые скобки в примере не являются обязательными.

@cindex operators

@dfn{Оператор} определяет операцию, которая будет выполняться над его
операндом(ами).  Операторы могут иметь один, два или три операнда, в
зависимости от оператора.

@node Assignment Operators
@section Операторы Присваивания
@cindex assignment operators
@cindex operators, assignment

Операторы присваивания сохраняют значения в переменных.  Си обеспечивает
несколько вариантов операторов присваивания.

Стандартный оператор присваивания @code{=} просто сохранит значение правого
операнда в переменную, указанную в левом операнде.  Как и со всеми
операторами присваивания, левый операнд (обычно называемый как
``lvalue (левое значение)'') не может быть буквальным или постоянным
значением.

@example
@group
int x = 10;
float y = 45.12 + 2.0;
int z = (2 * (3 + function () ));

struct foo @{
  int bar;
  int baz;
@} quux = @{3, 4@};
@end group
@end example

@noindent
Обратите внимание, что, в отличие от других операторов присваивания,
описанных ниже, можно использовать простой оператор присваивания для
хранения значений структурного типа.

Составные операторы присваивания выполняют операцию с участием как левого,
так и правый операнда, затем присваивают полученное выражение левому
операнду.  Вот список составных операторов присваивания и краткое описание
того, что они делают:

@itemize

@item
@code{+=}

Складывает два операнда вместе, затем присваивает результат сложения левому
операнду.

@item
@code{-=}

Вычитает правый операнд из левого операнда, затем присваивает результат
вычитания левому операнду.

@item
@code{*=}

Перемножает два операнда, затем присваивает результат умножения левому
операнду.

@item
@code{/=}

Делит левый операнд на правый операнд, присваивает результат деления левому
операнду.

@item
@code{%=}

Выполняет деление по модулю деление двух операндов, присваивает результат
деления левому операнду.

@item
@code{<<=}

Выполненяет операцию сдвига влево с левым операндом, сдвигая на число битов,
заданное с помощью правого операнда, присваивает результат сдвига левому
операнду.

@item
@code{>>=}

Выполняет операцию сдвига вправо с левым операндом, сдвигая на число битов,
заданное с помощью правого операнда, и присваивает результат сдвига левому
операнду.

@item
@code{&=}

Выполняет поразрядную операцию @code{И} для двух операндов, и присваивает
результат операции левому операнду.

@item
@code{^=}

Выполняет поразрядную операцию @code{исключающего ИЛИ} для двух операндов,
и присваивает результат операции левому операнду.

@item
@code{|=}

Выполняет поразрядную операцию @code{ИЛИ} для двух операндов,
и присваивает результат операции левому операнду.

@end itemize
@comment  __End из соединения назначений списка операторов

Ниже приведен пример использования одного из составных операторов
присваивания:

@example
x += y;
@end example

@noindent
Поскольку нет никаких влияющих побочных эффектов при оценки переменной
@code{x} как lvalue (левого значения), приведенный выше код дает тот же
результат, что и код:

@example
x = x + y;
@end example


@c GNU C Extension -- temporarily commented out for manual 0.1
@c @node Generalized Lvalues
@c @subsubsection Generalized Lvalues
@c @cindex compound expressions as lvalues
@c @cindex expressions, compound, as lvalues
@c @cindex conditional expressions as lvalues
@c index expressions, conditional, as lvalues
@c @cindex casts as lvalues
@c @cindex generalized lvalues
@c @cindex lvalues, generalized
@c @cindex extensions, @code{?:}
@c @cindex @code{?:} extensions
@c 
@c Составные выражения, условные выражения и сдвиги разрешены, как lvalues
@c (левые значения) при ​​условии, что их операнды  также lvalues.  Это
@c означает, что можно взять их адрес или хранимое значение в них.
@c 
@c Например, можно присвоить значение выражения соединения, при условии, что @c последнее выражение в последовательности является именованным.  Эти два
@c выражения эквивалентны:
@c 
@c @example
@c (a, b) += 5
@c a, (b += 5)
@c @end example
@c 
@c Кроме того, можно взять адрес выражения соединения.  Таким образом, эти
@c два выражения эквивалентны:
@c 
@c @example
@c &(a, b)
@c a, &b
@c @end example
@c 
@c Условное выражение является допустимым, если их именованный тип не
@c является недействительным, и если оба и второй и третий операнды являются
@c действительными lvalues (левыми выражениями).  Например, эти два выражения
@c эквивалентны:
@c 
@c @example
@c (a ? b : c) = 5
@c (a ? b = 5 : (c = 5))
@c @end example
@c 
@c Составной тип является допустимым, если его именованный операнд является
@c именным.  Простое назначение которого сторона left-hand представляет
@c собой отливка работает путем преобразования в стороне right-hand первой
@c указанного типа, а затем к типу внутренней стороны выражения left-hand.
@c После этого сохраняется, значение преобразуется обратно к указанному типу,
@c чтобы стать значением задания.  Таким образом, если @code{a} имеет тип
@c @code{char *}, следующие два выражения эквивалентны:
@c (ВопросExpressions 244)
@c 
@c @example
@c (int)a = 5
@c (int)(a = (char *)(int)5)
@c @end example
@c 
@c Назначение-с-арифметической операции, такие как @code{+=}, приложенного к
@c литым выполняет арифметические операции, используя тип полученного из
@c литой, а затем продолжается, как и в предыдущем случае. Таким образом,
@c эти два выражения эквивалентны:
@c 
@c @example
@c (int)a += 5
@c (int)(a = (char *)(int) ((int)a + 5))
@c @end example

@c Вы не можете взять адрес именующее гипсе, потому что использование его
@c адреса не будет работать слаженно.  Предположим, что @code{&(int)f} были
@c разрешены, где @code{f} имеет тип @code{float}. Тогда следующий оператор
@c попытается сохранить целое битового шаблона, где число с плавающей точкой
@c принадлежит:
@c 
@c @example
@c *&(int)f = 1;
@c @end example
@c 
@c Это совершенно отличается от того, что @code{(int)f = 1} будет делать ---
@c что бы преобразовать 1 с плавающей точкой и хранить его.  Вместо того,
@c чтобы причина этого несоответствия, мы считаем, что лучше запретить
@c использование @code{&} на гипсе.
@c 
@c Если вы действительно хотите указатель @code{int *} с адресом @code{f},
@c вы можете просто написать @code{(int *)&f}.

@node Incrementing and Decrementing
@section Увеличение и Уменьшение
@cindex increment operator
@cindex decrement operator
@cindex operator, increment
@cindex operator, decrement

Оператор инкремента @code{++} добавляет 1 (еденицу) к своему операнду.
Операнд должен быть либо переменной одного из примитивных типов данных,
указателем или переменной перечисления.  Можжно применить оператор
инкремента либо до, либо после операнда. вот несколько примеров:

@example
@group
char w = '1';
int x = 5;
char y = 'B';
float z = 5.2;
int *p = &x;

++w;   /* @r{@code{w} теперь символ `2' (не число 2).} */
x++;   /* @r{@code{x} теперь 6.} */
++y;   /* @r{@code{y} теперь `C' (в системах ASCII).} */
z++;   /* @r{@code{z} теперь 6.2.} */
++p;   /* @r{@code{p} теперь @code{&x} + @code{sizeof(int)}.} */
@end group
@end example

@noindent
(Обратите внимание, что увеличивающийся указатель имеет смысл только если
есть основания полагать, что новое значение указателя будет допустимым
адресом памяти.)

Префиксное приращение, добавляет 1 к операнду перед вычислением операнда.
Постфиксное приращение добавляет 1 после того, как операнд вычислен.  В
предыдущих примерах, изменение положения оператора не будет иметь никакого
значения.  Однако, бывают случаи, когда это имеет значение:

@example
@group
int x = 5;
printf ("%d \n", x++); /* @r{Распечатает @code{x}, а затем увеличит его.} */
/* @r{Вывод 5, хотя переменная @code{x} теперь равна 6.} */
printf ("%d \n", ++x); /* @r{Приращение к @code{x}, а затем печать его.} */
/* @r{Вывод и переменная @code{x} теперь равна 7.} */
@end group
@end example

@noindent
Вывод приведенного выше примера:

@example
@group
5
7
@end group
@end example

Кроме того, можно вычесть 1 из операнда с помощью оператора декремента:

@example
@group
int x = 5;

x--; /* @r{@code{x} теперь 4.} */
@end group
@end example

@noindent
Понятия префикс и постфикс, применяются также и с оператором инкремента.

@node Arithmetic Operators
@section Арифметические Операторы
@cindex arithmetic operators
@cindex operators, arithmetic

Си обеспечивает операторы для стандартных арифметических операций: сложения,
вычитания, умножения деления, деление по модулю и отрицание.  Использование
этих операторов просто; вот несколько примеров:

@example
@group
/* @r{Сложение.} */
x = 5 + 3;
y = 10.23 + 37.332;
quux_pointer = foo_pointer + bar_pointer;
@end group
@end example

@example
@group
/* @r{Вычитание.} */
x = 5 - 3;
y = 57.223 - 10.903;
quux_pointer = foo_pointer - bar_pointer;
@end group
@end example

@noindent
Можно складывать и вычитать указатели памяти, но нельзя перемножать и делить
их.

@example
@group
/* @r{Умножение.} */
x = 5 * 3;
y = 47.4 * 1.001;
@end group
@end example

@example
@group
/* @r{Деление.} */
x = 5 / 3;
y = 940.0 / 20.2;
@end group
@end example

@noindent
Целочисленное деление положительных значений обрезает по направлению к нулю,
так что 5/3 равен 1.  Однако, если один из операндов является отрицательным,
то направление округления зависит от реализации.
@ref{Signed Integer Division} для информации о переполнении в знаковом
целочисленном делении.

@c Нужно указать GCC, как ему вести себя, если операнд отрицателен.


Оператор деление по модулю @code{%} используется, чтобы получить остаток от
деления его двух операндов.  Операнды устанавливаются по обе стороны от
оператора, и имеет значение, какой операнд на какой стороне: @code{3 % 5} или
@code{5 % 3} имеют разный результат.  Операнды должны быть выражениями
примитивного типа данных.

@example
@group
/* @r{Деление по модулю.} */
x = 5 % 3;
y = 74 % 47;
@end group
@end example

@noindent
Деление по модулю возвращает остаток, полученный после выполнения деления
целых чисел двух операндов.  Операнды должны быть примитивного целого типа.

@example
@group
/* @r{Отрицание.} */
int x = -5;
float y = -3.14159;
@end group
@end example

Если операнд используемый с оператором отрицания имеет беззнаковый тип
данных, то результат не станет отрицательным, а будет иметь максимальное
значение беззнакового типа данных, за вычетом значения операнда.

Многие системы используют в коде арифметику с дополнением до двух, и на таких
системах самое отрицательное значение, знакового типа, может находится дальше
от нуля, чем самое положительное значение.  Например, на одной платформе, эта
программа:

@example
@group
#include <limits.h>
#include <stdio.h>

int main (int argc, char *argv[]) 
@{
  int x;
  x = INT_MAX;
  printf("INT_MAX  = %d\n", x);
  x = INT_MIN;
  printf("INT_MIN  = %d\n", x);
  x = -x;
  printf("-INT_MIN = %d\n", x);
  return 0;
@}
@end group
@end example

Производит этот вывод:

@example
@group
INT_MAX  = 2147483647
INT_MIN  = -2147483648
-INT_MIN = -2147483648
@end group
@end example

Можно также применить положительный оператор для числового выражения:

@example
int x = +42;
@end example

@noindent
Числовые значения считаются положительными, если явно не сделать его
отрицательным, поэтому этот оператор не оказывает никакого влияния на работу
программы.

@node Complex Conjugation
@section Комплексное Сопряжение
@cindex complex conjugation
@cindex conjugation
 
В качестве расширения GNU, можно использовать оператор комплексного
сопряжения @code{~}, выполняет комплексное сопряжение на операнде --- то
есть, он меняет знак мнимой составляющей.  Операнд должен быть выражением
типа комплесного числа.  Вот пример:
 
@example
@group
__complex__ int x = 5 + 17i;
 
printf ("%d  \n", (x * ~x));
@end group
@end example
 
Так как мнимое число @math{(a + bi)} умноженное на его сопряжённое число
равное @math{a^2 + b^2}, приведенное выше выражение @code{printf} выведет на
печатать число 314, которое получилось из выражения @math{25 + 289}.

@node Comparison Operators
@section Операторы Сравнения
@cindex comparison operators
@cindex operators, comparison

Можно использовать операторы сравнения для определения того, как два операнда
соотносятся друг с другом: они равны друг другу, один больше, чем другой,
один меньше другого, и так далее.  При использовании любого из операторов
сравнения, результат всегда равен 1 или 0, то есть является истинной или
ложью, соответственно.

(В следующих примерах кода, переменные @code{x} and @code{y} содержат любые
два выражения арифметического типа или указателя.)

Оператор равенства @code{==} тестирует свои два операнда на равенство.
Результат равен 1, если операнды равны, и 0, если операнды не равны.

@example
@group
if (x == y)
  puts ("x равен y");
else
  puts ("x не равен y");
@end group
@end example

Оператор неравенства @code{!=} тестирует свои два операнда на неравенство.
Результат равен 1, если операнды не равны, и 0, если операнды @emph{являются}
равными.

@example
@group
if (x != y)
  puts ("x не равен y");
else
  puts ("x равен y");
@end group
@end example

Сравнение значений с плавающей точкой для точного равенства или неравенства
может привести к неожиданным результатам.  @ref{Real Number Types} для
получения дополнительной информации.

Можно сравнивать указатели на функции для равенства или неравенства;
сравнение проверяет, указывают ли указатели на одну и ту же функцию или нет.

Помимо равенства и неравенства, есть операторы, которые можно использовать
для тестирования того, меньше, больше, меньше или равной, больше или равно
одно значение другого значения.  Вот некоторые примеры кода, которые
иллюстрируют использование этих операторов:

@example
@group
if (x < y)
  puts ("x меньше y");
@end group
@end example

@example
@group
if (x <= y)
  puts ("x меньше или равно y");
@end group
@end example

@example
@group
if (x > y)
  puts ("x больше y");
@end group
@end example

@example
@group
if (x >= y)
  puts ("x больше или равно y");
@end group
@end example


@node Logical Operators
@section Логические Операторы
@cindex logical operators

Логические операторы проверяют значение истинности пары операндов.  Любое
выражение отлично от нуля считается истинным в Си, в то время как выражение,
значение которого является ноль считается ложным.

Логический оператор @code{И} - @code{&&} проверяет, если два выражения
истинны.  Если первое выражение ложно, то второе выражение не вычисляется.

@example
@group
if ((x == 5) && (y == 10))
  printf ("x равно 5 и y равно 10");
@end group
@end example

Логический оператор @code{или} - @code{||} проверяет, если хотя бы одно из
двух выражений истинным.  Если первое выражение истинно, то второе выражение
не вычисляется.

@example
@group
if ((x == 5) || (y == 10))
   printf ("x равно 5 или y равно 10");
@end group
@end example

Можете предварять логическое выражение оператором отрицания @code{не} -
@code{!}, который переворачивает значение истинности:

@example
@group
if (!(x == 5))
  printf ("x не равно 5");
@end group
@end example

Так как второй операнд в паре логического выражения не обязательно
вычисляется, возможно написать код с неинтуитивными результатами:

@example
@group
if (foo && x++)
  bar();
@end group
@end example

@noindent
В случае когда оценка @code{foo} не будет равна нулю, то не только произойдёт
вызов @code{bar}, но и значение @code{x} будет увеличино.  Если требуется
увеличивать @code{x} независимо от значения @code{foo}, нужно сделать
приращение за пределами выражения @code{И}.


@node Bit Shifting
@section Битовый Сдвиг
@cindex bit shifting
@cindex shifting

Использование оператора @code{<<} сдвиг влево, сдвинет биты своего первого
операнда влево.  Второй операнд обозначает количество битовых мест для
сдвига.  Биты, сдвинутые на левой стороне значения отбрасываются; новые биты,
добавленные на правой стороне все будет установлены в 0.

@example
@group
x = 47;    /* @r{47 это 00101111 в двоичном представлении.} */
x << 1;    /* @r{00101111 << 1 после сдвига равно 01011110.} */
@end group
@end example

Точно так же оператор @code{>>} сдвига вправо, сдвинет биты своего первого
операнда вправо.  Биты смещённые с правой стороны отбрасываются; новые биты,
добавленные на левой стороне @emph{обычно} устанавливаются в 0, но если
первый операнд является знаковым отрицательным значением, то добавленные биты
будут либо 0 @emph{либо} любым другим значением, которое ранее было в
самой крайней левой позиции бита.

@example
@group
x = 47;   /* @r{47 это 00101111 в двоичном представлении.} */
x >> 1;   /* @r{00101111 >> 1 после сдвига вправо теперь 00010111.} */
@end group
@end example

Для обоих операторов @code{<<} и @code{>>}, если второй операнд больше
битовой ширины первого операнда или второй операнд является отрицательным,
поведение операторов не определено.

Можно использовать операторы сдвига для выполнения множества интересных
трюков.  Например, для работы с датой - учитывая дату с днём ​​месяца
пронумерованной в @code{d}, месяца пронцмерованного @code{m}, и года
пронумерованного @code{y}, можно хранить всю дату в одном числе @code{x}:

@example
int d = 12;
int m = 6;
int y = 1983;
int x = (((y << 4) + m) << 5) + d;
@end example

@noindent
Можно теперь извлечь исходный день, месяц и год из @code{x}, используя
комбинацию операторов сдвига и модульного деления:

@example
d = x % 32;
m = (x >> 5) % 16;
y = x >> 9;
@end example

@node Bitwise Logical Operators
@section Побитовые Логические Операторы
@cindex bitwise logical operators
@cindex logical operators, bitwise

Cи предоставляет операторы для выполнения побитового соединения @code{И},
@code{ИЛИ}, @code{исключающего ИЛИ} и @code{НЕ} (дополнения).

Побитовое соединение @code{И} анализирует каждый бит двух операндов, и
когда два соответствующих бита установлены в 1, результирующий бит
устанавливается в 1.  Во всех остальных случаях, результирующий бит
устанавливается в 0.  Ниже приведен пример того, как это работает, используя
двоичные числа:

@example
11001001 & 10011011 = 10001001
@end example

Побитовое соединение @code{ИЛИ} анализирует каждый бит в двух операндах, и
когда два соответствующих биты установлены в 0, то результирующий бит
устанавливается в 0.  Во всех остальных случаях, результирующий бит
устанавливается в 1.

@example
11001001 | 10011011 = 11011011
@end example

Побитовое соединение @code{исключающее ИЛИ} анализирует каждый бит в двух
операндах, и когда два соответствующих бита отличны по установленному
значению, то результирующий бит устанавливается в 1.  Во всех остальных
случаях, результирующий бит устанавливается в 0.

@example
11001001 ^ 10011011 = 01010010
@end example

Побитовое соединение @code{НЕ} меняет значение каждого бита в операнде на
противоположное:

@example
~11001001 = 00110110
@end example

В Cи, эти операторы можно использовать только с операндами целочисленного
типа (или символьного), а также для обеспечения максимальной переносимости
следует использовать только оператор побитового отрицания с беззнаковыми
целочисленными типами.  Вот некоторые примеры использования этих операторов
в коде Cи:

@example
@group
unsigned int foo = 42;
unsigned int bar = 57;
unsigned int quux;

quux = foo & bar;
quux = foo | bar;
quux = foo ^ bar;
quux = ~foo;
@end group
@end example

@node Pointer Operators
@section Операторы Указателей
@cindex pointer operators

Можно использовать оператор взятия адреса @code{&} для получения адреса
памяти объекта.

@example
@group
int x = 5;
int *pointer_to_x = &x;
@end group
@end example

Не следует использовать этот оператор, чтобы получить адрес функции, хотя
можно так:

@example
@group
extern int foo (void);
int (*fp1) (void) = foo; /* fp1 указатель на foo */
int (*fp2) (void) = &foo; /* fp2 также указывает на foo */
@end group
@end example

Указатели на функции и указатели на данные не совместимы, в том смысле, что
не получиться сохранить адрес функции в указателе на данные, а затем
скопировать этот указатель в указатель на функцию и вызвать потом функцию
успешно.  Это может работать на некоторых системах, но это непереносимая
техника.

В качестве расширения GNU для C89, можно также получить адрес метки используя
оператор взятия адреса метки @code{&&}.  Результатом будет указатель
@code{void*}, который может быть использован оператором @code{goto}.
@xref{The goto Statement}.

Учитывая адрес памяти, хранящийся в указателе, можно использовать оператор
косвенного обращения (разыменования) @code{*}, чтобы получить значение,
хранящееся по адресу.  (Это называется @dfn{разыменованием} указателя.)

@example
@group
int x = 5;
int y;
int *ptr;

ptr = &x;    /* @r{@code{ptr} теперь хранит адрес @code{x}.} */

y = *ptr;    /* @r{@code{y} получает значение, хранящееся по адресу}
                @r{которое сохранено в @code{ptr}.} */
@end group
@end example

@noindent
Избегайте использование разыменования указателей, которые не были
инициализированы в известную ячейку памяти.


@node The sizeof Operator
@section Оператор Получения Размера
@cindex sizeof operator

Можно использовать оператор @code{sizeof}, чтобы получить размер (в байтах)
операнда содержащего тип данных.  Операнд может быть указан с фактическим
спецификатором типа (например, @code{int} или @code{float}), а также быть
любым допустимым выражением.  Когда операнд является именем типа, он должен
быть заключен в скобки.  Вот некоторые примеры:

@example
@group
size_t a = sizeof(int);
size_t b = sizeof(float);
size_t c = sizeof(5);
size_t d = sizeof(5.143);
size_t e = sizeof a;
@end group
@end example

Результат оператора @code{sizeof} имеет имя типа @code{size_t}, которое
определено в файле заголовка @code{<stddef.h>}.  @code{size_t} является
беззнаковым целочисленным типом, может быть идентичен @code{unsigned int} или
@code{unsigned long int}, что меняется от системы к системе.

@code{size_t} тип часто бывает удобным типом для индексации цикла, так как
это позволяет иметь возможность удерживать значение количества элементов в
любом массиве, что не получиться при использовании индексации например с
типом @code{int}.

Оператор @code{sizeof} может использоваться для автоматического вычисления
количества элементов в массиве:

@example
@group
#include <stddef.h>
#include <stdio.h>

static const int values[] = @{ 1, 2, 48, 681 @};
#define ARRAYSIZE(x) (sizeof x/sizeof x[0])

int main (int argc, char *argv[]) 
@{
    size_t i;
    for (i = 0; i < ARRAYSIZE(values); i++) 
    @{
        printf("%d\n", values[i]);
    @}
    return 0;
@}
@end group
@end example

Есть два случая, когда этот метод не работает.  Во-первых, когда элемент
массива имеет нулевой размер  (GCC поддерживает структуры нулевого размера
как расширение GNU).  Во-вторых, если массив фактически является параметром
функции (@pxref{Function Parameters}).

@node Type Casts
@section Приведение Типов
@cindex type casts
@cindex casts

Можно использовать приведение типа, чтобы явно указать, что выражение
относится к определенному типу данных.  Такое приведение состоит из
спецификатора типа, заключенного в скобках, за которым следует выражение.
Для обеспечения правильного приведения,  нужно также заключить выражение,
которое следует за спецификатором типа в скобках. Вот пример:

@example
@group
float x;
int y = 7;
int z = 3;
x = (float) (y / z);
@end group
@end example

В этом примере, поскольку @code{y} и @code{z} оба являются целыми числами,
выполняется целочисленное деление, @code{x} это переменная с плавающей
точкой и принимает вычисленное выражение деления - значение 2.  Здесь явное
приведение результата деления к типу @code{float} не делает ничего хорошего,
потому что вычисленное значение @code{y/z} уже усечено до 2.

Чтобы устранить эту проблему, необходимо преобразовать тип одного из
операндов опрации деления в тип с плавающей точкой до выполнения деления:

@example
@group
float x;
int y = 7;
int z = 3;
x = (y / (float)z);
@end group
@end example

@noindent Здесь, значение с плавающей точкой, близкое к 2.333@dots{},
присваивается @code{x}.

Приведение типа работает только со скалярными типами (то есть с
целочисленными типами, типими числа с плавающей точкой и типами указатель).
Таким образом, это допустимо:

@example
@group
struct fooTag @{ /* коллекция ... */ @};
struct fooTag foo;
unsigned char byteArray[8];

foo = (struct fooType) byteArray; /* @r{Ошибка!} */
@end group
@end example

@node Array Subscripts
@section Индексация Массива
@cindex array subscripts

Можно получить доступ к элементам массива, указав имя массива и индекс
массива (или индекс или номер элемента), заключенного в квадратные скобки.
Ниже приведен пример целочисленного массива с именем @code{my_array}:

@example
@group
my_array[0] = 5;
@end group
@end example

Выражение индекс массива @code{A[i]} определяется как идентично выражению
@code{(*((A)+(i)))}.  Это означает, что многие виды использования имени
массива эквивалентно выражению с указателем.  Это также означает, что нельзя
индексировать массив, имеющий класс хранения @code{register}.

@node Function Calls as Expressions
@section Вызовы Функций как Выражения
@cindex function calls, as expressions

Вызов любой функции, которая возвращает значение, является выражением.

@example
@group
int function(void);
@dots{}
a = 10 + function();
@end group
@end example


@node The Comma Operator
@section Оператор Запятая
@cindex comma operator

Можно использовать оператор запятая @code{,} для разделения двух (якобы
связанных) выражений.  Например, первое выражение может задавать значение,
которое используется вторым выражением:
@c Это работает, потому что существует точка последовательности после оценки
@c левой стороны выражения.
@example
@group
x++, y = x * x;
@end group
@end example

Чаще всего, оператор запятая используется в конструкции оператора @code{for},
как здесь:

@example
@group
/* @r{Использование оператора запятая в @code{for} конструкции.} */

for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
  @{
    @dots{}
  @}
@end group
@end example

@noindent
Это позволяет удобно устанавливать, контролировать и изменять несколько
управлящих выражений конструкции @code{for}.

Запятая также используется для разделения параметров функции; Однако, это
@emph{не} оператор запятая в действии.  В самом деле, если оператор запятой
использовать как мы уже обсуждали здесь, в вызове функции, то компилятор
будет интерпретировать это как вызов функции с дополнительным параметром.

Если требуется использовать запятую в качестве аргумента функции, нужно
поставить скобки вокруг неё.  Это потому, что запятая в списке аргументов
функции имеет другой смысл: она разделяет аргументы.  Таким образом,

@example
foo (x,  y=47,  x,  z);
@end example

@noindent
интерпретируется как вызов функции с четырьмя аргументами, но

@example
foo (x,  (y=47,  x),  z);
@end example

@noindent
Это вызов функции с использованием трёх аргументов.  (Второй аргумент
это - выражение @code{(y=47, x)}.)

@node Member Access Expressions
@section Доступ к Членам Выражения
@cindex member access expressions

Можно использовать оператор @code{.} для доступа через переменную к элементу
структуры или объединения.  Имя переменной структуры располагается с левой
стороны, а и имя члена коллекции с правой стороны оператора.

@example
@group
struct point
@{
  int x, y;
@};

struct point first_point;

first_point.x = 0;
first_point.y = 5;
@end group
@end example

@cindex indirect member access operator
Также можно получить доступ через переменную к членам структуры или
объединения с помощью указателя, используя опреатор косвенного доступа к
члену структуры @code{->}.  Выражение @code{x->y} эквивалентно выражению
@code{(*x).y}.

@example
@group
struct fish
  @{
    int length, weight;
  @};

struct fish salmon;

struct fish *fish_pointer = &salmon;

fish_pointer->length = 3;
fish_pointer->weight = 9;
@end group
@end example 

@xref{Pointers}.


@node Conditional Expressions
@section Условные Выражения
@cindex conditional expressions
@cindex expressions, conditional
@cindex ternary operator

Можно использовать условный оператор, чтобы выполнить оценку или его второго
операнда либо третьего, на основании значения истинности первого операнда.
Вот пример:

@example
a ? b : c
@end example

Если выражение @code{a} истинно, то вычисляется выражение @code{b} и
результатом всего выражения является оцененное значение выражения @code{b}.
В противном случае, вычисляется выражение @code{c} и результатом всего
выражения будет вычисленное значение выражения @code{c}.

Выражения @code{b} and @code{c} должны быть совместимыми.  То есть, они оба
должны быть 

@enumerate
@item арифметическими типами
@item совместимыми структурами @code{struct} или типами @code{union}
@item указателями на совместимые типы (один из которых может быть указателем NULL)
@end enumerate 

В качестве альтернативы, один операнд является указателем, а другой является
указателем @code{void*}.

Вот пример

@example
a = (x == 5) ? y : z;
@end example

Здесь, если @code{x} равен 5, то @code{a} получит значение @code{y}.  В
противном случае, @code{a} получит значение @code{z}.  Это можно
рассматривать как метод стенографии для написания простого заявления
@code{if}@dots{}@code{else}.  Следующий пример выполнения той же задачи, как
и в предыдущем:

@example
@group
if (x == 5)
    a = y;
else
    a = z;
@end group
@end example

Если первый операнд условного оператора является оценивается в истину, то
третий операнд никогда не оценивается.  Аналогичным образом, если первый
операнд оценен в ложь, тогда второй операнд никогда не оценивается.  Первый
операнд всегда оценивается.


@c GNU C Рачширения

@node Statements and Declarations in Expressions
@section Выражения в Объявлениях
@cindex statements inside expressions
@cindex declarations inside expressions
@cindex expressions containing statements
@cindex macros, statements in expressions

В качестве расширения GNU Cи, можо построить выражение с помощью составного
оператора, заключенного в круглых скобках.  Это позволяет включать в
выражения циклы, указатели и локальные переменные.

Напомним, что составной оператор (также известный как блок) представляет
собой последовательность операторов заключённую в фигурные скобки.  В этой
конструкции круглые скобки заключают в себя фигурные скобки.  Вот пример:

@example
@group
(@{ int y = function (); int z;
    if (y > 0) z = y;
   else z = - y;
   z; @})
@end group
@end example

Это является допустимым (хотя и несколько более сложным, чем это необходимо)
выражением для абсолютного значения функции @code{function ()}.

Последним элементом в составном операторе должно быть выражение, за которым
следует оператор точки с запятой; значение этого подвыражения служит
заключительным значением всей конструкции.  (Если используется какой-то
другой тип в качестве последнего составного оператора в фигурных скобках,
конструкция возвращает значение типа @code{void}, и, таким образом, не имеет
возвращаемого значения.)

Эта функция особенно полезна для ``безопасного'' объявления макроса (так
что каждый операнд был оценен ровно один раз).  Например, функция ``maximum''
обычно определяется как макрос в стандартном Cи следующим образом:

@example
#define max(a,b) ((a) > (b) ? (a) : (b))
@end example

@noindent
@cindex side effects, macro argument
Но это определение вычисляет либо @code{a} либо @code{b} дважды, с
искажёнными зультатами, если вычисление операнда имеет побочные эффекты.  В
GNU Cи, если известен тип операндов (здесь давайте предположим @code{int}),
можно определить безопасный макрос следующим образом:

@example
#define maxint(a,b) \
  (@{int _a = (a), _b = (b); _a > _b ? _a : _b; @})
@end example

Если тип операнда не известен, можно сделать это, использовав @code{typeof}
для выражения или именованного типа.

@comment Описание для typeof

Встроенный оператор @code{typeof} не допускается  использовать для
константных выражений, таких как константное значение перечисления, размер
битового поля или начальное значение статической переменной.


@node Operator Precedence
@section Приоритет Операторов
@cindex operator precedence
@cindex precedence, operator

Если выражение содержит несколько операторов, такое как @code{a + b * f()},
операторы группируются на основе правил @dfn{приоритета}.  Например, действия
этого выражения состоит из вызова функции @code{f} без аргументов, умножения
её результата выполнения на @code{b} и затем добавление к получившемуся
результату @code{a}.  Вот как правила приоритета операторов Cи, определят
последовательность оценки этого выражения.

Ниже приведен список типов выражений, представленных в порядке, начиная с
наивысшего приоритета.  Иногда два или более оператора имеют одинаковый
приоритет, тогда все эти операторы выполняются по очереди слева направо, если
не явно не задано иное.

@enumerate

@item
Оператор вызова функции, индексации массива и выражение доступа к члену
структуры.

@item
Унарные операторы, в том числе логическое отрицание, побитовое дополнение,
инкрементация, декрементация, унарный плюс, унарный минус, оператор
косвенного обращения, оператор взятия адреса, приведения типов и
@code{sizeof} выражения.  Когда несколько унарных операторов указаны подряд,
идущие позже, вычисляются раньше чем идущие впереди них: @code{!-x} означает
@code{!(-x)}.

@item
Multiplication, division, and modular division expressions.

@item
Выражения сложения и вычитания.

@item
Выражения поразрядного сдвига.

@item
Выражения Большее чем, меньше чем, больше или равно чем, меньше или равно чем@.

@item
Выражения проверки равенства и неравенства.

@item
Побитовые выражения @code{AND (И)}.

@item
Побитовые выражения @code{^ (Исключающее ИЛИ)}.

@item
Побитовые выражения @code{OR (ИЛИ)}.

@item
Логические выражения @code{AND (И)}.

@item
Логические выражения @code{OR (ИЛИ)}.

@item
Условные выражения (использование @code{?:}).  При использовании в качестве
подвыражений, они оцениваются справа налево.

@item
Все выражения присваивания, в том числе составное присваивание.  Когда
несколько операторов присваивания появляются как подвыражения в составе
одного большого выражения, они вычисляются справа налево.

@item
Выражения оператора запятая.

@end enumerate

@c ??? Здесь нужно больше примеров!

@c ??? Нужно объяснить, когда круглые скобки настоятельно рекомендуется
@c для явного определения порядка вычисления.

Приведенный выше перечень несколько суховат и, по-видимому прост и не
покажет скрытых некоторых подводных камней.  Возьмём такой пример:

@example
foo = *p++;
@end example

Здесь @code{p} увеличиваются как побочный эффект выражения, но @code{foo}
принимает значение @code{*(p++)}, а не @code{(*p)++}, так как унарные
операторы выполняются справа налево.  Есть и другие примеры потенциальных
сюрпризов, скрывающихся за завесом приоритета вычисления операторов Cи.  По
этой причине, если есть малейший риск непонимания читателем смысла программы,
нужно использовать круглые скобки, чтобы ясно задать смысл выражения.

@node Order of Evaluation
@section Порядок Вычисления

В Cи нельзя предполагать, что несколько подвыражений вычисляются в порядке,
который кажется естественным.  Например, рассмотрим выражение
@code{++a * f()}.  Означает ли это приращение @code{a} до или после вызова
функции @code{f}?  Компилятор может сделать это в любом порядке, так что
нельзя сделать точное предположение.

Это руководство объясняет абстрактную семантику языка Cи.  Однако реальный
компилятор преобразует исходный код в конкретные действия на реальном
компьютере, и может изменить порядок операций в интересах эффективности.
Соответствие между написанным текстом программы и тем какие действия на самом
деле выполнит компьютер определяются в терминах @emph{побочных эффектов} и
@emph{точек последовательности}.

@menu
* Side Effects::
* Sequence Points::
* Sequence Points Constrain Expressions::
* Sequence Points and Signal Delivery::
@end menu

@node Side Effects
@subsection Побочные Эффекты

@cindex side effect
К @dfn{побочному эффекту} относится одно из следующих действий:
@enumerate
@item доступ к объекту @code{volatile}
@item изменение объекта
@item изменение файла
@item вызов функции, выполняющая один из указанных выше побочных эффектов
@end enumerate

По существу, это внешне видимые эффекты запуска программы.  Они называются
побочными эффектами, потому что они являются следствием @code{оценки}
выражения за пределами фактического результирующего значения выражения.

Компилятор может выполнять операции вашей программы в порядке, отличающийся
от порядка, вытекающего из исходного кода вашей программы, при условии, что
в конце концов отработают все необходимые побочные эффекты.  Компилятору
также позволено полностью опустить некоторые операции; например, он может
пропустить часть оценки выражения, если он уверен, что значение не
используется, и оценка этой части выражения не будет производить никаких
необходимых побочных эффектов.

@node Sequence Points
@subsection Точки Последовательности

Еще одно требование к компилятору является то, что побочные эффекты должны
проявляться в правильном порядке.  Для того, чтобы обеспечить это без
чрезмерного ограничения компилятора, стандарты C89 и C90 определяют список
точек последовательности.  @dfn{Точка последовательности} представляется
одним из следующих действий:

@cindex sequence point
@enumerate
@c authority: С99 стандарт, приложение С
@item после вызова функции (после завершения оценки аргумента)
@item после левостороннего операнда оператора @code{AND (И)} @code{&&}
@item после левого операнда оператора @code{OR (ИЛИ)} @code{||}
@item после левого операнда оператора запятая @code{,}
@item после первого операнда тернарного оператора @code{a ? b : c}
@item после полного объявления
@footnote{полное объявление - это объявление функции или объекта, который не
является частью другого объекта}
@item после выражения инициализации 
@item после конструкций выражений (т.е. выражение с последующим @code{;})
@item после объявления управляющих конструкций @code{if} или @code{switch}
@item после объявления управляющего выражения @code{while} или @code{do}
@item после объявления любого из трех управляющих выражений @code{for}
@item после выражения оператора возврата
@item непосредственно перед возвращением библиотечной функции
@item после действий, связанных с элементом форматированного I/O (как это
используется, например, с @code{strftime} или @code{printf} и @code{scanf}
родственных функций).
@item непосредственно перед и после вызова функции сравнения (как это
происходит, например, при использовании @code{qsort})
@end enumerate

@c authority: C99 standard, section 5.1.2.3
В точке последовательности, все побочные эффекты оценки предыдущих выражений
должны быть завершены, и никакие побочных эффектов последующих оценок
выражений не имеют смысла.

@c authority: C89 standard, section 5.1.2.3
@c это описание не было включено в C99, я предполагаю, что из-за внедрение
@c оптимизации программы в целом
Это может показаться трудным для понимания, но есть и другой способ, чтобы
рассмотреть это.  Представьте, что вы написали библиотеку (некоторые из
функции являются внешними и, возможно, другие нет) и скомпилировал её,
разрешается вызов одной из этих функций из внешнего кода.  Определения
приведённые выше гарантируют, что в момент вызова вашей функции, данные,
которые ей перадаются, имеют согласованное значение, заданное виртуальной
машиной, и любые данные, возвращаемые вашей функцией имеют состояние, которое
также будет согласовано с виртуальной машиной.  Это включает в себя данные,
доступные с помощью указателей (т.е. не только параметры функций и
идентификаторы с внешним связыванием).

Вышесказанное является небольшим упрощением, поскольку существуют
компиляторы, которые выполняют оптимизацию программы в целом, уже во время
компоновки.  Важно отметить, однако, хотя они могут выполнять оптимизации,
видимые побочные эффекты программы должны быть такими же, как если бы они
были получены с помощью виртуальной машины.

@node Sequence Points Constrain Expressions
@subsection Ограничение Выражений Точками Последовательности

@c authority: C89 section 6.3, C99 section 6.5
Фрагмент кода 
@example
i = i + 1;
@end example 
это вполне нормально, и нет сомнений в том, что происходит во многих
программах.  Тем не менее, вполне аналогичный фрагмент кода
@example
i = ++i + 1;
@end example 
немного сложнее понять; каково окончательное значение @code{i}?  Стандарты Cи
(как C89 и C99)запрещают эту конструкцию в соответствии программ.  

Между двух точек последовательности, 
@enumerate
@item объект может иметь свое сохраненное значение модифицированное не более
одного раза в ходе оценки выражения
@item предварительное значение объекта должно быть только для чтения, чтобы
определить значение для сохранения.
@end enumerate

Первый из этих двух условий запрещают выражения типа @code{foo(x=2, ++x)}.
Второе условие запрещает такие выражения, как @code{a[i++] = i}.

@c с соответствии с этим списком примеры, такие как f(x++, x++).

@table @code
@item int x=0; foo(++x, ++x)
Не допускается для соответствия программы, модифицировать @code{x} дважды,
прежде чем оценка аргумента завершена.
@item int x=0; bar((++x,++x))
Позволено, функция @code{bar} принимает один аргумент (в аргументе передано
два значения), и есть точка последовательности - оператор запятая.
@item *p++ || *p++
Позволено, существует точка последовательности на @code{||}.
@item int x = 1, y = x++;
Позволено, существует точка последовательности после полного описания
@code{x}.
@item x=2; x++;
Позволено, существует точка последовательности в конце первого оператора
выражения.
@item if (x++ > MAX) x = 0;
Позволено, существует точка последовательности в конце управляющего выражения
@code{if}@footnote{Однако, если, например @code{MAX} является @code{INT_MAX}
и @code{x} имеет тип @code{int}, мы явно имеем проблему с переполнением.
@xref{Overflow}.}.
@item (x=y) ? ++x : x--;
Позволено, существует точка последовательности перед @code{?}, и только один
из двух следующих выражений оцениваются.
@item int *p=malloc(sizeof(*p)), *q=p;  *p=foo(); bar((*p)++,(*q)++);
Не допустимо, объект в @code{p} модифицируется дважды, прежде чем оценка
аргументов @code{bar} завершена.  Тот факт, что это делается один раз через
@code{p} и один раз через @code{q} не имеет никакого значения, так как они
указывают на один и тот же объект.
@end table

Вернемся к примеру, мы использовали, чтобы представить проблему порядка
оценки, @code{++a * f()}.  Предположим, что код на самом деле выглядит
следующим образом:

@example
@group
static int a = 1;

static int f (void)
@{
  a = 100;
  return 3;
@}

int foo (void)
@{
   return ++a * f();
@}
@end group
@end example

Разрешён ли этот код в соответствии стандартам программы?  Хотя выражение в
@code{foo} модифицирует @code{a} дважды, это не проблема.  Давайте посмотрим
на два возможных случаях.

@table @asis
@item Правый операнд @code{f()} оценивается первым.  Поскольку @code{f}
возвращает значение, отличное от void (неопределенно), выражение должно
содержать @code{return} объявление.  Таким образом, существует точка
последовательности в конце выражения возврата.  Это происходит между
модификацией @code{a}, при работе @code{f} и оценки левого операнда.
@item Левый операнд @code{++a} вычисляется первым.  Во-первых, @code{a}
увеличивается.  Затем вычисляются аргументы @code{f} (их нет).  Затем
существует точка последовательности перед фактическим вызовом @code{f}.
@end table

@c C99 не указывает явно, что существует точка последовательности после
@c оценки аргумента, если вызов функции не содержит аргументов.
Итак, мы видим, что наша программа соответствует стандарту.  Обратите
внимание, что приведенное выше рассуждение фактически не зависит от деталей
тела функции @code{f}.  Это зависит только от того, что функция содержит
что-то, что заканчивающееся точкой последовательности - в нашем примере это
оператор возврата, но оператор выражения или полное описание также подойдёт.

@cindex unspecified behaviour
Тем не менее, результат выполнения этого кода зависит от порядка вычисления
операндов @code{*}.  Если левый операнд вычисляется первым, @code{foo}
возвращает 6.  В противном случае она возвращает 303.  Стандарт Cи не
определяет, в каком порядке операнды должны быть оценены, а также не требует
реализации документирования порядка и не требует придерживаться такого
порядка.  Эффект этого кода @dfn{не определённ}, а это означает, что может
произойти одно из нескольких конкретных вещей, но стандарты Cи не
определяют что именно произойдёт в этом случае.



@node Sequence Points and Signal Delivery
@subsection Точки Последовательности и Доставка Сигналов

Сигналы в основном описаны в руководстве GNU C Library, а не в этом
документе, несмотря на это, стандарты Cи рассматривают компилятор и
библиотеку Cи  вместе как ``реализацию''.

@c [Эта сцена-установка, вероятно, слишком долго. - jay@gnu.org]
@c
@c Ваша программа Cи может быть уведомлена асинхронными событиями по
@c механизму @dfn{signal}.  Есть несколько десятков различных возможных
@c сигналов;  К ним относятся, например, @code{SIGINT}, который уведомляет
@c свою программу о том, что пользователь нажал на клавиатуре клавишу
@c прерывания и @code{SIGFPE}, который указывает своей программе о том, что
@c произошло арифметическое переполнение.  Сигналы могут быть асинхронными,
@c например, @code{SIGINT} обычно возникает за пределами вашей программы, или
@c обычными синхронными, такими как @code{SIGFPE} или @code{SIGABRT} (вызов
@c функции @code{abort}, прямо или косвенно).  Сигналы также могут быть
@c отправлены с помощью функции @code{kill} и @code{raise}.
@c 
@c Все сигналы имеют эффект по умолчанию, как правило, для завершения
@c программы.  Тем не менее, вы можете настроить @dfn{signal handler} - в
@c работе функции, когда указанный сигнал подается.


Когда сигнал получен, это будет происходить между точками последовательности.
Побочные эффекты на @code{volatile} объектов до предыдущей точки
последовательности будет учтены, но другие обновления, возможно, ещё не
произошли.  Это относится даже к прямым присвоениям, таким как @code{x=0;},
так как код, сгенерированный для этого заявления может потребовать более
одной команды, а это означает, что его отработка может быть прервана на
полпути его выполнения, путем доставки сигнала.

Стандарт Си весьма ограничивает с доступом к данным внутри обработчика
сигнала.  Они могут использовать @code{auto} переменные, но с точки зрения
чтения или записи других объектов, они должны быть
@code{volatile sig_atomic_t}.  В @code{volatile} типе гарантируется, что
доступ к переменной в других частях программы не охватывает точки
последовательности и использование @code{sig_atomic_t} типа обеспечивает
поведение, при котором изменения в переменной являются атомарными
относительно доставки сигнала.

Стандарт POSIX также позволяет небольшое количество библиотечных функций для
вызова из обработчика сигнала.  Эти функции называются набором функций
@dfn{безопасных-фссинхронных-сигналовa}.  Если ваша программа предназначена
для запуска на системе POSIX, но не в других системах, вы можете смело
вызывать их из обработчика сигнала тоже.

