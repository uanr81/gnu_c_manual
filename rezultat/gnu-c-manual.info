This is gnu-c-manual.info, produced by texi2any version 6.7 from
gnu-c-manual.texi.

Copyright (C) 2007-2015 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts and no Back-Cover Texts.
A copy of the license is included in the section entitled "GNU Free
Documentation License."


File: gnu-c-manual.info,  Node: Top,  Next: Preface,  Up: (dir)

GNU C Справочное руководство
****************************

Это справочное руководство GNU C.

* Menu:

* Preface::
* Lexical Elements::
* Data Types::
* Expressions and Operators::
* Statements::
* Functions::
* Program Structure and Scope::
* A Sample Program::
* Overflow::
* GNU Free Documentation License::
* Index::


File: gnu-c-manual.info,  Node: Preface,  Next: Lexical Elements,  Prev: Top,  Up: Top

Preface
*******

This is a reference manual for the C programming language as implemented
by the GNU Compiler Collection (GCC). Specifically, this manual aims to
document:

   * The 1989 ANSI C standard, commonly known as "C89"
   * The 1999 ISO C standard, commonly known as "C99", to the extent
     that C99 is implemented by GCC
   * The current state of GNU extensions to standard C

This manual describes C89 as its baseline.  C99 features and GNU
extensions are explicitly labeled as such.

   By default, GCC will compile code as C89 plus GNU-specific
extensions.  Much of C99 is supported; once full support is available,
the default compilation dialect will be C99 plus GNU-specific
extensions.  (Some of the GNU extensions to C89 ended up, sometimes
slightly modified, as standard language features in C99.)

   The C language includes a set of preprocessor directives, which are
used for things such as macro text replacement, conditional compilation,
and file inclusion.  Although normally described in a C language manual,
the GNU C preprocessor has been thoroughly documented in 'The C
Preprocessor', a separate manual which covers preprocessing for C, C++,
and Objective-C programs, so it is not included here.

Credits
=======

Thanks to everyone who has helped with editing, proofreading, ideas,
typesetting, and administrivia, including: Diego Andres Alvarez Marin,
Nelson H. F. Beebe, Karl Berry, Robert Chassell, Hanfeng Chen, Mark de
Volld, Antonio Diaz Diaz, dine, Andreas Foerster, Denver Gingerich, Lisa
Goldstein, Robert Hansen, Jean-Christophe Helary, Mogens Hetsholm, Teddy
Hogeborn, Joe Humphries, J. Wren Hunt, Dutch Ingraham, Adam Johansen,
Vladimir Kadlec, Benjamin Kagia, Dright Kayorent, Sugun Kedambadi, Felix
Lee, Bjorn Liencres, Steve Morningthunder, Aljosha Papsch, Matthew
Plant, Jonathan Sisti, Richard Stallman, J. Otto Tennant, Ole Tetlie,
Keith Thompson, T.F. Torrey, James Youngman, and Steve Zachar.  Trevis
Rothwell serves as project maintainer and, along with James Youngman,
wrote the bulk of the text.

   Some example programs are based on algorithms in Donald Knuth's 'The
Art of Computer Programming'.

   Please send bug reports and suggestions to <gnu-c-manual@gnu.org>.


File: gnu-c-manual.info,  Node: Lexical Elements,  Next: Data Types,  Prev: Preface,  Up: Top

1 Лексические Элементы
**********************

В этой главе описывается лексические элементы, которые составляют
исходный код Cи после предварительной обработки.  Эти элементы
называются "токены".  Есть пять типов токенов: ключевые слова,
идентификаторы, константы, операторы и разделители.  Пропуски, иногда
требуется, чтобы разделить отдельные лексемы, это всё описано в этой
главе.

* Menu:

* Identifiers::
* Keywords::
* Constants::
* Operators::
* Separators::
* White Space::


File: gnu-c-manual.info,  Node: Identifiers,  Next: Keywords,  Up: Lexical Elements

1.1 Идентификаторы
==================

Идентификаторы представляют собой последовательность символов,
используются для обозначения переменных, функций, новых типов данных и
макросов препроцессора.  Можно также включать в идентификаторы буквы,
десятичные цифры, и символ подчеркивания '_'.

   Первый символ идентификатора не может быть цифрой.

   Строчные буквы и прописные буквы различаются, так что 'foo' и 'FOO'
два разных идентификатора.

   При использовании расширений GNU, вы можете также включать символ '$'
(знак доллара) в идентификаторах.


File: gnu-c-manual.info,  Node: Keywords,  Next: Constants,  Prev: Identifiers,  Up: Lexical Elements

1.2 Ключевые Слова
==================

Ключевые слова являются специальными идентификаторами зарезервироваными
для использования в качестве части самого языка программирования.  Вы не
можете использовать их для любых других целей.

   Вот список ключевых слов признан ANSI C89:

     auto break case char const continue default do double else enum extern
     float for goto if int long register return short signed sizeof static
     struct switch typedef union unsigned void volatile while

ISO C99 добавляет следующие ключевые слова:

     inline _Bool _Complex _Imaginary

и расширение GNU добавляет эти ключевые слова:

     __FUNCTION__ __PRETTY_FUNCTION__ __alignof __alignof__ __asm
     __asm__ __attribute __attribute__ __builtin_offsetof __builtin_va_arg
     __complex __complex__ __const __extension__ __func__ __imag __imag__
     __inline __inline__ __label__ __null __real __real__
     __restrict __restrict__ __signed __signed__ __thread __typeof
     __volatile __volatile__

В обоих ISO C99 и C89 с расширениями GNU, следующее также признаётся в
качестве ключевого слова:
     restrict


File: gnu-c-manual.info,  Node: Constants,  Next: Operators,  Prev: Keywords,  Up: Lexical Elements

1.3 Constants
=============

Константа является буквальным числовым или символьным значением,
например, '5' или ''m''.  Все константы относятся к конкретному типу
данных; Вы можете использовать явное приведение типов для указания типа
константы или позволить компилятору использовать тип по умолчанию на
основе значения константы.

* Menu:

* Integer Constants::
* Character Constants::
* Real Number Constants::
* String Constants::


File: gnu-c-manual.info,  Node: Integer Constants,  Next: Character Constants,  Up: Constants

1.3.1 Целочисленные Константы
-----------------------------

Целочисленная константа представляет собой последовательность цифр, с
необязательным префиксом для обозначения системы счисления.

   Если последовательности цифр предшествует '0x' или '0X' (ноль или
ноль затем X), то константа считается шестнадцатеричным (основание 16).
Шестнадцатеричные значения используют цифры от 0 до 9, а также буквы от
'a' до 'f' и от 'A' до 'F'.  Вот некоторые примеры:

     0x2f
     0x88
     0xAB43
     0xAbCd
     0x1

   Если первая цифра 0 (ноль), а следующий символ не является 'x' или
'X', то константа считается восьмеричной (основание 8).  Восьмеричные
значения могут использовать только цифры от 0 до 7, 8 и 9 не
допускаются.  Вот некоторые примеры:

     057
     012
     03
     0241

   Во всех других случаях последовательность цифр считается десятичной
константой (основание 10).  Десятичные значения могут состоять из цифр
от 0 до 9.  Ниже приведены некоторые примеры:

     459
     23901
     8
     12

   Существуют различные типы целочисленных данных, для коротких целых,
длинных целых чисел, целых чисел и целых чисел без знака.  Вы можете
заставить целую константу быть длинным типом и/или целым числом без
знака, добавив к последовательности одну или несколько букв из
следующего списка в конце константы:

'u'
'U'
     Целочисленный тип без знака.

'l'
'L'
     Длинный целочисленный тип.

   Например, '45U' является константой с типом значения 'unsigned int
(беззнаковое целочисленное)'.  Вы также можете комбинировать буквы:
'45UL' - указывает тип значения константы как 'беззнаковое длинное
целочисленное'.  (Буквы могут быть использованы в любом порядке.)

   Оба расширения ISO C99 и GNU C добавляют целочисленные типы 'long
long int' (целочисленное двойной длинны) и 'unsigned long long int'
(беззнаковое целочисленное двойной длинны).  Вы можете использовать два
'L's, чтобы получить константу 'long long int'; и добавить 'U' тогда,
кода константа является 'unsigned long long int'.  Например: '45ULL'.


File: gnu-c-manual.info,  Node: Character Constants,  Next: Real Number Constants,  Prev: Integer Constants,  Up: Constants

1.3.2 Character Constants
-------------------------

Символьная константа характер, как правило, это один символ, заключенный
в одинарные кавычки, например, ''Q''.  Символьная константа имеет тип
'int' по умолчанию.

   Некоторые символы, такие как одиночная кавычка, не могут быть
представлены только самим один символом.  Для представления таких
символов, есть несколько "escape последовательностей", которые вы можете
использовать:

'\\'
     Backslash character.

'\?'
     Question mark character.

'\''
     Single quotation mark.

'\"'
     Double quotation mark.

'\a'
     Audible alert.

'\b'
     Backspace character.

'\e'
     <ESC> character.  (This is a GNU extension.)

'\f'
     Form feed.

'\n'
     Newline character.

'\r'
     Carriage return.

'\t'
     Horizontal tab.

'\v'
     Vertical tab.

'\o, \oo, \ooo'
     Octal number.

'\xh, \xhh, \xhhh, ...'
     Hexadecimal number.

   To use any of these escape sequences, enclose the sequence in single
quotes, and treat it as if it were any other character.  For example,
the letter m is ''m'' and the newline character is ''\n''.

   The octal number escape sequence is the backslash character followed
by one, two, or three octal digits (0 to 7).  For example, 101 is the
octal equivalent of 65, which is the ASCII character ''A''.  Thus, the
character constant ''\101'' is the same as the character constant ''A''.

   The hexadecimal escape sequence is the backslash character, followed
by 'x' and an unlimited number of hexadecimal digits (0 to 9, and 'a' to
'f' or 'A' to 'F').

   While the length of possible hexadecimal digit strings is unlimited,
the number of character constants in any given character set is not.
(The much-used extended ASCII character set, for example, has only 256
characters in it.)  If you try to use a hexadecimal value that is
outside the range of characters, you will get a compile-time error.


File: gnu-c-manual.info,  Node: Real Number Constants,  Next: String Constants,  Prev: Character Constants,  Up: Constants

1.3.3 Real Number Constants
---------------------------

A real number constant is a value that represents a fractional (floating
point) number.  It consists of a sequence of digits which represents the
integer (or "whole") part of the number, a decimal point, and a sequence
of digits which represents the fractional part.

   Either the integer part or the fractional part may be omitted, but
not both.  Here are some examples:

     double a, b, c, d, e, f;

     a = 4.7;

     b = 4.;

     c = 4;

     d = .7;

     e = 0.7;

(In the third assignment statement, the integer constant 4 is
automatically converted from an integer value to a double value.)

   Real number constants can also be followed by 'e' or 'E', and an
integer exponent.  The exponent can be either positive or negative.

     double x, y;

     x = 5e2;   /* 'x' is 5 * 100, or 500.0. */
     y = 5e-2;  /* 'y' is 5 * (1/100), or 0.05. */

   You can append a letter to the end of a real number constant to cause
it to be of a particular type.  If you append the letter F (or f) to a
real number constant, then its type is 'float'.  If you append the
letter L (or l), then its type is 'long double'.  If you do not append
any letters, then its type is 'double'.


File: gnu-c-manual.info,  Node: String Constants,  Prev: Real Number Constants,  Up: Constants

1.3.4 String Constants
----------------------

A string constant is a sequence of zero or more characters, digits, and
escape sequences enclosed within double quotation marks.  A string
constant is of type "array of characters".  All string constants contain
a null termination character ('\0') as their last character.  Strings
are stored as arrays of characters, with no inherent size attribute.
The null termination character lets string-processing functions know
where the string ends.

   Adjacent string constants are concatenated (combined) into one
string, with the null termination character added to the end of the
final concatenated string.

   A string cannot contain double quotation marks, as double quotation
marks are used to enclose the string.  To include the double quotation
mark character in a string, use the '\"' escape sequence.  You can use
any of the escape sequences that can be used as character constants in
strings.  Here are some example of string constants:

     /* This is a single string constant. */
     "tutti frutti ice cream"

     /* These string constants will be concatenated, same as above. */
     "tutti " "frutti" " ice " "cream"

     /* This one uses two escape sequences. */
     "\"hello, world!\""

If a string is too long to fit on one line, you can use a backslash '\'
to break it up onto separate lines.

     "Today's special is a pastrami sandwich on rye bread with \
     a potato knish and a cherry soda."

Adjacent strings are automatically concatenated, so you can also have
string constants span multiple lines by writing them as separate,
adjacent, strings.  For example:

     "Tomorrow's special is a corned beef sandwich on "
     "pumpernickel bread with a kasha knish and seltzer water."

is the same as

     "Tomorrow's special is a corned beef sandwich on \
     pumpernickel bread with a kasha knish and seltzer water."

   To insert a newline character into the string, so that when the
string is printed it will be printed on two different lines, you can use
the newline escape sequence '\n'.

     printf ("potato\nknish");

prints

     potato
     knish


File: gnu-c-manual.info,  Node: Operators,  Next: Separators,  Prev: Constants,  Up: Lexical Elements

1.4 Operators
=============

An operator is a special token that performs an operation, such as
addition or subtraction, on either one, two, or three operands.  Full
coverage of operators can be found in a later chapter.  *Note
Expressions and Operators::.


File: gnu-c-manual.info,  Node: Separators,  Next: White Space,  Prev: Operators,  Up: Lexical Elements

1.5 Separators
==============

A separator separates tokens.  White space (see next section) is a
separator, but it is not a token.  The other separators are all
single-character tokens themselves:

     ( ) [ ] { } ; , . :


File: gnu-c-manual.info,  Node: White Space,  Prev: Separators,  Up: Lexical Elements

1.6 White Space
===============

White space is the collective term used for several characters: the
space character, the tab character, the newline character, the vertical
tab character, and the form-feed character.  White space is ignored
(outside of string and character constants), and is therefore optional,
except when it is used to separate tokens.  This means that

     #include <stdio.h>

     int
     main()
     {
       printf( "hello, world\n" );
       return 0;
     }

and

     #include <stdio.h> int main(){printf("hello, world\n");
     return 0;}

are functionally the same program.

   Although you must use white space to separate many tokens, no white
space is required between operators and operands, nor is it required
between other separators and that which they separate.

     /* All of these are valid. */

     x++;
     x ++ ;
     x=y+z;
     x = y + z ;
     x=array[2];
     x = array [ 2 ] ;
     fraction=numerator / *denominator_ptr;
     fraction = numerator / * denominator_ptr ;

Furthermore, wherever one space is allowed, any amount of white space is
allowed.

     /* These two statements are functionally identical. */
     x++;

     x
            ++       ;

   In string constants, spaces and tabs are not ignored; rather, they
are part of the string.  Therefore,

     "potato knish"

is not the same as

     "potato                        knish"


File: gnu-c-manual.info,  Node: Data Types,  Next: Expressions and Operators,  Prev: Lexical Elements,  Up: Top

2 Data Types
************

* Menu:

* Primitive Types::
* Enumerations::
* Unions::
* Structures::
* Arrays::
* Pointers::
* Incomplete Types::
* Type Qualifiers::
* Storage Class Specifiers::
* Renaming Types::


File: gnu-c-manual.info,  Node: Primitive Types,  Next: Enumerations,  Up: Data Types

2.1 Primitive Data Types
========================

* Menu:

* Integer Types::
* Real Number Types::
* Complex Number Types::


File: gnu-c-manual.info,  Node: Integer Types,  Next: Real Number Types,  Up: Primitive Types

2.1.1 Integer Types
-------------------

The integer data types range in size from at least 8 bits to at least 32
bits.  The C99 standard extends this range to include integer sizes of
at least 64 bits.  You should use integer types for storing whole number
values (and the 'char' data type for storing characters).  The sizes and
ranges listed for these types are minimums; depending on your computer
platform, these sizes and ranges may be larger.

   While these ranges provide a natural ordering, the standard does not
require that any two types have a different range.  For example, it is
common for 'int' and 'long' to have the same range.  The standard even
allows 'signed char' and 'long' to have the same range, though such
platforms are very unusual.

   * 'signed char'
     The 8-bit 'signed char' data type can hold integer values in the
     range of -128 to 127.

   * 'unsigned char'
     The 8-bit 'unsigned char' data type can hold integer values in the
     range of 0 to 255.

   * 'char'
     Depending on your system, the 'char' data type is defined as having
     the same range as either the 'signed char' or the 'unsigned char'
     data type (they are three distinct types, however).  By convention,
     you should use the 'char' data type specifically for storing ASCII
     characters (such as '`m''), including escape sequences (such as
     '`\n'').

   * 'short int'
     The 16-bit 'short int' data type can hold integer values in the
     range of -32,768 to 32,767.  You may also refer to this data type
     as 'short', 'signed short int', or 'signed short'.

   * 'unsigned short int'
     The 16-bit 'unsigned short int' data type can hold integer values
     in the range of 0 to 65,535.  You may also refer to this data type
     as 'unsigned short'.

   * 'int'
     The 32-bit 'int' data type can hold integer values in the range of
     -2,147,483,648 to 2,147,483,647.  You may also refer to this data
     type as 'signed int' or 'signed'.

   * 'unsigned int'
     The 32-bit 'unsigned int' data type can hold integer values in the
     range of 0 to 4,294,967,295.  You may also refer to this data type
     simply as 'unsigned'.

   * 'long int'
     The 32-bit 'long int' data type can hold integer values in the
     range of at least -2,147,483,648 to 2,147,483,647.  (Depending on
     your system, this data type might be 64-bit, in which case its
     range is identical to that of the 'long long int' data type.)  You
     may also refer to this data type as 'long', 'signed long int', or
     'signed long'.

   * 'unsigned long int'
     The 32-bit 'unsigned long int' data type can hold integer values in
     the range of at least 0 to 4,294,967,295.  (Depending on your
     system, this data type might be 64-bit, in which case its range is
     identical to that of the 'unsigned long long int' data type.)  You
     may also refer to this data type as 'unsigned long'.

   * 'long long int'
     The 64-bit 'long long int' data type can hold integer values in the
     range of -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.
     You may also refer to this data type as 'long long', 'signed long
     long int' or 'signed long long'.  This type is not part of C89, but
     is both part of C99 and a GNU C extension.

   * 'unsigned long long int'
     The 64-bit 'unsigned long long int' data type can hold integer
     values in the range of at least 0 to 18,446,744,073,709,551,615.
     You may also refer to this data type as 'unsigned long long'.  This
     type is not part of C89, but is both part of C99 and a GNU C
     extension.

   Here are some examples of declaring and defining integer variables:

     int foo;
     unsigned int bar = 42;
     char quux = 'a';

The first line declares an integer named 'foo' but does not define its
value; it is left uninitialized, and its value should not be assumed to
be anything in particular.


File: gnu-c-manual.info,  Node: Real Number Types,  Next: Complex Number Types,  Prev: Integer Types,  Up: Primitive Types

2.1.2 Real Number Types
-----------------------

There are three data types that represent fractional numbers.  While the
sizes and ranges of these types are consistent across most computer
systems in use today, historically the sizes of these types varied from
system to system.  As such, the minimum and maximum values are stored in
macro definitions in the library header file 'float.h'.  In this
section, we include the names of the macro definitions in place of their
possible values; check your system's 'float.h' for specific numbers.

   * 'float'
     The 'float' data type is the smallest of the three floating point
     types, if they differ in size at all.  Its minimum value is stored
     in the 'FLT_MIN', and should be no greater than '1e-37'.  Its
     maximum value is stored in 'FLT_MAX', and should be no less than
     '1e37'.

   * 'double'
     The 'double' data type is at least as large as the 'float' type,
     and it may be larger.  Its minimum value is stored in 'DBL_MIN',
     and its maximum value is stored in 'DBL_MAX'.

   * 'long double'
     The 'long double' data type is at least as large as the 'float'
     type, and it may be larger.  Its minimum value is stored in
     'LDBL_MIN', and its maximum value is stored in 'LDBL_MAX'.

All floating point data types are signed; trying to use 'unsigned
float', for example, will cause a compile-time error.

   Here are some examples of declaring and defining real number
variables:

     float foo;
     double bar = 114.3943;

The first line declares a float named 'foo' but does not define its
value; it is left uninitialized, and its value should not be assumed to
be anything in particular.

   The real number types provided in C are of finite precision, and
accordingly, not all real numbers can be represented exactly.  Most
computer systems that GCC compiles for use a binary representation for
real numbers, which is unable to precisely represent numbers such as,
for example, 4.2.  For this reason, we recommend that you consider not
comparing real numbers for exact equality with the '==' operator, but
rather check that real numbers are within an acceptable tolerance.

   There are other more subtle implications of these imprecise
representations; for more details, see David Goldberg's paper 'What
Every Computer Scientist Should Know About Floating-Point Arithmetic'
and section 4.2.2 of Donald Knuth's 'The Art of Computer Programming'.


File: gnu-c-manual.info,  Node: Complex Number Types,  Prev: Real Number Types,  Up: Primitive Types

2.1.3 Complex Number Types
--------------------------

GCC introduced some complex number types as an extension to C89.
Similar features were introduced in C99(1), but there were a number of
differences.  We describe the standard complex number types first.

* Menu:

* Standard Complex Number Types::
* GNU Extensions for Complex Number Types::

   ---------- Footnotes ----------

   (1) C++ also has complex number support, but it is incompatible with
the ISO C99 types.


File: gnu-c-manual.info,  Node: Standard Complex Number Types,  Next: GNU Extensions for Complex Number Types,  Up: Complex Number Types

2.1.3.1 Standard Complex Number Types
.....................................

Complex types were introduced in C99.  There are three complex types:

     'float _Complex'
     'double _Complex'
     'long double _Complex'

   The names here begin with an underscore and an uppercase letter in
order to avoid conflicts with existing programs' identifiers.  However,
the C99 standard header file '<complex.h>' introduces some macros which
make using complex types easier.

     'complex'
     Expands to '_Complex'.  This allows a variable to be declared as
     'double complex' which seems more natural.

     'I'
     A constant of type 'const float _Complex' having the value of the
     imaginary unit normally referred to as i.

   The '<complex.h>' header file also declares a number of functions for
performing computations on complex numbers, for example the 'creal' and
'cimag' functions which respectively return the real and imaginary parts
of a 'double complex' number.  Other functions are also provided, as
shown in this example:

     #include <complex.h>
     #include <stdio.h>

     void example (void)
     {
       complex double z = 1.0 + 3.0*I;
       printf ("Phase is %f, modulus is %f\n", carg (z), cabs (z));
     }


File: gnu-c-manual.info,  Node: GNU Extensions for Complex Number Types,  Prev: Standard Complex Number Types,  Up: Complex Number Types

2.1.3.2 GNU Extensions for Complex Number Types
...............................................

GCC also introduced complex types as a GNU extension to C89, but the
spelling is different.  The floating-point complex types in GCC's C89
extension are:

     '__complex__ float'
     '__complex__ double'
     '__complex__ long double'

   GCC's extension allow for complex types other than floating-point, so
that you can declare complex character types and complex integer types;
in fact '__complex__' can be used with any of the primitive data types.
We won't give you a complete list of all possibilities, but here are
some examples:

   * '__complex__ float'
     The '__complex__ float' data type has two components: a real part
     and an imaginary part, both of which are of the 'float' data type.

   * '__complex__ int'
     The '__complex__ int' data type also has two components: a real
     part and an imaginary part, both of which are of the 'int' data
     type.

   To extract the real part of a complex-valued expression, use the
keyword '__real__', followed by the expression.  Likewise, use
'__imag__' to extract the imaginary part.

     __complex__ float a = 4 + 3i;

     float b = __real__ a;          /* 'b' is now 4. */
     float c = __imag__ a;          /* 'c' is now 3. */

   This example creates a complex floating point variable 'a', and
defines its real part as 4 and its imaginary part as 3.  Then, the real
part is assigned to the floating point variable 'b', and the imaginary
part is assigned to the floating point variable 'c'.


File: gnu-c-manual.info,  Node: Enumerations,  Next: Unions,  Prev: Primitive Types,  Up: Data Types

2.2 Enumerations
================

An enumeration is a custom data type used for storing constant integer
values and referring to them by names.  By default, these values are of
type 'signed int'; however, you can use the '-fshort-enums' GCC compiler
option to cause the smallest possible integer type to be used instead.
Both of these behaviors conform to the C89 standard, but mixing the use
of these options within the same program can produce incompatibilities.

* Menu:

* Defining Enumerations::
* Declaring Enumerations::


File: gnu-c-manual.info,  Node: Defining Enumerations,  Next: Declaring Enumerations,  Up: Enumerations

2.2.1 Defining Enumerations
---------------------------

You define an enumeration using the 'enum' keyword, followed by the name
of the enumeration (this is optional), followed by a list of constant
names (separated by commas and enclosed in braces), and ending with a
semicolon.

     enum fruit {grape, cherry, lemon, kiwi};

   That example defines an enumeration, 'fruit', which contains four
constant integer values, 'grape', 'cherry', 'lemon', and 'kiwi', whose
values are, by default, 0, 1, 2, and 3, respectively.  You can also
specify one or more of the values explicitly:

     enum more_fruit {banana = -17, apple, blueberry, mango};

   That example defines 'banana' to be -17, and the remaining values are
incremented by 1: 'apple' is -16, 'blueberry' is -15, and 'mango' is
-14.  Unless specified otherwise, an enumeration value is equal to one
more than the previous value (and the first value defaults to 0).

   You can also refer to an enumeration value defined earlier in the
same enumeration:

     enum yet_more_fruit {kumquat, raspberry, peach,
                          plum = peach + 2};

   In that example, 'kumquat' is 0, 'raspberry' is 1, 'peach' is 2, and
'plum' is 4.

   You can't use the same name for an 'enum' as a 'struct' or 'union' in
the same scope.


File: gnu-c-manual.info,  Node: Declaring Enumerations,  Prev: Defining Enumerations,  Up: Enumerations

2.2.2 Declaring Enumerations
----------------------------

You can declare variables of an enumeration type both when the
enumeration is defined and afterward.  This example declares one
variable, named 'my_fruit' of type 'enum fruit', all in a single
statement:

     enum fruit {banana, apple, blueberry, mango} my_fruit;

while this example declares the type and variable separately:

     enum fruit {banana, apple, blueberry, mango};
     enum fruit my_fruit;

   (Of course, you couldn't declare it that way if you hadn't named the
enumeration.)

   Although such variables are considered to be of an enumeration type,
you can assign them any value that you could assign to an 'int'
variable, including values from other enumerations.  Furthermore, any
variable that can be assigned an 'int' value can be assigned a value
from an enumeration.

   However, you cannot change the values in an enumeration once it has
been defined; they are constant values.  For example, this won't work:

     enum fruit {banana, apple, blueberry, mango};
     banana = 15;  /* You can't do this! */

   Enumerations are useful in conjunction with the 'switch' statement,
because the compiler can warn you if you have failed to handle one of
the enumeration values.  Using the example above, if your code handles
'banana', 'apple' and 'mango' only but not 'blueberry', GCC can generate
a warning.


File: gnu-c-manual.info,  Node: Unions,  Next: Structures,  Prev: Enumerations,  Up: Data Types

2.3 Unions
==========

A union is a custom data type used for storing several variables in the
same memory space.  Although you can access any of those variables at
any time, you should only read from one of them at a time--assigning a
value to one of them overwrites the values in the others.

* Menu:

* Defining Unions::
* Declaring Union Variables::
* Accessing Union Members::
* Size of Unions::


File: gnu-c-manual.info,  Node: Defining Unions,  Next: Declaring Union Variables,  Up: Unions

2.3.1 Defining Unions
---------------------

You define a union using the 'union' keyword followed by the
declarations of the union's members, enclosed in braces.  You declare
each member of a union just as you would normally declare a
variable--using the data type followed by one or more variable names
separated by commas, and ending with a semicolon.  Then end the union
definition with a semicolon after the closing brace.

   You should also include a name for the union between the 'union'
keyword and the opening brace.  This is syntactically optional, but if
you leave it out, you can't refer to that union data type later on
(without a 'typedef', *note The typedef Statement::).

   Here is an example of defining a simple union for holding an integer
value and a floating point value:

     union numbers
       {
         int i;
         float f;
       };

   That defines a union named 'numbers', which contains two members, 'i'
and 'f', which are of type 'int' and 'float', respectively.


File: gnu-c-manual.info,  Node: Declaring Union Variables,  Next: Accessing Union Members,  Prev: Defining Unions,  Up: Unions

2.3.2 Declaring Union Variables
-------------------------------

You can declare variables of a union type when both you initially define
the union and after the definition, provided you gave the union type a
name.

* Menu:

* Declaring Union Variables at Definition::
* Declaring Union Variables After Definition::
* Initializing Union Members::


File: gnu-c-manual.info,  Node: Declaring Union Variables at Definition,  Next: Declaring Union Variables After Definition,  Up: Declaring Union Variables

2.3.2.1 Declaring Union Variables at Definition
...............................................

You can declare variables of a union type when you define the union type
by putting the variable names after the closing brace of the union
definition, but before the final semicolon.  You can declare more than
one such variable by separating the names with commas.

     union numbers
       {
         int i;
         float f;
       } first_number, second_number;

   That example declares two variables of type 'union numbers',
'first_number' and 'second_number'.


File: gnu-c-manual.info,  Node: Declaring Union Variables After Definition,  Next: Initializing Union Members,  Prev: Declaring Union Variables at Definition,  Up: Declaring Union Variables

2.3.2.2 Declaring Union Variables After Definition
..................................................

You can declare variables of a union type after you define the union by
using the 'union' keyword and the name you gave the union type, followed
by one or more variable names separated by commas.

     union numbers
       {
         int i;
         float f;
       };
     union numbers first_number, second_number;

   That example declares two variables of type 'union numbers',
'first_number' and 'second_number'.


File: gnu-c-manual.info,  Node: Initializing Union Members,  Prev: Declaring Union Variables After Definition,  Up: Declaring Union Variables

2.3.2.3 Initializing Union Members
..................................

You can initialize the first member of a union variable when you declare
it:

     union numbers
       {
         int i;
         float f;
       };
     union numbers first_number = { 5 };

   In that example, the 'i' member of 'first_number' gets the value 5.
The 'f' member is left alone.

   Another way to initialize a union member is to specify the name of
the member to initialize.  This way, you can initialize whichever member
you want to, not just the first one.  There are two methods that you can
use--either follow the member name with a colon, and then its value,
like this:

     union numbers first_number = { f: 3.14159 };

or precede the member name with a period and assign a value with the
assignment operator, like this:

     union numbers first_number = { .f = 3.14159 };

   You can also initialize a union member when you declare the union
variable during the definition:

     union numbers
       {
         int i;
         float f;
       } first_number = { 5 };


File: gnu-c-manual.info,  Node: Accessing Union Members,  Next: Size of Unions,  Prev: Declaring Union Variables,  Up: Unions

2.3.3 Accessing Union Members
-----------------------------

You can access the members of a union variable using the member access
operator.  You put the name of the union variable on the left side of
the operator, and the name of the member on the right side.

     union numbers
       {
         int i;
         float f;
       };
     union numbers first_number;
     first_number.i = 5;
     first_number.f = 3.9;

   Notice in that example that giving a value to the 'f' member
overrides the value stored in the 'i' member.


File: gnu-c-manual.info,  Node: Size of Unions,  Prev: Accessing Union Members,  Up: Unions

2.3.4 Size of Unions
--------------------

This size of a union is equal to the size of its largest member.
Consider the first union example from this section:

     union numbers
       {
         int i;
         float f;
       };

The size of the union data type is the same as 'sizeof (float)', because
the 'float' type is larger than the 'int' type.  Since all of the
members of a union occupy the same memory space, the union data type
size doesn't need to be large enough to hold the sum of all their sizes;
it just needs to be large enough to hold the largest member.


File: gnu-c-manual.info,  Node: Structures,  Next: Arrays,  Prev: Unions,  Up: Data Types

2.4 Structures
==============

A structure is a programmer-defined data type made up of variables of
other data types (possibly including other structure types).

* Menu:

* Defining Structures::
* Declaring Structure Variables::
* Accessing Structure Members::
* Bit Fields::
* Size of Structures::


File: gnu-c-manual.info,  Node: Defining Structures,  Next: Declaring Structure Variables,  Up: Structures

2.4.1 Defining Structures
-------------------------

You define a structure using the 'struct' keyword followed by the
declarations of the structure's members, enclosed in braces.  You
declare each member of a structure just as you would normally declare a
variable--using the data type followed by one or more variable names
separated by commas, and ending with a semicolon.  Then end the
structure definition with a semicolon after the closing brace.

   You should also include a name for the structure in between the
'struct' keyword and the opening brace.  This is optional, but if you
leave it out, you can't refer to that structure data type later on
(without a 'typedef', *note The typedef Statement::).

   Here is an example of defining a simple structure for holding the X
and Y coordinates of a point:

     struct point
       {
         int x, y;
       };

   That defines a structure type named 'struct point', which contains
two members, 'x' and 'y', both of which are of type 'int'.

   Structures (and unions) may contain instances of other structures and
unions, but of course not themselves.  It is possible for a structure or
union type to contain a field which is a pointer to the same type (*note
Incomplete Types::).


File: gnu-c-manual.info,  Node: Declaring Structure Variables,  Next: Accessing Structure Members,  Prev: Defining Structures,  Up: Structures

2.4.2 Declaring Structure Variables
-----------------------------------

You can declare variables of a structure type when both you initially
define the structure and after the definition, provided you gave the
structure type a name.

* Menu:

* Declaring Structure Variables at Definition::
* Declaring Structure Variables After Definition::
* Initializing Structure Members::


File: gnu-c-manual.info,  Node: Declaring Structure Variables at Definition,  Next: Declaring Structure Variables After Definition,  Up: Declaring Structure Variables

2.4.2.1 Declaring Structure Variables at Definition
...................................................

You can declare variables of a structure type when you define the
structure type by putting the variable names after the closing brace of
the structure definition, but before the final semicolon.  You can
declare more than one such variable by separating the names with commas.

     struct point
       {
         int x, y;
       } first_point, second_point;

   That example declares two variables of type 'struct point',
'first_point' and 'second_point'.


File: gnu-c-manual.info,  Node: Declaring Structure Variables After Definition,  Next: Initializing Structure Members,  Prev: Declaring Structure Variables at Definition,  Up: Declaring Structure Variables

2.4.2.2 Declaring Structure Variables After Definition
......................................................

You can declare variables of a structure type after defining the
structure by using the 'struct' keyword and the name you gave the
structure type, followed by one or more variable names separated by
commas.

     struct point
       {
         int x, y;
       };
     struct point first_point, second_point;

   That example declares two variables of type 'struct point',
'first_point' and 'second_point'.


File: gnu-c-manual.info,  Node: Initializing Structure Members,  Prev: Declaring Structure Variables After Definition,  Up: Declaring Structure Variables

2.4.2.3 Initializing Structure Members
......................................

You can initialize the members of a structure type to have certain
values when you declare structure variables.

   If you do not initialize a structure variable, the effect depends on
whether it has static storage (*note Storage Class Specifiers::) or not.
If it is, members with integral types are initialized with 0 and pointer
members are initialized to NULL; otherwise, the value of the structure's
members is indeterminate.

   One way to initialize a structure is to specify the values in a set
of braces and separated by commas.  Those values are assigned to the
structure members in the same order that the members are declared in the
structure in definition.

     struct point
       {
         int x, y;
       };
     struct point first_point = { 5, 10 };

   In that example, the 'x' member of 'first_point' gets the value 5,
and the 'y' member gets the value 10.

   Another way to initialize the members is to specify the name of the
member to initialize.  This way, you can initialize the members in any
order you like, and even leave some of them uninitialized.  There are
two methods that you can use.  The first method is available in C99 and
as a C89 extension in GCC:

     struct point first_point = { .y = 10, .x = 5 };

   You can also omit the period and use a colon instead of '=', though
this is a GNU C extension:

     struct point first_point = { y: 10, x: 5 };

   You can also initialize the structure variable's members when you
declare the variable during the structure definition:

     struct point
       {
         int x, y;
       } first_point = { 5, 10 };

   You can also initialize fewer than all of a structure variable's
members:

     struct pointy
       {
         int x, y;
         char *p;
       };
     struct pointy first_pointy = { 5 };

   Here, 'x' is initialized with 5, 'y' is initialized with 0, and 'p'
is initialized with NULL. The rule here is that 'y' and 'p' are
initialized just as they would be if they were static variables.

   Here is another example that initializes a structure's members which
are structure variables themselves:

     struct point
       {
         int x, y;
       };

     struct rectangle
       {
         struct point top_left, bottom_right;
       };

     struct rectangle my_rectangle = { {0, 5}, {10, 0} };

   That example defines the 'rectangle' structure to consist of two
'point' structure variables.  Then it declares one variable of type
'struct rectangle' and initializes its members.  Since its members are
structure variables, we used an extra set of braces surrounding the
members that belong to the 'point' structure variables.  However, those
extra braces are not necessary; they just make the code easier to read.


File: gnu-c-manual.info,  Node: Accessing Structure Members,  Next: Bit Fields,  Prev: Declaring Structure Variables,  Up: Structures

2.4.3 Accessing Structure Members
---------------------------------

You can access the members of a structure variable using the member
access operator.  You put the name of the structure variable on the left
side of the operator, and the name of the member on the right side.

     struct point
       {
         int x, y;
       };

     struct point first_point;

     first_point.x = 0;
     first_point.y = 5;

   You can also access the members of a structure variable which is
itself a member of a structure variable.

     struct rectangle
       {
         struct point top_left, bottom_right;
       };

     struct rectangle my_rectangle;

     my_rectangle.top_left.x = 0;
     my_rectangle.top_left.y = 5;

     my_rectangle.bottom_right.x = 10;
     my_rectangle.bottom_right.y = 0;


File: gnu-c-manual.info,  Node: Bit Fields,  Next: Size of Structures,  Prev: Accessing Structure Members,  Up: Structures

2.4.4 Bit Fields
----------------

You can create structures with integer members of nonstandard sizes,
called _bit fields_.  You do this by specifying an integer ('int',
'char', 'long int', etc.) member as usual, and inserting a colon and the
number of bits that the member should occupy in between the member's
name and the semicolon.

     struct card
       {
         unsigned int suit : 2;
         unsigned int face_value : 4;
       };

   That example defines a structure type with two bit fields, 'suit' and
'face_value', which take up 2 bits and 4 bits, respectively.  'suit' can
hold values from 0 to 3, and 'face_value' can hold values from 0 to 15.
Notice that these bit fields were declared as 'unsigned int'; had they
been signed integers, then their ranges would have been from -2 to 1,
and from -8 to 7, respectively.

   More generally, the range of an unsigned bit field of N bits is from
0 to 2^N - 1, and the range of a signed bit field of N bits is from
-(2^N) / 2 to ((2^N) / 2) - 1.

   Bit fields can be specified without a name in order to control which
actual bits within the containing unit are used.  However, the effect of
this is not very portable and it is rarely useful.  You can also specify
a bit field of size 0, which indicates that subsequent bit fields not
further bit fields should be packed into the unit containing the
previous bit field.  This is likewise not generally useful.

   You may not take the address of a bit field with the address operator
'&' (*note Pointer Operators::).


File: gnu-c-manual.info,  Node: Size of Structures,  Prev: Bit Fields,  Up: Structures

2.4.5 Size of Structures
------------------------

The size of a structure type is equal to the sum of the size of all of
its members, possibly including padding to cause the structure type to
align to a particular byte boundary.  The details vary depending on your
computer platform, but it would not be atypical to see structures padded
to align on four- or eight-byte boundaries.  This is done in order to
speed up memory accesses of instances of the structure type.

   As a GNU extension, GCC allows structures with no members.  Such
structures have zero size.

   If you wish to explicitly omit padding from your structure types
(which may, in turn, decrease the speed of structure memory accesses),
then GCC provides multiple methods of turning packing off.  The quick
and easy method is to use the '-fpack-struct' compiler option.  For more
details on omitting packing, please see the GCC manual which corresponds
to your version of the compiler.


File: gnu-c-manual.info,  Node: Arrays,  Next: Pointers,  Prev: Structures,  Up: Data Types

2.5 Arrays
==========

An array is a data structure that lets you store one or more elements
consecutively in memory.  In C, array elements are indexed beginning at
position zero, not one.

* Menu:

* Declaring Arrays::
* Initializing Arrays::
* Accessing Array Elements::
* Multidimensional Arrays::
* Arrays as Strings::
* Arrays of Unions::
* Arrays of Structures::


File: gnu-c-manual.info,  Node: Declaring Arrays,  Next: Initializing Arrays,  Up: Arrays

2.5.1 Declaring Arrays
----------------------

You declare an array by specifying the data type for its elements, its
name, and the number of elements it can store.  Here is an example that
declares an array that can store ten integers:

     int my_array[10];

   For standard C code, the number of elements in an array must be
positive.

   As a GNU extension, the number of elements can be as small as zero.
Zero-length arrays are useful as the last element of a structure which
is really a header for a variable-length object:

     struct line
     {
       int length;
       char contents[0];
     };

     {
       struct line *this_line = (struct line *)
         malloc (sizeof (struct line) + this_length);
       this_line -> length = this_length;
     }

   Another GNU extension allows you to declare an array size using
variables, rather than only constants.  For example, here is a function
definition that declares an array using its parameter as the number of
elements:

     int
     my_function (int number)
     {
       int my_array[number];
       ...;
     }


File: gnu-c-manual.info,  Node: Initializing Arrays,  Next: Accessing Array Elements,  Prev: Declaring Arrays,  Up: Arrays

2.5.2 Initializing Arrays
-------------------------

You can initialize the elements in an array when you declare it by
listing the initializing values, separated by commas, in a set of
braces.  Here is an example:

     int my_array[5] = { 0, 1, 2, 3, 4 };

   You don't have to explicitly initialize all of the array elements.
For example, this code initializes the first three elements as
specified, and then initializes the last two elements to a default value
of zero:

     int my_array[5] = { 0, 1, 2 };

   When using either ISO C99, or C89 with GNU extensions, you can
initialize array elements out of order, by specifying which array
indices to initialize.  To do this, include the array index in brackets,
and optionally the assignment operator, before the value.  Here is an
example:

     int my_array[5] = { [2] 5, [4] 9 };
Or, using the assignment operator:

     int my_array[5] = { [2] = 5, [4] = 9 };

Both of those examples are equivalent to:

     int my_array[5] = { 0, 0, 5, 0, 9 };

   When using GNU extensions, you can initialize a range of elements to
the same value, by specifying the first and last indices, in the form '
[FIRST] ... [LAST] '.  Here is an example:

     int new_array[100] = { [0 ... 9] = 1, [10 ... 98] = 2, 3 };

   That initializes elements 0 through 9 to 1, elements 10 through 98 to
2, and element 99 to 3.  (You also could explicitly write '[99] = 3'.)
Also, notice that you _must_ have spaces on both sides of the '...'.

   If you initialize every element of an array, then you do not have to
specify its size; its size is determined by the number of elements you
initialize.  Here is an example:

     int my_array[] = { 0, 1, 2, 3, 4 };

   Although this does not explicitly state that the array has five
elements using 'my_array[5]', it initializes five elements, so that is
how many it has.

   Alternately, if you specify which elements to initialize, then the
size of the array is equal to the highest element number initialized,
plus one.  For example:

     int my_array[] = { 0, 1, 2, [99] = 99 };

   In that example, only four elements are initialized, but the last one
initialized is element number 99, so there are 100 elements.


File: gnu-c-manual.info,  Node: Accessing Array Elements,  Next: Multidimensional Arrays,  Prev: Initializing Arrays,  Up: Arrays

2.5.3 Accessing Array Elements
------------------------------

You can access the elements of an array by specifying the array name,
followed by the element index, enclosed in brackets.  Remember that the
array elements are numbered starting with zero.  Here is an example:

     my_array[0] = 5;

   That assigns the value 5 to the first element in the array, at
position zero.  You can treat individual array elements like variables
of whatever data type the array is made up of.  For example, if you have
an array made of a structure data type, you can access the structure
elements like this:

     struct point
     {
       int x, y;
     };
     struct point point_array[2] = { {4, 5}, {8, 9} };
     point_array[0].x = 3;


File: gnu-c-manual.info,  Node: Multidimensional Arrays,  Next: Arrays as Strings,  Prev: Accessing Array Elements,  Up: Arrays

2.5.4 Multidimensional Arrays
-----------------------------

You can make multidimensional arrays, or "arrays of arrays".  You do
this by adding an extra set of brackets and array lengths for every
additional dimension you want your array to have.  For example, here is
a declaration for a two-dimensional array that holds five elements in
each dimension (a two-element array consisting of five-element arrays):

     int two_dimensions[2][5] { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10} };

   Multidimensional array elements are accessed by specifying the
desired index of both dimensions:

     two_dimensions[1][3] = 12;

   In our example, 'two_dimensions[0]' is itself an array.  The element
'two_dimensions[0][2]' is followed by 'two_dimensions[0][3]', not by
'two_dimensions[1][2]'.


File: gnu-c-manual.info,  Node: Arrays as Strings,  Next: Arrays of Unions,  Prev: Multidimensional Arrays,  Up: Arrays

2.5.5 Arrays as Strings
-----------------------

You can use an array of characters to hold a string (*note String
Constants::).  The array may be built of either signed or unsigned
characters.

   When you declare the array, you can specify the number of elements it
will have.  That number will be the maximum number of characters that
should be in the string, including the null character used to end the
string.  If you choose this option, then you do not have to initialize
the array when you declare it.  Alternately, you can simply initialize
the array to a value, and its size will then be exactly large enough to
hold whatever string you used to initialize it.

   There are two different ways to initialize the array.  You can
specify of comma-delimited list of characters enclosed in braces, or you
can specify a string literal enclosed in double quotation marks.

   Here are some examples:

     char blue[26];
     char yellow[26] = {'y', 'e', 'l', 'l', 'o', 'w', '\0'};
     char orange[26] = "orange";
     char gray[] = {'g', 'r', 'a', 'y', '\0'};
     char salmon[] = "salmon";

   In each of these cases, the null character '\0' is included at the
end of the string, even when not explicitly stated.  (Note that if you
initialize a string using an array of individual characters, then the
null character is _not_ guaranteed to be present.  It might be, but such
an occurrence would be one of chance, and should not be relied upon.)

   After initialization, you cannot assign a new string literal to an
array using the assignment operator.  For example, this _will not work_:

     char lemon[26] = "custard";
     lemon = "steak sauce";      /* Fails! */

However, there are functions in the GNU C library that perform
operations (including copy) on string arrays.  You can also change one
character at a time, by accessing individual string elements as you
would any other array:

     char name[] = "bob";
     name[0] = 'r';

   It is possible for you to explicitly state the number of elements in
the array, and then initialize it using a string that has more
characters than there are elements in the array.  This is not a good
thing.  The larger string will _not_ override the previously specified
size of the array, and you will get a compile-time warning.  Since the
original array size remains, any part of the string that exceeds that
original size is being written to a memory location that was not
allocated for it.


File: gnu-c-manual.info,  Node: Arrays of Unions,  Next: Arrays of Structures,  Prev: Arrays as Strings,  Up: Arrays

2.5.6 Arrays of Unions
----------------------

You can create an array of a union type just as you can an array of a
primitive data type.

     union numbers
       {
         int i;
         float f;
       };
     union numbers number_array [3];

   That example creates a 3-element array of 'union numbers' variables
called 'number_array'.  You can also initialize the first members of the
elements of a number array:

     union numbers number_array [3] = { {3}, {4}, {5} };

The additional inner grouping braces are optional.

   After initialization, you can still access the union members in the
array using the member access operator.  You put the array name and
element number (enclosed in brackets) to the left of the operator, and
the member name to the right.

     union numbers number_array [3];
     number_array[0].i = 2;


File: gnu-c-manual.info,  Node: Arrays of Structures,  Prev: Arrays of Unions,  Up: Arrays

2.5.7 Arrays of Structures
--------------------------

You can create an array of a structure type just as you can an array of
a primitive data type.

     struct point
       {
         int x, y;
       };
     struct point point_array [3];

   That example creates a 3-element array of 'struct point' variables
called 'point_array'.  You can also initialize the elements of a
structure array:

     struct point point_array [3] = { {2, 3}, {4, 5}, {6, 7} };

   As with initializing structures which contain structure members, the
additional inner grouping braces are optional.  But, if you use the
additional braces, then you can partially initialize some of the
structures in the array, and fully initialize others:

     struct point point_array [3] = { {2}, {4, 5}, {6, 7} };

   In that example, the first element of the array has only its 'x'
member initialized.  Because of the grouping braces, the value 4 is
assigned to the 'x' member of the second array element, _not_ to the 'y'
member of the first element, as would be the case without the grouping
braces.

   After initialization, you can still access the structure members in
the array using the member access operator.  You put the array name and
element number (enclosed in brackets) to the left of the operator, and
the member name to the right.

     struct point point_array [3];
     point_array[0].x = 2;
     point_array[0].y = 3;


File: gnu-c-manual.info,  Node: Pointers,  Next: Incomplete Types,  Prev: Arrays,  Up: Data Types

2.6 Pointers
============

Pointers hold memory addresses of stored constants or variables.  For
any data type, including both primitive types and custom types, you can
create a pointer that holds the memory address of an instance of that
type.

* Menu:

* Declaring Pointers::
* Initializing Pointers::
* Pointers to Unions::
* Pointers to Structures::


File: gnu-c-manual.info,  Node: Declaring Pointers,  Next: Initializing Pointers,  Up: Pointers

2.6.1 Declaring Pointers
------------------------

You declare a pointer by specifying a name for it and a data type.  The
data type indicates of what type of variable the pointer will hold
memory addresses.

   To declare a pointer, include the indirection operator (*note Pointer
Operators::) before the identifier.  Here is the general form of a
pointer declaration:

     DATA-TYPE * NAME;

White space is not significant around the indirection operator:

     DATA-TYPE *NAME;
     DATA-TYPE* NAME;

   Here is an example of declaring a pointer to hold the address of an
'int' variable:

     int *ip;

   Be careful, though: when declaring multiple pointers in the same
statement, you must explicitly declare each as a pointer, using the
indirection operator:

     int *foo, *bar;  /* Two pointers. */
     int *baz, quux;   /* A pointer and an integer variable. */


File: gnu-c-manual.info,  Node: Initializing Pointers,  Next: Pointers to Unions,  Prev: Declaring Pointers,  Up: Pointers

2.6.2 Initializing Pointers
---------------------------

You can initialize a pointer when you first declare it by specifying a
variable address to store in it.  For example, the following code
declares an 'int' variable 'i', and a pointer which is initialized with
the address of 'i':

     int i;
     int *ip = &i;

   Note the use of the address operator (*note Pointer Operators::),
used to get the memory address of a variable.  After you declare a
pointer, you do _not_ use the indirection operator with the pointer's
name when assigning it a new address to point to.  On the contrary, that
would change the value of the variable that the points to, not the value
of the pointer itself.  For example:

     int i, j;
     int *ip = &i;  /* 'ip' now holds the address of 'i'. */
     ip = &j;       /* 'ip' now holds the address of 'j'. */
     *ip = &i;      /* 'j' now holds the address of 'i'. */

   The value stored in a pointer is an integral number: a location
within the computer's memory space.  If you are so inclined, you can
assign pointer values explicitly using literal integers, casting them to
the appropriate pointer type.  However, we do not recommend this
practice unless you need to have extremely fine-tuned control over what
is stored in memory, and you know exactly what you are doing.  It would
be all too easy to accidentally overwrite something that you did not
intend to.  Most uses of this technique are also non-portable.

   It is important to note that if you do not initialize a pointer with
the address of some other existing object, it points nowhere in
particular and will likely make your program crash if you use it
(formally, this kind of thing is called "undefined behavior").


File: gnu-c-manual.info,  Node: Pointers to Unions,  Next: Pointers to Structures,  Prev: Initializing Pointers,  Up: Pointers

2.6.3 Pointers to Unions
------------------------

You can create a pointer to a union type just as you can a pointer to a
primitive data type.

     union numbers
       {
         int i;
         float f;
       };
     union numbers foo = {4};
     union numbers *number_ptr = &foo;

   That example creates a new union type, 'union numbers', and declares
(and initializes the first member of) a variable of that type named
'foo'.  Finally, it declares a pointer to the type 'union numbers', and
gives it the address of 'foo'.

   You can access the members of a union variable through a pointer, but
you can't use the regular member access operator anymore.  Instead, you
have to use the indirect member access operator (*note Member Access
Expressions::).  Continuing with the previous example, the following
example will change the value of the first member of 'foo':

     number_ptr -> i = 450;

   Now the 'i' member in 'foo' is 450.


File: gnu-c-manual.info,  Node: Pointers to Structures,  Prev: Pointers to Unions,  Up: Pointers

2.6.4 Pointers to Structures
----------------------------

You can create a pointer to a structure type just as you can a pointer
to a primitive data type.

     struct fish
       {
         float length, weight;
       };
     struct fish salmon = {4.3, 5.8};
     struct fish *fish_ptr = &salmon;

   That example creates a new structure type, 'struct fish', and
declares (and initializes) a variable of that type named 'salmon'.
Finally, it declares a pointer to the type 'struct fish', and gives it
the address of 'salmon'.

   You can access the members of a structure variable through a pointer,
but you can't use the regular member access operator anymore.  Instead,
you have to use the indirect member access operator (*note Member Access
Expressions::).  Continuing with the previous example, the following
example will change the values of the members of 'salmon':

     fish_ptr -> length = 5.1;
     fish_ptr -> weight = 6.2;

   Now the 'length' and 'width' members in 'salmon' are 5.1 and 6.2,
respectively.


File: gnu-c-manual.info,  Node: Incomplete Types,  Next: Type Qualifiers,  Prev: Pointers,  Up: Data Types

2.7 Incomplete Types
====================

You can define structures, unions, and enumerations without listing
their members (or values, in the case of enumerations).  Doing so
results in an incomplete type.  You can't declare variables of
incomplete types, but you can work with pointers to those types.

     struct point;

   At some time later in your program you will want to complete the
type.  You do this by defining it as you usually would:

     struct point
       {
         int x, y;
       };

   This technique is commonly used to for linked lists:

     struct singly_linked_list
       {
         struct singly_linked_list *next;
         int x;
         /* other members here perhaps */
       };
     struct singly_linked_list *list_head;


File: gnu-c-manual.info,  Node: Type Qualifiers,  Next: Storage Class Specifiers,  Prev: Incomplete Types,  Up: Data Types

2.8 Type Qualifiers
===================

There are two type qualifiers that you can prepend to your variable
declarations which change how the variables may be accessed: 'const' and
'volatile'.

   'const' causes the variable to be read-only; after initialization,
its value may not be changed.

     const float pi = 3.14159f;

In addition to helping to prevent accidental value changes, declaring
variables with 'const' can aid the compiler in code optimization.

   'volatile' tells the compiler that the variable is explicitly
changeable, and seemingly useless accesses of the variable (for
instance, via pointers) should not be optimized away.  You might use
'volatile' variables to store data that is updated via callback
functions or signal handlers.  *note Sequence Points and Signal
Delivery::.

     volatile float currentTemperature = 40.0;


File: gnu-c-manual.info,  Node: Storage Class Specifiers,  Next: Renaming Types,  Prev: Type Qualifiers,  Up: Data Types

2.9 Storage Class Specifiers
============================

There are four storage class specifiers that you can prepend to your
variable declarations which change how the variables are stored in
memory: 'auto', 'extern', 'register', and 'static'.

   You use 'auto' for variables which are local to a function, and whose
values should be discarded upon return from the function in which they
are declared.  This is the default behavior for variables declared
within functions.

     void
     foo (int value)
     {
       auto int x = value;
       ...
       return;
     }

   'register' is nearly identical in purpose to 'auto', except that it
also suggests to the compiler that the variable will be heavily used,
and, if possible, should be stored in a register.  You cannot use the
address-of operator to obtain the address of a variable declared with
'register'.  This means that you cannot refer to the elements of an
array declared with storage class 'register'.  In fact the only thing
you can do with such an array is measure its size with 'sizeof'.  GCC
normally makes good choices about which values to hold in registers, and
so 'register' is not often used.

   'static' is essentially the opposite of 'auto': when applied to
variables within a function or block, these variables will retain their
value even when the function or block is finished.  This is known as
"static storage duration".

     int
     sum (int x)
     {
       static int sumSoFar = 0;
       sumSoFar = sumSoFar + x;
       return sumSoFar;
     }

You can also declare variables (or functions) at the top level (that is,
not inside a function) to be 'static'; such variables are visible
(global) to the current source file (but not other source files).  This
gives an unfortunate double meaning to 'static'; this second meaning is
known as "static linkage".  Two functions or variables having static
linkage in separate files are entirely separate; neither is visible
outside the file in which it is declared.

   Uninitialized variables that are declared as 'extern' are given
default values of '0', '0.0', or 'NULL', depending on the type.
Uninitialized variables that are declared as 'auto' or 'register'
(including the default usage of 'auto') are left uninitialized, and
hence should not be assumed to hold any particular value.

   'extern' is useful for declaring variables that you want to be
visible to all source files that are linked into your project.  You
cannot initialize a variable in an 'extern' declaration, as no space is
actually allocated during the declaration.  You must make both an
'extern' declaration (typically in a header file that is included by the
other source files which need to access the variable) and a non-'extern'
declaration which is where space is actually allocated to store the
variable.  The 'extern' declaration may be repeated multiple times.

     extern int numberOfClients;

     ...

     int numberOfClients = 0;

   *Note Program Structure and Scope::, for related information.


File: gnu-c-manual.info,  Node: Renaming Types,  Prev: Storage Class Specifiers,  Up: Data Types

2.10 Renaming Types
===================

Sometimes it is convenient to give a new name to a type.  You can do
this using the 'typedef' statement.  *Note The typedef Statement::, for
more information.


File: gnu-c-manual.info,  Node: Expressions and Operators,  Next: Statements,  Prev: Data Types,  Up: Top

3 Выражения и Операторы
***********************

* Menu:

* Expressions::
* Assignment Operators::
* Incrementing and Decrementing::
* Arithmetic Operators::
* Complex Conjugation::
* Comparison Operators::
* Logical Operators::
* Bit Shifting::
* Bitwise Logical Operators::
* Pointer Operators::
* The sizeof Operator::
* Type Casts::
* Array Subscripts::
* Function Calls as Expressions::
* The Comma Operator::
* Member Access Expressions::
* Conditional Expressions::
* Statements and Declarations in Expressions::
* Operator Precedence::
* Order of Evaluation::


File: gnu-c-manual.info,  Node: Expressions,  Next: Assignment Operators,  Up: Expressions and Operators

3.1 Выражения
=============

"Выражение" состоит, по меньшей мере, из одного операнда и содержит ноль
или более операторов.  Операнды - это типизированные объекты, такие как
константы, переменные и вызовы функций, которые возвращают значение.
Вот некоторые примеры:

     47
     2 + 2
     cosine(3.14159) /* Мы предполагаем, это возвращает значение с плавающей
     точкой. */

   Круглые скобки для группировки подвыражений:

     ( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )

Вложенные выражения вычисляются первыми.  В приведенном выше примере,
вначале оцениваются выражения '3 + 10' и '2 * 6', затем оцениваются
полученные выражения '13' и '12', соответственно.  Затем '12' вычитается
из '13', в результате чего получается '1'.  Наконец, '1' умножается на
'2', в результате чего появляется '2'.  Самые внешние круглые скобки в
примере не являются обязательными.

   "Оператор" определяет операцию, которая будет выполняться над его
операндом(ами).  Операторы могут иметь один, два или три операнда, в
зависимости от оператора.


File: gnu-c-manual.info,  Node: Assignment Operators,  Next: Incrementing and Decrementing,  Prev: Expressions,  Up: Expressions and Operators

3.2 Операторы Присваивания
==========================

Операторы присваивания сохраняют значения в переменных.  Си обеспечивает
несколько вариантов операторов присваивания.

   Стандартный оператор присваивания '=' просто сохранит значение
правого операнда в переменную, указанную в левом операнде.  Как и со
всеми операторами присваивания, левый операнд (обычно называемый как
"lvalue (левое значение)") не может быть буквальным или постоянным
значением.

     int x = 10;
     float y = 45.12 + 2.0;
     int z = (2 * (3 + function () ));

     struct foo {
       int bar;
       int baz;
     } quux = {3, 4};

Обратите внимание, что, в отличие от других операторов присваивания,
описанных ниже, можно использовать простой оператор присваивания для
хранения значений структурного типа.

   Составные операторы присваивания выполняют операцию с участием как
левого, так и правый операнда, затем присваивают полученное выражение
левому операнду.  Вот список составных операторов присваивания и краткое
описание того, что они делают:

   * '+='

     Складывает два операнда вместе, затем присваивает результат
     сложения левому операнду.

   * '-='

     Вычитает правый операнд из левого операнда, затем присваивает
     результат вычитания левому операнду.

   * '*='

     Перемножает два операнда, затем присваивает результат умножения
     левому операнду.

   * '/='

     Делит левый операнд на правый операнд, присваивает результат
     деления левому операнду.

   * '%='

     Выполняет деление по модулю деление двух операндов, присваивает
     результат деления левому операнду.

   * '<<='

     Выполненяет операцию сдвига влево с левым операндом, сдвигая на
     число битов, заданное с помощью правого операнда, присваивает
     результат сдвига левому операнду.

   * '>>='

     Выполняет операцию сдвига вправо с левым операндом, сдвигая на
     число битов, заданное с помощью правого операнда, и присваивает
     результат сдвига левому операнду.

   * '&='

     Выполняет поразрядную операцию 'И' для двух операндов, и
     присваивает результат операции левому операнду.

   * '^='

     Выполняет поразрядную операцию 'исключающего ИЛИ' для двух
     операндов, и присваивает результат операции левому операнду.

   * '|='

     Выполняет поразрядную операцию 'ИЛИ' для двух операндов, и
     присваивает результат операции левому операнду.

   Ниже приведен пример использования одного из составных операторов
присваивания:

     x += y;

Поскольку нет никаких влияющих побочных эффектов при оценки переменной
'x' как lvalue (левого значения), приведенный выше код дает тот же
результат, что и код:

     x = x + y;


File: gnu-c-manual.info,  Node: Incrementing and Decrementing,  Next: Arithmetic Operators,  Prev: Assignment Operators,  Up: Expressions and Operators

3.3 Увеличение и Уменьшение
===========================

Оператор инкремента '++' добавляет 1 (еденицу) к своему операнду.
Операнд должен быть либо переменной одного из примитивных типов данных,
указателем или переменной перечисления.  Можжно применить оператор
инкремента либо до, либо после операнда.  вот несколько примеров:

     char w = '1';
     int x = 5;
     char y = 'B';
     float z = 5.2;
     int *p = &x;

     ++w;   /* 'w' теперь символ '2' (не число 2). */
     x++;   /* 'x' теперь 6. */
     ++y;   /* 'y' теперь 'C' (в системах ASCII). */
     z++;   /* 'z' теперь 6.2. */
     ++p;   /* 'p' теперь '&x' + 'sizeof(int)'. */

(Обратите внимание, что увеличивающийся указатель имеет смысл только
если есть основания полагать, что новое значение указателя будет
допустимым адресом памяти.)

   Префиксное приращение, добавляет 1 к операнду перед вычислением
операнда.  Постфиксное приращение добавляет 1 после того, как операнд
вычислен.  В предыдущих примерах, изменение положения оператора не будет
иметь никакого значения.  Однако, бывают случаи, когда это имеет
значение:

     int x = 5;
     printf ("%d \n", x++); /* Распечатает 'x', а затем увеличит его. */
     /* Вывод 5, хотя переменная 'x' теперь равна 6. */
     printf ("%d \n", ++x); /* Приращение к 'x', а затем печать его. */
     /* Вывод и переменная 'x' теперь равна 7. */

Вывод приведенного выше примера:

     5
     7

   Кроме того, можно вычесть 1 из операнда с помощью оператора
декремента:

     int x = 5;

     x--; /* 'x' теперь 4. */

Понятия префикс и постфикс, применяются также и с оператором инкремента.


File: gnu-c-manual.info,  Node: Arithmetic Operators,  Next: Complex Conjugation,  Prev: Incrementing and Decrementing,  Up: Expressions and Operators

3.4 Арифметические Операторы
============================

Си обеспечивает операторы для стандартных арифметических операций:
сложения, вычитания, умножения деления, деление по модулю и отрицание.
Использование этих операторов просто; вот несколько примеров:

     /* Сложение. */
     x = 5 + 3;
     y = 10.23 + 37.332;
     quux_pointer = foo_pointer + bar_pointer;

     /* Вычитание. */
     x = 5 - 3;
     y = 57.223 - 10.903;
     quux_pointer = foo_pointer - bar_pointer;

Можно складывать и вычитать указатели памяти, но нельзя перемножать и
делить их.

     /* Умножение. */
     x = 5 * 3;
     y = 47.4 * 1.001;

     /* Деление. */
     x = 5 / 3;
     y = 940.0 / 20.2;

Целочисленное деление положительных значений обрезает по направлению к
нулю, так что 5/3 равен 1.  Однако, если один из операндов является
отрицательным, то направление округления зависит от реализации.  *note
Signed Integer Division:: для информации о переполнении в знаковом
целочисленном делении.

   Оператор деление по модулю '%' используется, чтобы получить остаток
от деления его двух операндов.  Операнды устанавливаются по обе стороны
от оператора, и имеет значение, какой операнд на какой стороне: '3 % 5'
или '5 % 3' имеют разный результат.  Операнды должны быть выражениями
примитивного типа данных.

     /* Деление по модулю. */
     x = 5 % 3;
     y = 74 % 47;

Деление по модулю возвращает остаток, полученный после выполнения
деления целых чисел двух операндов.  Операнды должны быть примитивного
целого типа.

     /* Отрицание. */
     int x = -5;
     float y = -3.14159;

   Если операнд используемый с оператором отрицания имеет беззнаковый
тип данных, то результат не станет отрицательным, а будет иметь
максимальное значение беззнакового типа данных, за вычетом значения
операнда.

   Многие системы используют в коде арифметику с дополнением до двух, и
на таких системах самое отрицательное значение, знакового типа, может
находится дальше от нуля, чем самое положительное значение.  Например,
на одной платформе, эта программа:

     #include <limits.h>
     #include <stdio.h>

     int main (int argc, char *argv[])
     {
       int x;
       x = INT_MAX;
       printf("INT_MAX  = %d\n", x);
       x = INT_MIN;
       printf("INT_MIN  = %d\n", x);
       x = -x;
       printf("-INT_MIN = %d\n", x);
       return 0;
     }

   Производит этот вывод:

     INT_MAX  = 2147483647
     INT_MIN  = -2147483648
     -INT_MIN = -2147483648

   Можно также применить положительный оператор для числового выражения:

     int x = +42;

Числовые значения считаются положительными, если явно не сделать его
отрицательным, поэтому этот оператор не оказывает никакого влияния на
работу программы.


File: gnu-c-manual.info,  Node: Complex Conjugation,  Next: Comparison Operators,  Prev: Arithmetic Operators,  Up: Expressions and Operators

3.5 Комплексное Сопряжение
==========================

В качестве расширения GNU, можно использовать оператор комплексного
сопряжения '~', выполняет комплексное сопряжение на операнде -- то есть,
он меняет знак мнимой составляющей.  Операнд должен быть выражением типа
комплесного числа.  Вот пример:

     __complex__ int x = 5 + 17i;

     printf ("%d  \n", (x * ~x));

   Так как мнимое число (a + bi) умноженное на его сопряжённое число
равное a^2 + b^2, приведенное выше выражение 'printf' выведет на
печатать число 314, которое получилось из выражения 25 + 289.


File: gnu-c-manual.info,  Node: Comparison Operators,  Next: Logical Operators,  Prev: Complex Conjugation,  Up: Expressions and Operators

3.6 Операторы Сравнения
=======================

Можно использовать операторы сравнения для определения того, как два
операнда соотносятся друг с другом: они равны друг другу, один больше,
чем другой, один меньше другого, и так далее.  При использовании любого
из операторов сравнения, результат всегда равен 1 или 0, то есть
является истинной или ложью, соответственно.

   (В следующих примерах кода, переменные 'x' and 'y' содержат любые два
выражения арифметического типа или указателя.)

   Оператор равенства '==' тестирует свои два операнда на равенство.
Результат равен 1, если операнды равны, и 0, если операнды не равны.

     if (x == y)
       puts ("x равен y");
     else
       puts ("x не равен y");

   Оператор неравенства '!=' тестирует свои два операнда на неравенство.
Результат равен 1, если операнды не равны, и 0, если операнды _являются_
равными.

     if (x != y)
       puts ("x не равен y");
     else
       puts ("x равен y");

   Сравнение значений с плавающей точкой для точного равенства или
неравенства может привести к неожиданным результатам.  *note Real Number
Types:: для получения дополнительной информации.

   Можно сравнивать указатели на функции для равенства или неравенства;
сравнение проверяет, указывают ли указатели на одну и ту же функцию или
нет.

   Помимо равенства и неравенства, есть операторы, которые можно
использовать для тестирования того, меньше, больше, меньше или равной,
больше или равно одно значение другого значения.  Вот некоторые примеры
кода, которые иллюстрируют использование этих операторов:

     if (x < y)
       puts ("x меньше y");

     if (x <= y)
       puts ("x меньше или равно y");

     if (x > y)
       puts ("x больше y");

     if (x >= y)
       puts ("x больше или равно y");


File: gnu-c-manual.info,  Node: Logical Operators,  Next: Bit Shifting,  Prev: Comparison Operators,  Up: Expressions and Operators

3.7 Логические Операторы
========================

Логические операторы проверяют значение истинности пары операндов.
Любое выражение отлично от нуля считается истинным в Си, в то время как
выражение, значение которого является ноль считается ложным.

   Логический оператор 'И' - '&&' проверяет, если два выражения истинны.
Если первое выражение ложно, то второе выражение не вычисляется.

     if ((x == 5) && (y == 10))
       printf ("x равно 5 и y равно 10");

   Логический оператор 'или' - '||' проверяет, если хотя бы одно из двух
выражений истинным.  Если первое выражение истинно, то второе выражение
не вычисляется.

     if ((x == 5) || (y == 10))
        printf ("x равно 5 или y равно 10");

   Можете предварять логическое выражение оператором отрицания 'не' -
'!', который переворачивает значение истинности:

     if (!(x == 5))
       printf ("x не равно 5");

   Так как второй операнд в паре логического выражения не обязательно
вычисляется, возможно написать код с неинтуитивными результатами:

     if (foo && x++)
       bar();

В случае когда оценка 'foo' не будет равна нулю, то не только произойдёт
вызов 'bar', но и значение 'x' будет увеличино.  Если требуется
увеличивать 'x' независимо от значения 'foo', нужно сделать приращение
за пределами выражения 'И'.


File: gnu-c-manual.info,  Node: Bit Shifting,  Next: Bitwise Logical Operators,  Prev: Logical Operators,  Up: Expressions and Operators

3.8 Битовый Сдвиг
=================

Использование оператора '<<' сдвиг влево, сдвинет биты своего первого
операнда влево.  Второй операнд обозначает количество битовых мест для
сдвига.  Биты, сдвинутые на левой стороне значения отбрасываются; новые
биты, добавленные на правой стороне все будет установлены в 0.

     x = 47;    /* 47 это 00101111 в двоичном представлении. */
     x << 1;    /* 00101111 << 1 после сдвига равно 01011110. */

   Точно так же оператор '>>' сдвига вправо, сдвинет биты своего первого
операнда вправо.  Биты смещённые с правой стороны отбрасываются; новые
биты, добавленные на левой стороне _обычно_ устанавливаются в 0, но если
первый операнд является знаковым отрицательным значением, то добавленные
биты будут либо 0 _либо_ любым другим значением, которое ранее было в
самой крайней левой позиции бита.

     x = 47;   /* 47 это 00101111 в двоичном представлении. */
     x >> 1;   /* 00101111 >> 1 после сдвига вправо теперь 00010111. */

   Для обоих операторов '<<' и '>>', если второй операнд больше битовой
ширины первого операнда или второй операнд является отрицательным,
поведение операторов не определено.

   Можно использовать операторы сдвига для выполнения множества
интересных трюков.  Например, для работы с датой - учитывая дату с днём
​​месяца пронумерованной в 'd', месяца пронцмерованного 'm', и года
пронумерованного 'y', можно хранить всю дату в одном числе 'x':

     int d = 12;
     int m = 6;
     int y = 1983;
     int x = (((y << 4) + m) << 5) + d;

Можно теперь извлечь исходный день, месяц и год из 'x', используя
комбинацию операторов сдвига и модульного деления:

     d = x % 32;
     m = (x >> 5) % 16;
     y = x >> 9;


File: gnu-c-manual.info,  Node: Bitwise Logical Operators,  Next: Pointer Operators,  Prev: Bit Shifting,  Up: Expressions and Operators

3.9 Побитовые Логические Операторы
==================================

Cи предоставляет операторы для выполнения побитового соединения 'И',
'ИЛИ', 'исключающего ИЛИ' и 'НЕ' (дополнения).

   Побитовое соединение 'И' анализирует каждый бит двух операндов, и
когда два соответствующих бита установлены в 1, результирующий бит
устанавливается в 1.  Во всех остальных случаях, результирующий бит
устанавливается в 0.  Ниже приведен пример того, как это работает,
используя двоичные числа:

     11001001 & 10011011 = 10001001

   Побитовое соединение 'ИЛИ' анализирует каждый бит в двух операндах, и
когда два соответствующих биты установлены в 0, то результирующий бит
устанавливается в 0.  Во всех остальных случаях, результирующий бит
устанавливается в 1.

     11001001 | 10011011 = 11011011

   Побитовое соединение 'исключающее ИЛИ' анализирует каждый бит в двух
операндах, и когда два соответствующих бита отличны по установленному
значению, то результирующий бит устанавливается в 1.  Во всех остальных
случаях, результирующий бит устанавливается в 0.

     11001001 ^ 10011011 = 01010010

   Побитовое соединение 'НЕ' меняет значение каждого бита в операнде на
противоположное:

     ~11001001 = 00110110

   В Cи, эти операторы можно использовать только с операндами
целочисленного типа (или символьного), а также для обеспечения
максимальной переносимости следует использовать только оператор
побитового отрицания с беззнаковыми целочисленными типами.  Вот
некоторые примеры использования этих операторов в коде Cи:

     unsigned int foo = 42;
     unsigned int bar = 57;
     unsigned int quux;

     quux = foo & bar;
     quux = foo | bar;
     quux = foo ^ bar;
     quux = ~foo;


File: gnu-c-manual.info,  Node: Pointer Operators,  Next: The sizeof Operator,  Prev: Bitwise Logical Operators,  Up: Expressions and Operators

3.10 Операторы Указателей
=========================

Можно использовать оператор взятия адреса '&' для получения адреса
памяти объекта.

     int x = 5;
     int *pointer_to_x = &x;

   Не следует использовать этот оператор, чтобы получить адрес функции,
хотя можно так:

     extern int foo (void);
     int (*fp1) (void) = foo; /* fp1 указатель на foo */
     int (*fp2) (void) = &foo; /* fp2 также указывает на foo */

   Указатели на функции и указатели на данные не совместимы, в том
смысле, что не получиться сохранить адрес функции в указателе на данные,
а затем скопировать этот указатель в указатель на функцию и вызвать
потом функцию успешно.  Это может работать на некоторых системах, но это
непереносимая техника.

   В качестве расширения GNU для C89, можно также получить адрес метки
используя оператор взятия адреса метки '&&'.  Результатом будет
указатель 'void*', который может быть использован оператором 'goto'.
*Note The goto Statement::.

   Учитывая адрес памяти, хранящийся в указателе, можно использовать
оператор косвенного обращения (разыменования) '*', чтобы получить
значение, хранящееся по адресу.  (Это называется "разыменованием"
указателя.)

     int x = 5;
     int y;
     int *ptr;

     ptr = &x;    /* 'ptr' теперь хранит адрес 'x'. */

     y = *ptr;    /* 'y' получает значение, хранящееся по адресу
                     которое сохранено в 'ptr'. */

Избегайте использование разыменования указателей, которые не были
инициализированы в известную ячейку памяти.


File: gnu-c-manual.info,  Node: The sizeof Operator,  Next: Type Casts,  Prev: Pointer Operators,  Up: Expressions and Operators

3.11 Оператор Получения Размера
===============================

Можно использовать оператор 'sizeof', чтобы получить размер (в байтах)
операнда содержащего тип данных.  Операнд может быть указан с
фактическим спецификатором типа (например, 'int' или 'float'), а также
быть любым допустимым выражением.  Когда операнд является именем типа,
он должен быть заключен в скобки.  Вот некоторые примеры:

     size_t a = sizeof(int);
     size_t b = sizeof(float);
     size_t c = sizeof(5);
     size_t d = sizeof(5.143);
     size_t e = sizeof a;

   Результат оператора 'sizeof' имеет имя типа 'size_t', которое
определено в файле заголовка '<stddef.h>'.  'size_t' является
беззнаковым целочисленным типом, может быть идентичен 'unsigned int' или
'unsigned long int', что меняется от системы к системе.

   'size_t' тип часто бывает удобным типом для индексации цикла, так как
это позволяет иметь возможность удерживать значение количества элементов
в любом массиве, что не получиться при использовании индексации например
с типом 'int'.

   Оператор 'sizeof' может использоваться для автоматического вычисления
количества элементов в массиве:

     #include <stddef.h>
     #include <stdio.h>

     static const int values[] = { 1, 2, 48, 681 };
     #define ARRAYSIZE(x) (sizeof x/sizeof x[0])

     int main (int argc, char *argv[])
     {
         size_t i;
         for (i = 0; i < ARRAYSIZE(values); i++)
         {
             printf("%d\n", values[i]);
         }
         return 0;
     }

   Есть два случая, когда этот метод не работает.  Во-первых, когда
элемент массива имеет нулевой размер (GCC поддерживает структуры
нулевого размера как расширение GNU). Во-вторых, если массив фактически
является параметром функции (*note Function Parameters::).


File: gnu-c-manual.info,  Node: Type Casts,  Next: Array Subscripts,  Prev: The sizeof Operator,  Up: Expressions and Operators

3.12 Приведение Типов
=====================

Можно использовать приведение типа, чтобы явно указать, что выражение
относится к определенному типу данных.  Такое приведение состоит из
спецификатора типа, заключенного в скобках, за которым следует
выражение.  Для обеспечения правильного приведения, нужно также
заключить выражение, которое следует за спецификатором типа в скобках.
Вот пример:

     float x;
     int y = 7;
     int z = 3;
     x = (float) (y / z);

   В этом примере, поскольку 'y' и 'z' оба являются целыми числами,
выполняется целочисленное деление, 'x' это переменная с плавающей точкой
и принимает вычисленное выражение деления - значение 2.  Здесь явное
приведение результата деления к типу 'float' не делает ничего хорошего,
потому что вычисленное значение 'y/z' уже усечено до 2.

   Чтобы устранить эту проблему, необходимо преобразовать тип одного из
операндов опрации деления в тип с плавающей точкой до выполнения
деления:

     float x;
     int y = 7;
     int z = 3;
     x = (y / (float)z);

Здесь, значение с плавающей точкой, близкое к 2.333..., присваивается
'x'.

   Приведение типа работает только со скалярными типами (то есть с
целочисленными типами, типими числа с плавающей точкой и типами
указатель).  Таким образом, это допустимо:

     struct fooTag { /* коллекция ... */ };
     struct fooTag foo;
     unsigned char byteArray[8];

     foo = (struct fooType) byteArray; /* Ошибка! */


File: gnu-c-manual.info,  Node: Array Subscripts,  Next: Function Calls as Expressions,  Prev: Type Casts,  Up: Expressions and Operators

3.13 Индексация Массива
=======================

Можно получить доступ к элементам массива, указав имя массива и индекс
массива (или индекс или номер элемента), заключенного в квадратные
скобки.  Ниже приведен пример целочисленного массива с именем
'my_array':

     my_array[0] = 5;

   Выражение индекс массива 'A[i]' определяется как идентично выражению
'(*((A)+(i)))'.  Это означает, что многие виды использования имени
массива эквивалентно выражению с указателем.  Это также означает, что
нельзя индексировать массив, имеющий класс хранения 'register'.


File: gnu-c-manual.info,  Node: Function Calls as Expressions,  Next: The Comma Operator,  Prev: Array Subscripts,  Up: Expressions and Operators

3.14 Вызовы Функций как Выражения
=================================

Вызов любой функции, которая возвращает значение, является выражением.

     int function(void);
     ...
     a = 10 + function();


File: gnu-c-manual.info,  Node: The Comma Operator,  Next: Member Access Expressions,  Prev: Function Calls as Expressions,  Up: Expressions and Operators

3.15 Оператор Запятая
=====================

Можно использовать оператор запятая ',' для разделения двух (якобы
связанных) выражений.  Например, первое выражение может задавать
значение, которое используется вторым выражением:
     x++, y = x * x;

   Чаще всего, оператор запятая используется в конструкции оператора
'for', как здесь:

     /* Использование оператора запятая в 'for' конструкции. */

     for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
       {
         ...
       }

Это позволяет удобно устанавливать, контролировать и изменять несколько
управлящих выражений конструкции 'for'.

   Запятая также используется для разделения параметров функции; Однако,
это _не_ оператор запятая в действии.  В самом деле, если оператор
запятой использовать как мы уже обсуждали здесь, в вызове функции, то
компилятор будет интерпретировать это как вызов функции с дополнительным
параметром.

   Если требуется использовать запятую в качестве аргумента функции,
нужно поставить скобки вокруг неё.  Это потому, что запятая в списке
аргументов функции имеет другой смысл: она разделяет аргументы.  Таким
образом,

     foo (x,  y=47,  x,  z);

интерпретируется как вызов функции с четырьмя аргументами, но

     foo (x,  (y=47,  x),  z);

Это вызов функции с использованием трёх аргументов.  (Второй аргумент
это - выражение '(y=47, x)'.)


File: gnu-c-manual.info,  Node: Member Access Expressions,  Next: Conditional Expressions,  Prev: The Comma Operator,  Up: Expressions and Operators

3.16 Доступ к Членам Выражения
==============================

Можно использовать оператор '.' для доступа через переменную к элементу
структуры или объединения.  Имя переменной структуры располагается с
левой стороны, а и имя члена коллекции с правой стороны оператора.

     struct point
     {
       int x, y;
     };

     struct point first_point;

     first_point.x = 0;
     first_point.y = 5;

   Также можно получить доступ через переменную к членам структуры или
объединения с помощью указателя, используя опреатор косвенного доступа к
члену структуры '->'.  Выражение 'x->y' эквивалентно выражению '(*x).y'.

     struct fish
       {
         int length, weight;
       };

     struct fish salmon;

     struct fish *fish_pointer = &salmon;

     fish_pointer->length = 3;
     fish_pointer->weight = 9;

   *Note Pointers::.


File: gnu-c-manual.info,  Node: Conditional Expressions,  Next: Statements and Declarations in Expressions,  Prev: Member Access Expressions,  Up: Expressions and Operators

3.17 Условные Выражения
=======================

Можно использовать условный оператор, чтобы выполнить оценку или его
второго операнда либо третьего, на основании значения истинности первого
операнда.  Вот пример:

     a ? b : c

   Если выражение 'a' истинно, то вычисляется выражение 'b' и
результатом всего выражения является оцененное значение выражения 'b'.
В противном случае, вычисляется выражение 'c' и результатом всего
выражения будет вычисленное значение выражения 'c'.

   Выражения 'b' and 'c' должны быть совместимыми.  То есть, они оба
должны быть

  1. арифметическими типами
  2. совместимыми структурами 'struct' или типами 'union'
  3. указателями на совместимые типы (один из которых может быть
     указателем NULL)

   В качестве альтернативы, один операнд является указателем, а другой
является указателем 'void*'.

   Вот пример

     a = (x == 5) ? y : z;

   Здесь, если 'x' равен 5, то 'a' получит значение 'y'.  В противном
случае, 'a' получит значение 'z'.  Это можно рассматривать как метод
стенографии для написания простого заявления 'if'...'else'.  Следующий
пример выполнения той же задачи, как и в предыдущем:

     if (x == 5)
         a = y;
     else
         a = z;

   Если первый операнд условного оператора является оценивается в
истину, то третий операнд никогда не оценивается.  Аналогичным образом,
если первый операнд оценен в ложь, тогда второй операнд никогда не
оценивается.  Первый операнд всегда оценивается.


File: gnu-c-manual.info,  Node: Statements and Declarations in Expressions,  Next: Operator Precedence,  Prev: Conditional Expressions,  Up: Expressions and Operators

3.18 Выражения в Объявлениях
============================

В качестве расширения GNU Cи, можо построить выражение с помощью
составного оператора, заключенного в круглых скобках.  Это позволяет
включать в выражения циклы, указатели и локальные переменные.

   Напомним, что составной оператор (также известный как блок)
представляет собой последовательность операторов заключённую в фигурные
скобки.  В этой конструкции круглые скобки заключают в себя фигурные
скобки.  Вот пример:

     ({ int y = function (); int z;
         if (y > 0) z = y;
        else z = - y;
        z; })

   Это является допустимым (хотя и несколько более сложным, чем это
необходимо) выражением для абсолютного значения функции 'function ()'.

   Последним элементом в составном операторе должно быть выражение, за
которым следует оператор точки с запятой; значение этого подвыражения
служит заключительным значением всей конструкции.  (Если используется
какой-то другой тип в качестве последнего составного оператора в
фигурных скобках, конструкция возвращает значение типа 'void', и, таким
образом, не имеет возвращаемого значения.)

   Эта функция особенно полезна для "безопасного" объявления макроса
(так что каждый операнд был оценен ровно один раз).  Например, функция
"maximum" обычно определяется как макрос в стандартном Cи следующим
образом:

     #define max(a,b) ((a) > (b) ? (a) : (b))

Но это определение вычисляет либо 'a' либо 'b' дважды, с искажёнными
зультатами, если вычисление операнда имеет побочные эффекты.  В GNU Cи,
если известен тип операндов (здесь давайте предположим 'int'), можно
определить безопасный макрос следующим образом:

     #define maxint(a,b) \
       ({int _a = (a), _b = (b); _a > _b ? _a : _b; })

   Если тип операнда не известен, можно сделать это, использовав
'typeof' для выражения или именованного типа.

   Встроенный оператор 'typeof' не допускается использовать для
константных выражений, таких как константное значение перечисления,
размер битового поля или начальное значение статической переменной.


File: gnu-c-manual.info,  Node: Operator Precedence,  Next: Order of Evaluation,  Prev: Statements and Declarations in Expressions,  Up: Expressions and Operators

3.19 Приоритет Операторов
=========================

Если выражение содержит несколько операторов, такое как 'a + b * f()',
операторы группируются на основе правил "приоритета".  Например,
действия этого выражения состоит из вызова функции 'f' без аргументов,
умножения её результата выполнения на 'b' и затем добавление к
получившемуся результату 'a'.  Вот как правила приоритета операторов Cи,
определят последовательность оценки этого выражения.

   Ниже приведен список типов выражений, представленных в порядке,
начиная с наивысшего приоритета.  Иногда два или более оператора имеют
одинаковый приоритет, тогда все эти операторы выполняются по очереди
слева направо, если не явно не задано иное.

  1. Оператор вызова функции, индексации массива и выражение доступа к
     члену структуры.

  2. Унарные операторы, в том числе логическое отрицание, побитовое
     дополнение, инкрементация, декрементация, унарный плюс, унарный
     минус, оператор косвенного обращения, оператор взятия адреса,
     приведения типов и 'sizeof' выражения.  Когда несколько унарных
     операторов указаны подряд, идущие позже, вычисляются раньше чем
     идущие впереди них: '!-x' означает '!(-x)'.

  3. Multiplication, division, and modular division expressions.

  4. Выражения сложения и вычитания.

  5. Выражения поразрядного сдвига.

  6. Выражения Большее чем, меньше чем, больше или равно чем, меньше или
     равно чем.

  7. Выражения проверки равенства и неравенства.

  8. Побитовые выражения 'AND (И)'.

  9. Побитовые выражения '^ (Исключающее ИЛИ)'.

  10. Побитовые выражения 'OR (ИЛИ)'.

  11. Логические выражения 'AND (И)'.

  12. Логические выражения 'OR (ИЛИ)'.

  13. Условные выражения (использование '?:').  При использовании в
     качестве подвыражений, они оцениваются справа налево.

  14. Все выражения присваивания, в том числе составное присваивание.
     Когда несколько операторов присваивания появляются как подвыражения
     в составе одного большого выражения, они вычисляются справа налево.

  15. Выражения оператора запятая.

   Приведенный выше перечень несколько суховат и, по-видимому прост и не
покажет скрытых некоторых подводных камней.  Возьмём такой пример:

     foo = *p++;

   Здесь 'p' увеличиваются как побочный эффект выражения, но 'foo'
принимает значение '*(p++)', а не '(*p)++', так как унарные операторы
выполняются справа налево.  Есть и другие примеры потенциальных
сюрпризов, скрывающихся за завесом приоритета вычисления операторов Cи.
По этой причине, если есть малейший риск непонимания читателем смысла
программы, нужно использовать круглые скобки, чтобы ясно задать смысл
выражения.


File: gnu-c-manual.info,  Node: Order of Evaluation,  Prev: Operator Precedence,  Up: Expressions and Operators

3.20 Порядок Вычисления
=======================

В Cи нельзя предполагать, что несколько подвыражений вычисляются в
порядке, который кажется естественным.  Например, рассмотрим выражение
'++a * f()'.  Означает ли это приращение 'a' до или после вызова функции
'f'?  Компилятор может сделать это в любом порядке, так что нельзя
сделать точное предположение.

   Это руководство объясняет абстрактную семантику языка Cи.  Однако
реальный компилятор преобразует исходный код в конкретные действия на
реальном компьютере, и может изменить порядок операций в интересах
эффективности.  Соответствие между написанным текстом программы и тем
какие действия на самом деле выполнит компьютер определяются в терминах
_побочных эффектов_ и _точек последовательности_.

* Menu:

* Side Effects::
* Sequence Points::
* Sequence Points Constrain Expressions::
* Sequence Points and Signal Delivery::


File: gnu-c-manual.info,  Node: Side Effects,  Next: Sequence Points,  Up: Order of Evaluation

3.20.1 Побочные Эффекты
-----------------------

К "побочному эффекту" относится одно из следующих действий:
  1. доступ к объекту 'volatile'
  2. изменение объекта
  3. изменение файла
  4. вызов функции, выполняющая один из указанных выше побочных эффектов

   По существу, это внешне видимые эффекты запуска программы.  Они
называются побочными эффектами, потому что они являются следствием
'оценки' выражения за пределами фактического результирующего значения
выражения.

   Компилятор может выполнять операции вашей программы в порядке,
отличающийся от порядка, вытекающего из исходного кода вашей программы,
при условии, что в конце концов отработают все необходимые побочные
эффекты.  Компилятору также позволено полностью опустить некоторые
операции; например, он может пропустить часть оценки выражения, если он
уверен, что значение не используется, и оценка этой части выражения не
будет производить никаких необходимых побочных эффектов.


File: gnu-c-manual.info,  Node: Sequence Points,  Next: Sequence Points Constrain Expressions,  Prev: Side Effects,  Up: Order of Evaluation

3.20.2 Точки Последовательности
-------------------------------

Еще одно требование к компилятору является то, что побочные эффекты
должны проявляться в правильном порядке.  Для того, чтобы обеспечить это
без чрезмерного ограничения компилятора, стандарты C89 и C90 определяют
список точек последовательности.  "Точка последовательности"
представляется одним из следующих действий:

  1. после вызова функции (после завершения оценки аргумента)
  2. после левостороннего операнда оператора 'AND (И)' '&&'
  3. после левого операнда оператора 'OR (ИЛИ)' '||'
  4. после левого операнда оператора запятая ','
  5. после первого операнда тернарного оператора 'a ? b : c'
  6. после полного объявления (1)
  7. после выражения инициализации
  8. после конструкций выражений (т.е.  выражение с последующим ';')
  9. после объявления управляющих конструкций 'if' или 'switch'
  10. после объявления управляющего выражения 'while' или 'do'
  11. после объявления любого из трех управляющих выражений 'for'
  12. после выражения оператора возврата
  13. непосредственно перед возвращением библиотечной функции
  14. после действий, связанных с элементом форматированного I/O (как
     это используется, например, с 'strftime' или 'printf' и 'scanf'
     родственных функций).
  15. непосредственно перед и после вызова функции сравнения (как это
     происходит, например, при использовании 'qsort')

   В точке последовательности, все побочные эффекты оценки предыдущих
выражений должны быть завершены, и никакие побочных эффектов последующих
оценок выражений не имеют смысла.

   Это может показаться трудным для понимания, но есть и другой способ,
чтобы рассмотреть это.  Представьте, что вы написали библиотеку
(некоторые из функции являются внешними и, возможно, другие нет) и
скомпилировал её, разрешается вызов одной из этих функций из внешнего
кода.  Определения приведённые выше гарантируют, что в момент вызова
вашей функции, данные, которые ей перадаются, имеют согласованное
значение, заданное виртуальной машиной, и любые данные, возвращаемые
вашей функцией имеют состояние, которое также будет согласовано с
виртуальной машиной.  Это включает в себя данные, доступные с помощью
указателей (т.е.  не только параметры функций и идентификаторы с внешним
связыванием).

   Вышесказанное является небольшим упрощением, поскольку существуют
компиляторы, которые выполняют оптимизацию программы в целом, уже во
время компоновки.  Важно отметить, однако, хотя они могут выполнять
оптимизации, видимые побочные эффекты программы должны быть такими же,
как если бы они были получены с помощью виртуальной машины.

   ---------- Footnotes ----------

   (1) полное объявление - это объявление функции или объекта, который
не является частью другого объекта


File: gnu-c-manual.info,  Node: Sequence Points Constrain Expressions,  Next: Sequence Points and Signal Delivery,  Prev: Sequence Points,  Up: Order of Evaluation

3.20.3 Ограничение Выражений Точками Последовательности
-------------------------------------------------------

Фрагмент кода
     i = i + 1;
   это вполне нормально, и нет сомнений в том, что происходит во многих
программах.  Тем не менее, вполне аналогичный фрагмент кода
     i = ++i + 1;
   немного сложнее понять; каково окончательное значение 'i'?  Стандарты
Cи (как C89 и C99)запрещают эту конструкцию в соответствии программ.

   Между двух точек последовательности,
  1. объект может иметь свое сохраненное значение модифицированное не
     более одного раза в ходе оценки выражения
  2. предварительное значение объекта должно быть только для чтения,
     чтобы определить значение для сохранения.

   Первый из этих двух условий запрещают выражения типа 'foo(x=2, ++x)'.
Второе условие запрещает такие выражения, как 'a[i++] = i'.

'int x=0; foo(++x, ++x)'
     Не допускается для соответствия программы, модифицировать 'x'
     дважды, прежде чем оценка аргумента завершена.
'int x=0; bar((++x,++x))'
     Позволено, функция 'bar' принимает один аргумент (в аргументе
     передано два значения), и есть точка последовательности - оператор
     запятая.
'*p++ || *p++'
     Позволено, существует точка последовательности на '||'.
'int x = 1, y = x++;'
     Позволено, существует точка последовательности после полного
     описания 'x'.
'x=2; x++;'
     Позволено, существует точка последовательности в конце первого
     оператора выражения.
'if (x++ > MAX) x = 0;'
     Позволено, существует точка последовательности в конце управляющего
     выражения 'if'(1).
'(x=y) ? ++x : x--;'
     Позволено, существует точка последовательности перед '?', и только
     один из двух следующих выражений оцениваются.
'int *p=malloc(sizeof(*p)), *q=p; *p=foo(); bar((*p)++,(*q)++);'
     Не допустимо, объект в 'p' модифицируется дважды, прежде чем оценка
     аргументов 'bar' завершена.  Тот факт, что это делается один раз
     через 'p' и один раз через 'q' не имеет никакого значения, так как
     они указывают на один и тот же объект.

   Вернемся к примеру, мы использовали, чтобы представить проблему
порядка оценки, '++a * f()'.  Предположим, что код на самом деле
выглядит следующим образом:

     static int a = 1;

     static int f (void)
     {
       a = 100;
       return 3;
     }

     int foo (void)
     {
        return ++a * f();
     }

   Разрешён ли этот код в соответствии стандартам программы?  Хотя
выражение в 'foo' модифицирует 'a' дважды, это не проблема.  Давайте
посмотрим на два возможных случаях.

Правый операнд 'f()' оценивается первым. Поскольку 'f'
     возвращает значение, отличное от void (неопределенно), выражение
     должно содержать 'return' объявление.  Таким образом, существует
     точка последовательности в конце выражения возврата.  Это
     происходит между модификацией 'a', при работе 'f' и оценки левого
     операнда.
Левый операнд '++a' вычисляется первым. Во-первых, 'a'
     увеличивается.  Затем вычисляются аргументы 'f' (их нет).  Затем
     существует точка последовательности перед фактическим вызовом 'f'.

   Итак, мы видим, что наша программа соответствует стандарту.  Обратите
внимание, что приведенное выше рассуждение фактически не зависит от
деталей тела функции 'f'.  Это зависит только от того, что функция
содержит что-то, что заканчивающееся точкой последовательности - в нашем
примере это оператор возврата, но оператор выражения или полное описание
также подойдёт.

   Тем не менее, результат выполнения этого кода зависит от порядка
вычисления операндов '*'.  Если левый операнд вычисляется первым, 'foo'
возвращает 6.  В противном случае она возвращает 303.  Стандарт Cи не
определяет, в каком порядке операнды должны быть оценены, а также не
требует реализации документирования порядка и не требует придерживаться
такого порядка.  Эффект этого кода "не определённ", а это означает, что
может произойти одно из нескольких конкретных вещей, но стандарты Cи не
определяют что именно произойдёт в этом случае.

   ---------- Footnotes ----------

   (1) Однако, если, например 'MAX' является 'INT_MAX' и 'x' имеет тип
'int', мы явно имеем проблему с переполнением.  *Note Overflow::.


File: gnu-c-manual.info,  Node: Sequence Points and Signal Delivery,  Prev: Sequence Points Constrain Expressions,  Up: Order of Evaluation

3.20.4 Точки Последовательности и Доставка Сигналов
---------------------------------------------------

Сигналы в основном описаны в руководстве GNU C Library, а не в этом
документе, несмотря на это, стандарты Cи рассматривают компилятор и
библиотеку Cи вместе как "реализацию".

   Когда сигнал получен, это будет происходить между точками
последовательности.  Побочные эффекты на 'volatile' объектов до
предыдущей точки последовательности будет учтены, но другие обновления,
возможно, ещё не произошли.  Это относится даже к прямым присвоениям,
таким как 'x=0;', так как код, сгенерированный для этого заявления может
потребовать более одной команды, а это означает, что его отработка может
быть прервана на полпути его выполнения, путем доставки сигнала.

   Стандарт Си весьма ограничивает с доступом к данным внутри
обработчика сигнала.  Они могут использовать 'auto' переменные, но с
точки зрения чтения или записи других объектов, они должны быть
'volatile sig_atomic_t'.  В 'volatile' типе гарантируется, что доступ к
переменной в других частях программы не охватывает точки
последовательности и использование 'sig_atomic_t' типа обеспечивает
поведение, при котором изменения в переменной являются атомарными
относительно доставки сигнала.

   Стандарт POSIX также позволяет небольшое количество библиотечных
функций для вызова из обработчика сигнала.  Эти функции называются
набором функций "безопасных-фссинхронных-сигналовa".  Если ваша
программа предназначена для запуска на системе POSIX, но не в других
системах, вы можете смело вызывать их из обработчика сигнала тоже.


File: gnu-c-manual.info,  Node: Statements,  Next: Functions,  Prev: Expressions and Operators,  Up: Top

4 Statements
************

You write statements to cause actions and to control flow within your
programs.  You can also write statements that do not do anything at all,
or do things that are uselessly trivial.

* Menu:

* Labels::
* Expression Statements::
* The if Statement::
* The switch Statement::
* The while Statement::
* The do Statement::
* The for Statement::
* Blocks::
* The Null Statement::
* The goto Statement::
* The break Statement::
* The continue Statement::
* The return Statement::
* The typedef Statement::


File: gnu-c-manual.info,  Node: Labels,  Next: Expression Statements,  Up: Statements

4.1 Labels
==========

You can use labels to identify a section of source code for use with a
later 'goto' (*note The goto Statement::).  A label consists of an
identifier (such as those used for variable names) followed by a colon.
Here is an example:

     treet:

   You should be aware that label names do not interfere with other
identifier names:

     int treet = 5;    /* 'treet' the variable. */
     treet:            /* 'treet' the label. */

   The ISO C standard mandates that a label must be followed by at least
one statement, possibly a null statement (*note The Null Statement::).
GCC will compile code that does not meet this requirement, but be aware
that if you violate it, your code may have portability issues.


File: gnu-c-manual.info,  Node: Expression Statements,  Next: The if Statement,  Prev: Labels,  Up: Statements

4.2 Expression Statements
=========================

You can turn any expression into a statement by adding a semicolon to
the end of the expression.  Here are some examples:

     5;
     2 + 2;
     10 >= 9;

   In each of those, all that happens is that each expression is
evaluated.  However, they are useless because they do not store a value
anywhere, nor do they actually do anything, other than the evaluation
itself.  The compiler is free to ignore such statements.

   Expression statements are only useful when they have some kind of
side effect, such as storing a value, calling a function, or (this is
esoteric) causing a fault in the program.  Here are some more useful
examples:

     x++;
     y = x + 25;
     puts ("Hello, user!");
     *cucumber;

   The last of those statements, '*cucumber;', could potentially cause a
fault in the program if the value of 'cucumber' is both not a valid
pointer and has been declared as 'volatile'.


File: gnu-c-manual.info,  Node: The if Statement,  Next: The switch Statement,  Prev: Expression Statements,  Up: Statements

4.3 The 'if' Statement
======================

You can use the 'if' statement to conditionally execute part of your
program, based on the truth value of a given expression.  Here is the
general form of an 'if' statement:

     if (TEST)
       THEN-STATEMENT
     else
       ELSE-STATEMENT

   If TEST evaluates to true, then THEN-STATEMENT is executed and
ELSE-STATEMENT is not.  If TEST evaluates to false, then ELSE-STATEMENT
is executed and THEN-STATEMENT is not.  The 'else' clause is optional.

   Here is an actual example:

     if (x == 10)
       puts ("x is 10");

   If 'x == 10' evaluates to true, then the statement 'puts ("x is
10");' is executed.  If 'x == 10' evaluates to false, then the statement
'puts ("x is 10");' is not executed.

   Here is an example using 'else':

     if (x == 10)
       puts ("x is 10");
     else
       puts ("x is not 10");

   You can use a series of 'if' statements to test for multiple
conditions:

     if (x == 1)
       puts ("x is 1");
     else if (x == 2)
       puts ("x is 2");
     else if (x == 3)
       puts ("x is 3");
     else
       puts ("x is something else");

   This function calculates and displays the date of Easter for the
given year 'y':

     void
     easterDate (int y)
     {
       int n = 0;
       int g = (y % 19) + 1;
       int c = (y / 100) + 1;
       int x = ((3 * c) / 4) - 12;
       int z = (((8 * c) + 5) / 25) - 5;
       int d = ((5 * y) / 4) - x - 10;
       int e = ((11 * g) + 20 + z - x) % 30;

       if (((e == 25) && (g > 11)) || (e == 24))
         e++;

       n = 44 - e;

       if (n < 21)
         n += 30;

       n = n + 7 - ((d + n) % 7);

       if (n > 31)
         printf ("Easter: %d April %d", n - 31, y);
       else
         printf ("Easter: %d March %d", n, y);
     }


File: gnu-c-manual.info,  Node: The switch Statement,  Next: The while Statement,  Prev: The if Statement,  Up: Statements

4.4 The 'switch' Statement
==========================

You can use the 'switch' statement to compare one expression with
others, and then execute a series of sub-statements based on the result
of the comparisons.  Here is the general form of a 'switch' statement:

     switch (TEST)
       {
         case COMPARE-1:
           IF-EQUAL-STATEMENT-1
         case COMPARE-2:
           IF-EQUAL-STATEMENT-2
         ...
         default:
           DEFAULT-STATEMENT
       }

   The 'switch' statement compares TEST to each of the COMPARE
expressions, until it finds one that is equal to TEST.  Then, the
statements following the successful case are executed.  All of the
expressions compared must be of an integer type, and the COMPARE-N
expressions must be of a constant integer type (e.g., a literal integer
or an expression built of literal integers).

   Optionally, you can specify a default case.  If TEST doesn't match
any of the specific cases listed prior to the default case, then the
statements for the default case are executed.  Traditionally, the
default case is put after the specific cases, but that isn't required.

     switch (x)
       {
         case 0:
           puts ("x is 0");
           break;
         case 1:
           puts ("x is 1");
           break;
         default:
           puts ("x is something else");
           break;
       }

   Notice the usage of the 'break' statement in each of the cases.  This
is because, once a matching case is found, not only are its statements
executed, but so are the statements for all following cases:

     int x = 0;
     switch (x)
       {
         case 0:
           puts ("x is 0");
         case 1:
           puts ("x is 1");
         default:
           puts ("x is something else");
       }

The output of that example is:

     x is 0
     x is 1
     x is something else

   This is often not desired.  Including a 'break' statement at the end
of each case redirects program flow to after the 'switch' statement.

   As a GNU C extension, you can also specify a range of consecutive
integer values in a single 'case' label, like this:

     case LOW ... HIGH:

This has the same effect as the corresponding number of individual
'case' labels, one for each integer value from LOW to HIGH, inclusive.

   This feature is especially useful for ranges of ASCII character
codes:

     case 'A' ... 'Z':

   Be careful to include spaces around the '...'; otherwise it may be
parsed incorrectly when you use it with integer values.  For example,
write this:

     case 1 ... 5:

instead of this:

     case 1...5:

   It is common to use a 'switch' statement to handle various possible
values of 'errno'.  In this case a portable program should watch out for
the possibility that two macros for 'errno' values in fact have the same
value, for example 'EWOULDBLOCK' and 'EAGAIN'.


File: gnu-c-manual.info,  Node: The while Statement,  Next: The do Statement,  Prev: The switch Statement,  Up: Statements

4.5 The 'while' Statement
=========================

The 'while' statement is a loop statement with an exit test at the
beginning of the loop.  Here is the general form of the 'while'
statement:

     while (TEST)
       STATEMENT

   The 'while' statement first evaluates TEST.  If TEST evaluates to
true, STATEMENT is executed, and then TEST is evaluated again.
STATEMENT continues to execute repeatedly as long as TEST is true after
each execution of STATEMENT.

   This example prints the integers from zero through nine:

     int counter = 0;
     while (counter < 10)
       printf ("%d ", counter++);

   A 'break' statement can also cause a 'while' loop to exit.


File: gnu-c-manual.info,  Node: The do Statement,  Next: The for Statement,  Prev: The while Statement,  Up: Statements

4.6 The 'do' Statement
======================

The 'do' statement is a loop statement with an exit test at the end of
the loop.  Here is the general form of the 'do' statement:

     do
       STATEMENT
     while (TEST);

   The 'do' statement first executes STATEMENT.  After that, it
evaluates TEST.  If TEST is true, then STATEMENT is executed again.
STATEMENT continues to execute repeatedly as long as TEST is true after
each execution of STATEMENT.

   This example also prints the integers from zero through nine:

     int x = 0;
     do
       printf ("%d ", x++);
     while (x < 10);

   A 'break' statement can also cause a 'do' loop to exit.


File: gnu-c-manual.info,  Node: The for Statement,  Next: Blocks,  Prev: The do Statement,  Up: Statements

4.7 The 'for' Statement
=======================

The 'for' statement is a loop statement whose structure allows easy
variable initialization, expression testing, and variable modification.
It is very convenient for making counter-controlled loops.  Here is the
general form of the 'for' statement:

     for (INITIALIZE; TEST; STEP)
       STATEMENT

   The 'for' statement first evaluates the expression INITIALIZE.  Then
it evaluates the expression TEST.  If TEST is false, then the loop ends
and program control resumes after STATEMENT.  Otherwise, if TEST is
true, then STATEMENT is executed.  Finally, STEP is evaluated, and the
next iteration of the loop begins with evaluating TEST again.

   Most often, INITIALIZE assigns values to one or more variables, which
are generally used as counters, TEST compares those variables to a
predefined expression, and STEP modifies those variables' values.  Here
is another example that prints the integers from zero through nine:

     int x;
     for (x = 0; x < 10; x++)
       printf ("%d ", x);

   First, it evaluates INITIALIZE, which assigns 'x' the value 0.  Then,
as long as 'x' is less than 10, the value of 'x' is printed (in the body
of the loop).  Then 'x' is incremented in the STEP clause and the test
re-evaluated.

   All three of the expressions in a 'for' statement are optional, and
any combination of the three is valid.  Since the first expression is
evaluated only once, it is perhaps the most commonly omitted expression.
You could also write the above example as:

     int x = 1;
     for (; x <= 10; x++)
       printf ("%d ", x);

In this example, 'x' receives its value prior to the beginning of the
'for' statement.

   If you leave out the TEST expression, then the 'for' statement is an
infinite loop (unless you put a 'break' or 'goto' statement somewhere in
STATEMENT).  This is like using '1' as TEST; it is never false.

   This 'for' statement starts printing numbers at 1 and then continues
indefinitely, always printing 'x' incremented by 1:

     for (x = 1; ; x++)
       printf ("%d ", x);

   If you leave out the STEP expression, then no progress is made toward
completing the loop--at least not as is normally expected with a 'for'
statement.

   This example prints the number 1 over and over, indefinitely:

     for (x = 1; x <= 10;)
       printf ("%d ", x);

   Perhaps confusingly, you cannot use the comma operator (*note The
Comma Operator::) for monitoring multiple variables in a 'for'
statement, because as usual the comma operator discards the result of
its left operand.  This loop:

     int x, y;
     for (x = 1, y = 10; x <= 10, y >= 1; x+=2, y--)
       printf ("%d %d\n", x, y);

Outputs:

     1 10
     3 9
     5 8
     7 7
     9 6
     11 5
     13 4
     15 3
     17 2
     19 1

   If you need to test two conditions, you will need to use the '&&'
operator:

     int x, y;
     for (x = 1, y = 10; x <= 10 && y >= 1; x+=2, y--)
       printf ("%d %d\n", x, y);

   A 'break' statement can also cause a 'for' loop to exit.

   Here is an example of a function that computes the summation of
squares, given a starting integer to square and an ending integer to
square:

     int
     sum_of_squares (int start, int end)
     {
       int i, sum = 0;
       for (i = start; i <= end; i++)
         sum += i * i;
       return sum;
     }


File: gnu-c-manual.info,  Node: Blocks,  Next: The Null Statement,  Prev: The for Statement,  Up: Statements

4.8 Blocks
==========

A "block" is a set of zero or more statements enclosed in braces.
Blocks are also known as "compound statements".  Often, a block is used
as the body of an 'if' statement or a loop statement, to group
statements together.

     for (x = 1; x <= 10; x++)
       {
         printf ("x is %d\n", x);

         if ((x % 2) == 0)
           printf ("%d is even\n", x);
         else
           printf ("%d is odd\n", x);
       }

   You can also put blocks inside other blocks:

     for (x = 1; x <= 10; x++)
       {
         if ((x % 2) == 0)
           {
             printf ("x is %d\n", x);
             printf ("%d is even\n", x);
           }
         else
           {
             printf ("x is %d\n", x);
             printf ("%d is odd\n", x);
           }
       }

   You can declare variables inside a block; such variables are local to
that block.  In C89, declarations must occur before other statements,
and so sometimes it is useful to introduce a block simply for this
purpose:

     {
       int x = 5;
       printf ("%d\n", x);
     }
     printf ("%d\n", x);   /* Compilation error! 'x' exists only
                            in the preceding block. */


File: gnu-c-manual.info,  Node: The Null Statement,  Next: The goto Statement,  Prev: Blocks,  Up: Statements

4.9 The Null Statement
======================

The "null statement" is merely a semicolon alone.

     ;

   A null statement does not do anything.  It does not store a value
anywhere.  It does not cause time to pass during the execution of your
program.

   Most often, a null statement is used as the body of a loop statement,
or as one or more of the expressions in a 'for' statement.  Here is an
example of a 'for' statement that uses the null statement as the body of
the loop (and also calculates the integer square root of 'n', just for
fun):

     for (i = 1; i*i < n; i++)
       ;

   Here is another example that uses the null statement as the body of a
'for' loop and also produces output:

     for (x = 1; x <= 5; printf ("x is now %d\n", x), x++)
       ;

   A null statement is also sometimes used to follow a label that would
otherwise be the last thing in a block.


File: gnu-c-manual.info,  Node: The goto Statement,  Next: The break Statement,  Prev: The Null Statement,  Up: Statements

4.10 The 'goto' Statement
=========================

You can use the 'goto' statement to unconditionally jump to a different
place in the program.  Here is the general form of a 'goto' statement:

     goto LABEL;

   You have to specify a label to jump to; when the 'goto' statement is
executed, program control jumps to that label.  *Note Labels::.  Here is
an example:

     goto end_of_program;
     ...
     end_of_program:

   The label can be anywhere in the same function as the 'goto'
statement that jumps to it, but a 'goto' statement cannot jump to a
label in a different function.

   You _can_ use 'goto' statements to simulate loop statements, but we
do not recommend it--it makes the program harder to read, and GCC cannot
optimize it as well.  You should use 'for', 'while', and 'do' statements
instead of 'goto' statements, when possible.

   As an extension, GCC allows a goto statement to jump to an address
specified by a 'void*' variable.  To make this work, you also need to
take the address of a label by using the unary operator '&&' (not '&').
Here is a contrived example:

     enum Play { ROCK=0, PAPER=1, SCISSORS=2 };
     enum Result { WIN, LOSE, DRAW };

     static enum Result turn (void)
     {
       const void * const jumptable[] = {&&rock, &&paper, &&scissors};
       enum Play opp;                /* opponent's play */
       goto *jumptable[select_option (&opp)];
      rock:
       return opp == ROCK ? DRAW : (opp == PAPER ? LOSE : WIN);
      paper:
       return opp == ROCK ? WIN  : (opp == PAPER ? DRAW : LOSE);
      scissors:
       return opp == ROCK ? LOSE : (opp == PAPER ? WIN  : DRAW);
     }


File: gnu-c-manual.info,  Node: The break Statement,  Next: The continue Statement,  Prev: The goto Statement,  Up: Statements

4.11 The 'break' Statement
==========================

You can use the 'break' statement to terminate a 'while', 'do', 'for',
or 'switch' statement.  Here is an example:

     int x;
     for (x = 1; x <= 10; x++)
       {
         if (x == 8)
           break;
         else
           printf ("%d ", x);
       }

   That example prints numbers from 1 to 7.  When 'x' is incremented to
8, 'x == 8' is true, so the 'break' statement is executed, terminating
the 'for' loop prematurely.

   If you put a 'break' statement inside of a loop or 'switch' statement
which itself is inside of a loop or 'switch' statement, the 'break' only
terminates the innermost loop or 'switch' statement.


File: gnu-c-manual.info,  Node: The continue Statement,  Next: The return Statement,  Prev: The break Statement,  Up: Statements

4.12 The 'continue' Statement
=============================

You can use the 'continue' statement in loops to terminate an iteration
of the loop and begin the next iteration.  Here is an example:

     for (x = 0; x < 100; x++)
       {
         if (x % 2 == 0)
           continue;
         else
           sum_of_odd_numbers + = x;
       }

   If you put a 'continue' statement inside a loop which itself is
inside a loop, then it affects only the innermost loop.


File: gnu-c-manual.info,  Node: The return Statement,  Next: The typedef Statement,  Prev: The continue Statement,  Up: Statements

4.13 The 'return' Statement
===========================

You can use the 'return' statement to end the execution of a function
and return program control to the function that called it.  Here is the
general form of the 'return' statement:

     return RETURN-VALUE;

   RETURN-VALUE is an optional expression to return.  If the function's
return type is 'void', then it is invalid to return an expression.  You
can, however, use the 'return' statement without a return value.

   If the function's return type is not the same as the type of
RETURN-VALUE, and automatic type conversion cannot be performed, then
returning RETURN-VALUE is invalid.

   If the function's return type is not 'void' and no return value is
specified, then the 'return' statement is valid unless the function is
called in a context that requires a return value.  For example:

     x = cosine (y);

   In that case, the function 'cosine' was called in a context that
required a return value, so the value could be assigned to 'x'.

   Even in contexts where a return value is not required, it is a bad
idea for a non-'void' function to omit the return value.  With GCC, you
can use the command line option '-Wreturn-type' to issue a warning if
you omit the return value in such functions.

   Here are some examples of using the 'return' statement, in both a
'void' and non-'void' function:

     void
     print_plus_five (int x)
     {
       printf ("%d ", x + 5);
       return;
     }

     int
     square_value (int x)
     {
       return x * x;
     }


File: gnu-c-manual.info,  Node: The typedef Statement,  Prev: The return Statement,  Up: Statements

4.14 The 'typedef' Statement
============================

You can use the 'typedef' statement to create new names for data types.
Here is the general form of the 'typedef' statement:

     typedef OLD-TYPE-NAME NEW-TYPE-NAME

   OLD-TYPE-NAME is the existing name for the type, and may consist of
more than one token (e.g., 'unsigned long int').  NEW-TYPE-NAME is the
resulting new name for the type, and must be a single identifier.
Creating this new name for the type does not cause the old name to cease
to exist.  Here are some examples:

     typedef unsigned char byte_type;
     typedef double real_number_type;

In the case of custom data types, you can use 'typedef' to make a new
name for the type while defining the type:

     typedef struct fish
     {
       float weight;
       float length;
       float probability_of_being_caught;
     } fish_type;

To make a type definition of an array, you first provide the type of the
element, and then establish the number of elements at the end of the
type definition:

     typedef char array_of_bytes [5];
     array_of_bytes five_bytes = {0, 1, 2, 3, 4};

   When selecting names for types, you should avoid ending your type
names with a '_t' suffix.  The compiler will allow you to do this, but
the POSIX standard reserves use of the '_t' suffix for standard library
type names.


File: gnu-c-manual.info,  Node: Functions,  Next: Program Structure and Scope,  Prev: Statements,  Up: Top

5 Functions
***********

You can write functions to separate parts of your program into distinct
subprocedures.  To write a function, you must at least create a function
definition.  It is a good idea also to have an explicit function
declaration; you don't have to, but if you leave it out, then the
default implicit declaration might not match the function itself, and
you will get some compile-time warnings.

   Every program requires at least one function, called 'main'.  That is
where the program's execution begins.

* Menu:

* Function Declarations::
* Function Definitions::
* Calling Functions::
* Function Parameters::
* Variable Length Parameter Lists::
* Calling Functions Through Function Pointers::
* The main Function::
* Recursive Functions::
* Static Functions::
* Nested Functions::


File: gnu-c-manual.info,  Node: Function Declarations,  Next: Function Definitions,  Up: Functions

5.1 Function Declarations
=========================

You write a function declaration to specify the name of a function, a
list of parameters, and the function's return type.  A function
declaration ends with a semicolon.  Here is the general form:

     RETURN-TYPE FUNCTION-NAME (PARAMETER-LIST);

   RETURN-TYPE indicates the data type of the value returned by the
function.  You can declare a function that doesn't return anything by
using the return type 'void'.

   FUNCTION-NAME can be any valid identifier (*note Identifiers::).

   PARAMETER-LIST consists of zero or more parameters, separated by
commas.  A typical parameter consists of a data type and an optional
name for the parameter.  You can also declare a function that has a
variable number of parameters (*note Variable Length Parameter Lists::),
or no parameters using 'void'.  Leaving out PARAMETER-LIST entirely also
indicates no parameters, but it is better to specify it explicitly with
'void'.

   Here is an example of a function declaration with two parameters:

     int foo (int, double);

   If you include a name for a parameter, the name immediately follows
the data type, like this:

     int foo (int x, double y);

   The parameter names can be any identifier (*note Identifiers::), and
if you have more than one parameter, you can't use the same name more
than once within a single declaration.  The parameter names in the
declaration need not match the names in the definition.

   You should write the function declaration above the first use of the
function.  You can put it in a header file and use the '#include'
directive to include that function declaration in any source code files
that use the function.


File: gnu-c-manual.info,  Node: Function Definitions,  Next: Calling Functions,  Prev: Function Declarations,  Up: Functions

5.2 Function Definitions
========================

You write a function definition to specify what a function actually
does.  A function definition consists of information regarding the
function's name, return type, and types and names of parameters, along
with the body of the function.  The function body is a series of
statements enclosed in braces; in fact it is simply a block (*note
Blocks::).

   Here is the general form of a function definition:

     RETURN-TYPE
     FUNCTION-NAME (PARAMETER-LIST)
     {
       FUNCTION-BODY
     }

   RETURN-TYPE and FUNCTION-NAME are the same as what you use in the
function declaration (*note Function Declarations::).

   PARAMETER-LIST is the same as the parameter list used in the function
declaration (*note Function Declarations::), except you _must_ include
names for the parameters in a function definition.

   Here is an simple example of a function definition--it takes two
integers as its parameters and returns the sum of them as its return
value:

     int
     add_values (int x, int y)
     {
       return x + y;
     }

   For compatibility with the original design of C, you can also specify
the type of the function parameters _after_ the closing parenthesis of
the parameter list, like this:

     int
     add_values (x, y)
         int x, int y;
     {
       return x + y;
     }

However, we strongly discourage this style of coding; it can cause
subtle problems with type casting, among other problems.


File: gnu-c-manual.info,  Node: Calling Functions,  Next: Function Parameters,  Prev: Function Definitions,  Up: Functions

5.3 Calling Functions
=====================

You can call a function by using its name and supplying any needed
parameters.  Here is the general form of a function call:

     FUNCTION-NAME (PARAMETERS)

   A function call can make up an entire statement, or it can be used as
a subexpression.  Here is an example of a standalone function call:

     foo (5);

In that example, the function 'foo' is called with the parameter '5'.

   Here is an example of a function call used as a subexpression:

     a = square (5);

Supposing that the function 'square' squares its parameter, the above
example assigns the value 25 to 'a'.

   If a parameter takes more than one argument, you separate parameters
with commas:

     a = quux (5, 10);


File: gnu-c-manual.info,  Node: Function Parameters,  Next: Variable Length Parameter Lists,  Prev: Calling Functions,  Up: Functions

5.4 Function Parameters
=======================

Function parameters can be any expression--a literal value, a value
stored in variable, an address in memory, or a more complex expression
built by combining these.

   Within the function body, the parameter is a local copy of the value
passed into the function; you cannot change the value passed in by
changing the local copy.

     int x = 23;
     foo (x);
     ...
     /* Definition for function 'foo'. */
     int foo (int a)
     {
       a = 2 * a;
       return a;
     }

In that example, even though the parameter 'a' is modified in the
function 'foo', the variable 'x' that is passed to the function does not
change.  If you wish to use the function to change the original value of
'x', then you would have to incorporate the function call into an
assignment statement:

     x = foo (x);

   If the value that you pass to a function is a memory address (that
is, a pointer), then you can access (and change) the data stored at the
memory address.  This achieves an effect similar to pass-by-reference in
other languages, but is not the same: the memory address is simply a
value, just like any other value, and cannot itself be changed.  The
difference between passing a pointer and passing an integer lies in what
you can do using the value within the function.

   Here is an example of calling a function with a pointer parameter:

     void
     foo (int *x)
     {
       *x = *x + 42;
     }
     ...
     int a = 15;
     foo (&a);

The formal parameter for the function is of type pointer-to-'int', and
we call the function by passing it the address of a variable of type
'int'.  By dereferencing the pointer within the function body, we can
both see and change the value stored in the address.  The above changes
the value of 'a' to '57'.

   Even if you don't want to change the value stored in the address,
passing the address of a variable rather than the variable itself can be
useful if the variable type is large and you need to conserve memory
space or limit the performance impact of parameter copying.  For
example:

     struct foo
     {
       int x;
       float y;
       double z;
     };

     void bar (const struct foo *a);

In this case, unless you are working on a computer with very large
memory addresses, it will take less memory to pass a pointer to the
structure than to pass an instance of the structure.

   One type of parameter that is always passed as a pointer is any sort
of array:

     void foo (int a[]);
     ...
     int x[100];
     foo (x);

In this example, calling the function 'foo' with the parameter 'a' does
not copy the entire array into a new local parameter within 'foo';
rather, it passes 'x' as a pointer to the first element in 'x'.  Be
careful, though: within the function, you cannot use 'sizeof' to
determine the size of the array 'x'--'sizeof' instead tells you the size
of the pointer 'x'.  Indeed, the above code is equivalent to:

     void foo (int *a);
     ...
     int x[100];
     foo (x);

Explicitly specifying the length of the array in the parameter
declaration will not help.  If you really need to pass an array by
value, you can wrap it in a 'struct', though doing this will rarely be
useful (passing a 'const'-qualified pointer is normally sufficient to
indicate that the caller should not modify the array).


File: gnu-c-manual.info,  Node: Variable Length Parameter Lists,  Next: Calling Functions Through Function Pointers,  Prev: Function Parameters,  Up: Functions

5.5 Variable Length Parameter Lists
===================================

You can write a function that takes a variable number of arguments;
these are called "variadic functions".  To do this, the function needs
to have at least one parameter of a known data type, but the remaining
parameters are optional, and can vary in both quantity and data type.

   You list the initial parameters as normal, but then after that, use
an ellipsis: '...'.  Here is an example function prototype:

     int add_multiple_values (int number, ...);

   To work with the optional parameters in the function definition, you
need to use macros that are defined in the library header file
'<stdarg.h>', so you must '#include' that file.  For a detailed
description of these macros, see 'The GNU C Library' manual's section on
variadic functions.

   Here is an example:

     int
     add_multiple_values (int number, ...)
     {
       int counter, total = 0;

       /* Declare a variable of type 'va_list'. */
       va_list parameters;

       /* Call the 'va_start' function. */
       va_start (parameters, number);

       for (counter = 0; counter < number; counter++)
         {
           /* Get the values of the optional parameters. */
           total += va_arg (parameters, int);
         }

       /* End use of the 'parameters' variable. */
       va_end (parameters);

       return total;
     }

   To use optional parameters, you need to have a way to know how many
there are.  This can vary, so it can't be hard-coded, but if you don't
know how many optional parameters you have, then you could have
difficulty knowing when to stop using the 'va_arg' function.  In the
above example, the first parameter to the 'add_multiple_values'
function, 'number', is the number of optional parameters actually
passed.  So, we might call the function like this:

     sum = add_multiple_values (3, 12, 34, 190);

   The first parameter indicates how many optional parameters follow it.

   Also, note that you don't actually need to use 'va_end' function.  In
fact, with GCC it doesn't do anything at all.  However, you might want
to include it to maximize compatibility with other compilers.

   *Note Variadic Functions: (libc)Variadic Functions.


File: gnu-c-manual.info,  Node: Calling Functions Through Function Pointers,  Next: The main Function,  Prev: Variable Length Parameter Lists,  Up: Functions

5.6 Calling Functions Through Function Pointers
===============================================

You can also call a function identified by a pointer.  The indirection
operator '*' is optional when doing this.

     #include <stdio.h>

     void foo (int i)
     {
       printf ("foo %d!\n", i);
     }

     void bar (int i)
     {
       printf ("%d bar!\n", i);
     }

     void message (void (*func)(int), int times)
     {
       int j;
       for (j=0; j<times; ++j)
         func (j);  /* (*func) (j); would be equivalent. */
     }

     void example (int want_foo)
     {
       void (*pf)(int) = &bar; /* The & is optional. */
       if (want_foo)
         pf = foo;
       message (pf, 5);
     }


File: gnu-c-manual.info,  Node: The main Function,  Next: Recursive Functions,  Prev: Calling Functions Through Function Pointers,  Up: Functions

5.7 The 'main' Function
=======================

Every program requires at least one function, called 'main'.  This is
where the program begins executing.  You do not need to write a
declaration or prototype for 'main', but you do need to define it.

   The return type for 'main' is always 'int'.  You do not have to
specify the return type for 'main', but you can.  However, you _cannot_
specify that it has a return type other than 'int'.

   In general, the return value from 'main' indicates the program's
"exit status".  A value of zero or EXIT_SUCCESS indicates success and
EXIT_FAILURE indicates an error.  Otherwise, the significance of the
value returned is implementation-defined.

   Reaching the '}' at the end of 'main' without a return, or executing
a 'return' statement with no value (that is, 'return;') are both
equivalent.  In C89, the effect of this is undefined, but in C99 the
effect is equivalent to 'return 0;'.

   You can write your 'main' function to have no parameters (that is, as
'int main (void)'), or to accept parameters from the command line.  Here
is a very simple 'main' function with no parameters:

     int
     main (void)
     {
       puts ("Hi there!");
       return 0;
     }

   To accept command line parameters, you need to have two parameters in
the 'main' function, 'int argc' followed by 'char *argv[]'.  You can
change the names of those parameters, but they must have those data
types--'int' and array of pointers to 'char'.  'argc' is the number of
command line parameters, including the name of the program itself.
'argv' is an array of the parameters, as character strings.  'argv[0]',
the first element in the array, is the name of the program as typed at
the command line(1); any following array elements are the parameters
that followed the name of the program.

   Here is an example 'main' function that accepts command line
parameters, and prints out what those parameters are:

     int
     main (int argc, char *argv[])
     {
       int counter;

       for (counter = 0; counter < argc; counter++)
         printf ("%s\n", argv[counter]);

       return 0;
     }

   ---------- Footnotes ----------

   (1) Rarely, 'argv[0]' can be a null pointer (in this case 'argc' is
0) or 'argv[0][0]' can be the null character.  In any case, 'argv[argc]'
is a null pointer.


File: gnu-c-manual.info,  Node: Recursive Functions,  Next: Static Functions,  Prev: The main Function,  Up: Functions

5.8 Recursive Functions
=======================

You can write a function that is recursive--a function that calls
itself.  Here is an example that computes the factorial of an integer:

     int
     factorial (int x)
     {
       if (x < 1)
         return 1;
       else
         return (x * factorial (x - 1));
     }

   Be careful that you do not write a function that is infinitely
recursive.  In the above example, once 'x' is 1, the recursion stops.
However, in the following example, the recursion does not stop until the
program is interrupted or runs out of memory:

     int
     watermelon (int x)
     {
       return (watermelon (x));
     }

   Functions can also be indirectly recursive, of course.


File: gnu-c-manual.info,  Node: Static Functions,  Next: Nested Functions,  Prev: Recursive Functions,  Up: Functions

5.9 Static Functions
====================

You can define a function to be static if you want it to be callable
only within the source file where it is defined:

     static int
     foo (int x)
     {
       return x + 42;
     }

This is useful if you are building a reusable library of functions and
need to include some subroutines that should not be callable by the end
user.

   Functions which are defined in this way are said to have "static
linkage".  Unfortunately the 'static' keyword has multiple meanings;
*note Storage Class Specifiers::.


File: gnu-c-manual.info,  Node: Nested Functions,  Prev: Static Functions,  Up: Functions

5.10 Nested Functions
=====================

As a GNU C extension, you can define functions within other functions, a
technique known as nesting functions.

   Here is an example of a tail-recursive factorial function, defined
using a nested function:

     int
     factorial (int x)
     {
       int
       factorial_helper (int a, int b)
       {
         if (a < 1)
         {
           return b;
         }
         else
         {
           return factorial_helper ((a - 1), (a * b));
         }
       }

      return factorial_helper (x, 1);
     }

   Note that nested functions must be defined along with variable
declarations at the beginning of a function, and all other statements
follow.


File: gnu-c-manual.info,  Node: Program Structure and Scope,  Next: A Sample Program,  Prev: Functions,  Up: Top

6 Program Structure and Scope
*****************************

Now that we have seen all of the fundamental elements of C programs,
it's time to look at the big picture.

* Menu:

* Program Structure::
* Scope::


File: gnu-c-manual.info,  Node: Program Structure,  Next: Scope,  Up: Program Structure and Scope

6.1 Program Structure
=====================

A C program may exist entirely within a single source file, but more
commonly, any non-trivial program will consist of several custom header
files and source files, and will also include and link with files from
existing libraries.

   By convention, header files (with a ".h" extension) contain variable
and function declarations, and source files (with a ".c" extension)
contain the corresponding definitions.  Source files may also store
declarations, if these declarations are not for objects which need to be
seen by other files.  However, header files almost certainly should not
contain any definitions.

   For example, if you write a function that computes square roots, and
you wanted this function to be accessible to files other than where you
define the function, then you would put the function declaration into a
header file (with a ".h" file extension):

     /* sqrt.h */

     double
     computeSqrt (double x);

This header file could be included by other source files which need to
use your function, but do not need to know how it was implemented.

   The implementation of the function would then go into a corresponding
source file (with a ".c" file extension):

     /* sqrt.c */
     #include "sqrt.h"

     double
     computeSqrt (double x)
     {
       double result;
       ...
       return result;
     }


File: gnu-c-manual.info,  Node: Scope,  Prev: Program Structure,  Up: Program Structure and Scope

6.2 Scope
=========

Scope refers to what parts of the program can "see" a declared object.
A declared object can be visible only within a particular function, or
within a particular file, or may be visible to an entire set of files by
way of including header files and using 'extern' declarations.

   Unless explicitly stated otherwise, declarations made at the
top-level of a file (i.e., not within a function) are visible to the
entire file, including from within functions, but are not visible
outside of the file.

   Declarations made within functions are visible only within those
functions.

   A declaration is not visible to declarations that came before it; for
example:

     int x = 5;
     int y = x + 10;

will work, but:

     int x = y + 10;
     int y = 5;

will not.

   *Note Storage Class Specifiers::, for more information on changing
the scope of declared objects.  Also see *note Static Functions::.


File: gnu-c-manual.info,  Node: A Sample Program,  Next: Overflow,  Prev: Program Structure and Scope,  Up: Top

7 A Sample Program
******************

To conclude our description of C, here is a complete program written in
C, consisting of both a C source file and a header file.  This program
is an expanded version of the quintessential "hello world" program, and
serves as an example of how to format and structure C code for use in
programs for FSF Project GNU. (You can always download the most recent
version of this program, including sample makefiles and other examples
of how to produce GNU software, from
'http://www.gnu.org/software/hello'.)

   This program uses features of the preprocessor; for a description of
preprocessor macros, see 'The C Preprocessor', available as part of the
GCC documentation.

* Menu:

* hello.c::
* system.h::


File: gnu-c-manual.info,  Node: hello.c,  Next: system.h,  Up: A Sample Program

7.1 'hello.c'
=============

     /* hello.c -- print a greeting message and exit.

        Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
        2005, 2006, 2007 Free Software Foundation, Inc.

        This program is free software; you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation; either version 3, or (at your option)
        any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program; if not, write to the Free Software Foundation,
        Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */

     #include <config.h>
     #include "system.h"

     /* String containing name the program is called with.  */
     const char *program_name;

     static const struct option longopts[] =
     {
       { "greeting", required_argument, NULL, 'g' },
       { "help", no_argument, NULL, 'h' },
       { "next-generation", no_argument, NULL, 'n' },
       { "traditional", no_argument, NULL, 't' },
       { "version", no_argument, NULL, 'v' },
       { NULL, 0, NULL, 0 }
     };

     static void print_help (void);
     static void print_version (void);

     int
     main (int argc, char *argv[])
     {
       int optc;
       int t = 0, n = 0, lose = 0;
       const char *greeting = NULL;

       program_name = argv[0];

       /* Set locale via LC_ALL.  */
       setlocale (LC_ALL, "");

     #if ENABLE_NLS
       /* Set the text message domain.  */
       bindtextdomain (PACKAGE, LOCALEDIR);
       textdomain (PACKAGE);
     #endif

       /* Even exiting has subtleties.  The /dev/full device on GNU/Linux
          can be used for testing whether writes are checked properly.  For
          instance, hello >/dev/full should exit unsuccessfully.  On exit,
          if any writes failed, change the exit status.  This is
          implemented in the Gnulib module "closeout".  */
       atexit (close_stdout);

       while ((optc = getopt_long (argc, argv, "g:hntv", longopts, NULL)) != -1)
         switch (optc)
           {
           /* One goal here is having --help and --version exit immediately,
              per GNU coding standards.  */
           case 'v':
             print_version ();
             exit (EXIT_SUCCESS);
             break;
           case 'g':
             greeting = optarg;
             break;
           case 'h':
             print_help ();
             exit (EXIT_SUCCESS);
             break;
           case 'n':
             n = 1;
             break;
           case 't':
             t = 1;
             break;
           default:
             lose = 1;
             break;
           }

       if (lose || optind < argc)
         {
           /* Print error message and exit.  */
           if (optind < argc)
             fprintf (stderr, _("%s: extra operand: %s\n"),
     		 program_name, argv[optind]);
           fprintf (stderr, _("Try `%s --help' for more information.\n"),
                    program_name);
           exit (EXIT_FAILURE);
         }

       /* Print greeting message and exit. */
       if (t)
         printf (_("hello, world\n"));

       else if (n)
         /* TRANSLATORS: Use box drawing characters or other fancy stuff
            if your encoding (e.g., UTF-8) allows it.  If done so add the
            following note, please:

            [Note: For best viewing results use a UTF-8 locale, please.]
         */
     	printf (_("\
     +---------------+\n\
     | Hello, world! |\n\
     +---------------+\n\
     "));

       else
         {
           if (!greeting)
             greeting = _("Hello, world!");
           puts (greeting);
         }

       exit (EXIT_SUCCESS);
     }



     /* Print help info.  This long message is split into
        several pieces to help translators be able to align different
        blocks and identify the various pieces.  */

     static void
     print_help (void)
     {
       /* TRANSLATORS: --help output 1 (synopsis)
          no-wrap */
             printf (_("\
     Usage: %s [OPTION]...\n"), program_name);

       /* TRANSLATORS: --help output 2 (brief description)
          no-wrap */
       fputs (_("\
     Print a friendly, customizable greeting.\n"), stdout);

       puts ("");
       /* TRANSLATORS: --help output 3: options 1/2
          no-wrap */
       fputs (_("\
       -h, --help          display this help and exit\n\
       -v, --version       display version information and exit\n"), stdout);

       puts ("");
       /* TRANSLATORS: --help output 4: options 2/2
          no-wrap */
       fputs (_("\
       -t, --traditional       use traditional greeting format\n\
       -n, --next-generation   use next-generation greeting format\n\
       -g, --greeting=TEXT     use TEXT as the greeting message\n"), stdout);

       printf ("\n");
       /* TRANSLATORS: --help output 5 (end)
          TRANSLATORS: the placeholder indicates the bug-reporting address
          for this application.  Please add _another line_ with the
          address for translation bugs.
          no-wrap */
       printf (_("\
     Report bugs to <%s>.\n"), PACKAGE_BUGREPORT);
     }



     /* Print version and copyright information.  */

     static void
     print_version (void)
     {
       printf ("hello (GNU %s) %s\n", PACKAGE, VERSION);
       /* xgettext: no-wrap */
       puts ("");

       /* It is important to separate the year from the rest of the message,
          as done here, to avoid having to retranslate the message when a new
          year comes around.  */
       printf (_("\
     Copyright (C) %s Free Software Foundation, Inc.\n\
     License GPLv3+: GNU GPL version 3 or later\
     <http://gnu.org/licenses/gpl.html>\n\
     This is free software: you are free to change and redistribute it.\n\
     There is NO WARRANTY, to the extent permitted by law.\n"),
                   "2007");
     }


File: gnu-c-manual.info,  Node: system.h,  Prev: hello.c,  Up: A Sample Program

7.2 'system.h'
==============

     /* system.h: system-dependent declarations; include this first.
        Copyright (C) 1996, 2005, 2006, 2007 Free Software Foundation, Inc.

        This program is free software; you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation; either version 3, or (at your option)
        any later version.

        This program is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with this program; if not, write to the Free Software Foundation,
        Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */

     #ifndef HELLO_SYSTEM_H
     #define HELLO_SYSTEM_H

     /* Assume ANSI C89 headers are available.  */
     #include <locale.h>
     #include <stdio.h>
     #include <stdlib.h>
     #include <string.h>

     /* Use POSIX headers.  If they are not available, we use the substitute
        provided by gnulib.  */
     #include <getopt.h>
     #include <unistd.h>

     /* Internationalization.  */
     #include "gettext.h"
     #define _(str) gettext (str)
     #define N_(str) gettext_noop (str)

     /* Check for errors on write.  */
     #include "closeout.h"

     #endif /* HELLO_SYSTEM_H */


File: gnu-c-manual.info,  Node: Overflow,  Next: GNU Free Documentation License,  Prev: A Sample Program,  Up: Top

Appendix A Overflow
*******************

[This appendix, written principally by Paul Eggert, is from the GNU
Autoconf manual.  We thought that it would be helpful to include here.
-TJR]

   In practice many portable C programs assume that signed integer
overflow wraps around reliably using two's complement arithmetic.  Yet
the C standard says that program behavior is undefined on overflow, and
in a few cases C programs do not work on some modern implementations
because their overflows do not wrap around as their authors expected.
Conversely, in signed integer remainder, the C standard requires
overflow behavior that is commonly not implemented.

* Menu:

* Integer Overflow Basics::      Why integer overflow is a problem
* Signed Overflow Examples::     Examples of code assuming wraparound
* Optimization and Wraparound::  Optimizations that break uses of wraparound
* Signed Overflow Advice::       Practical advice for signed overflow issues
* Signed Integer Division::      'INT_MIN / -1' and 'INT_MIN % -1'


File: gnu-c-manual.info,  Node: Integer Overflow Basics,  Next: Signed Overflow Examples,  Up: Overflow

A.1 Basics of Integer Overflow
==============================

In languages like C, unsigned integer overflow reliably wraps around;
e.g., 'UINT_MAX + 1' yields zero.  This is guaranteed by the C standard
and is portable in practice, unless you specify aggressive, nonstandard
optimization options suitable only for special applications.

   In contrast, the C standard says that signed integer overflow leads
to undefined behavior where a program can do anything, including dumping
core or overrunning a buffer.  The misbehavior can even precede the
overflow.  Such an overflow can occur during addition, subtraction,
multiplication, division, and left shift.

   Despite this requirement of the standard, many C programs assume that
signed integer overflow silently wraps around modulo a power of two,
using two's complement arithmetic, so long as you cast the resulting
value to a signed integer type or store it into a signed integer
variable.  If you use conservative optimization flags, such programs are
generally portable to the vast majority of modern platforms, with a few
exceptions discussed later.

   For historical reasons the C standard also allows implementations
with ones' complement or signed magnitude arithmetic, but it is safe to
assume two's complement nowadays.

   Also, overflow can occur when converting an out-of-range value to a
signed integer type.  Here a standard implementation must define what
happens, but this might include raising an exception.  In practice all
known implementations support silent wraparound in this case, so you
need not worry about other possibilities.


File: gnu-c-manual.info,  Node: Signed Overflow Examples,  Next: Optimization and Wraparound,  Prev: Integer Overflow Basics,  Up: Overflow

A.2 Examples of Code Assuming Wraparound Overflow
=================================================

There has long been a tension between what the C standard requires for
signed integer overflow, and what C programs commonly assume.  The
standard allows aggressive optimizations based on assumptions that
overflow never occurs, but many practical C programs rely on overflow
wrapping around.  These programs do not conform to the standard, but
they commonly work in practice because compiler writers are
understandably reluctant to implement optimizations that would break
many programs, unless perhaps a user specifies aggressive optimization.

   The C Standard says that if a program has signed integer overflow its
behavior is undefined, and the undefined behavior can even precede the
overflow.  To take an extreme example:

     if (password == expected_password)
       allow_superuser_privileges ();
     else if (counter++ == INT_MAX)
       abort ();
     else
       printf ("%d password mismatches\n", counter);

If the 'int' variable 'counter' equals 'INT_MAX', 'counter++' must
overflow and the behavior is undefined, so the C standard allows the
compiler to optimize away the test against 'INT_MAX' and the 'abort'
call.  Worse, if an earlier bug in the program lets the compiler deduce
that 'counter == INT_MAX' or that 'counter' previously overflowed, the C
standard allows the compiler to optimize away the password test and
generate code that allows superuser privileges unconditionally.

   Despite this requirement by the standard, it has long been common for
C code to assume wraparound arithmetic after signed overflow, and all
known practical C implementations support some C idioms that assume
wraparound signed arithmetic, even if the idioms do not conform strictly
to the standard.  If your code looks like the following examples it will
almost surely work with real-world compilers.

   Here is an example derived from the 7th Edition Unix implementation
of 'atoi' (1979-01-10):

     char *p;
     int f, n;
     ...
     while (*p >= '0' && *p <= '9')
       n = n * 10 + *p++ - '0';
     return (f ? -n : n);

Even if the input string is in range, on most modern machines this has
signed overflow when computing the most negative integer (the '-n'
overflows) or a value near an extreme integer (the first '+' overflows).

   Here is another example, derived from the 7th Edition implementation
of 'rand' (1979-01-10).  Here the programmer expects both multiplication
and addition to wrap on overflow:

     static long int randx = 1;
     ...
     randx = randx * 1103515245 + 12345;
     return (randx >> 16) & 077777;

   In the following example, derived from the GNU C Library 2.5
implementation of 'mktime' (2006-09-09), the code assumes wraparound
arithmetic in '+' to detect signed overflow:

     time_t t, t1, t2;
     int sec_requested, sec_adjustment;
     ...
     t1 = t + sec_requested;
     t2 = t1 + sec_adjustment;
     if (((t1 < t) != (sec_requested < 0))
         || ((t2 < t1) != (sec_adjustment < 0)))
       return -1;

   If your code looks like these examples, it is probably safe even
though it does not strictly conform to the C standard.  This might lead
one to believe that one can generally assume wraparound on overflow, but
that is not always true, as can be seen in the next section.


File: gnu-c-manual.info,  Node: Optimization and Wraparound,  Next: Signed Overflow Advice,  Prev: Signed Overflow Examples,  Up: Overflow

A.3 Optimizations That Break Wraparound Arithmetic
==================================================

Compilers sometimes generate code that is incompatible with wraparound
integer arithmetic.  A simple example is an algebraic simplification: a
compiler might translate '(i * 2000) / 1000' to 'i * 2' because it
assumes that 'i * 2000' does not overflow.  The translation is not
equivalent to the original when overflow occurs: e.g., in the typical
case of 32-bit signed two's complement wraparound 'int', if 'i' has type
'int' and value '1073742', the original expression returns -2147483 but
the optimized version returns the mathematically correct value 2147484.

   More subtly, loop induction optimizations often exploit the undefined
behavior of signed overflow.  Consider the following contrived function
'sumc':

     int
     sumc (int lo, int hi)
     {
       int sum = 0;
       int i;
       for (i = lo; i <= hi; i++)
         sum ^= i * 53;
       return sum;
     }

To avoid multiplying by 53 each time through the loop, an optimizing
compiler might internally transform 'sumc' to the equivalent of the
following:

     int
     transformed_sumc (int lo, int hi)
     {
       int sum = 0;
       int hic = hi * 53;
       int ic;
       for (ic = lo * 53; ic <= hic; ic += 53)
         sum ^= ic;
       return sum;
     }

This transformation is allowed by the C standard, but it is invalid for
wraparound arithmetic when 'INT_MAX / 53 < hi', because then the
overflow in computing expressions like 'hi * 53' can cause the
expression 'i <= hi' to yield a different value from the transformed
expression 'ic <= hic'.

   For this reason, compilers that use loop induction and similar
techniques often do not support reliable wraparound arithmetic when a
loop induction variable like 'ic' is involved.  Since loop induction
variables are generated by the compiler, and are not visible in the
source code, it is not always trivial to say whether the problem affects
your code.

   Hardly any code actually depends on wraparound arithmetic in cases
like these, so in practice these loop induction optimizations are almost
always useful.  However, edge cases in this area can cause problems.
For example:

     int j;
     for (j = 1; 0 < j; j *= 2)
       test (j);

Here, the loop attempts to iterate through all powers of 2 that 'int'
can represent, but the C standard allows a compiler to optimize away the
comparison and generate an infinite loop, under the argument that
behavior is undefined on overflow.  As of this writing this optimization
is not done by any production version of GCC with '-O2', but it might be
performed by other compilers, or by more aggressive GCC optimization
options, and the GCC developers have not decided whether it will
continue to work with GCC and '-O2'.


File: gnu-c-manual.info,  Node: Signed Overflow Advice,  Next: Signed Integer Division,  Prev: Optimization and Wraparound,  Up: Overflow

A.4 Practical Advice for Signed Overflow Issues
===============================================

Ideally the safest approach is to avoid signed integer overflow
entirely.  For example, instead of multiplying two signed integers, you
can convert them to unsigned integers, multiply the unsigned values,
then test whether the result is in signed range.

   Rewriting code in this way will be inconvenient, though, particularly
if the signed values might be negative.  Also, it may hurt performance.
Using unsigned arithmetic to check for overflow is particularly painful
to do portably and efficiently when dealing with an integer type like
'uid_t' whose width and signedness vary from platform to platform.

   Furthermore, many C applications pervasively assume wraparound
behavior and typically it is not easy to find and remove all these
assumptions.  Hence it is often useful to maintain nonstandard code that
assumes wraparound on overflow, instead of rewriting the code.  The rest
of this section attempts to give practical advice for this situation.

   If your code wants to detect signed integer overflow in 'sum = a +
b', it is generally safe to use an expression like '(sum < a) != (b <
0)'.

   If your code uses a signed loop index, make sure that the index
cannot overflow, along with all signed expressions derived from the
index.  Here is a contrived example of problematic code with two
instances of overflow.

     for (i = INT_MAX - 10; i <= INT_MAX; i++)
       if (i + 1 < 0)
         {
           report_overflow ();
           break;
         }

Because of the two overflows, a compiler might optimize away or
transform the two comparisons in a way that is incompatible with the
wraparound assumption.

   If your code uses an expression like '(i * 2000) / 1000' and you
actually want the multiplication to wrap around on overflow, use
unsigned arithmetic to do it, e.g., '((int) (i * 2000u)) / 1000'.

   If your code assumes wraparound behavior and you want to insulate it
against any GCC optimizations that would fail to support that behavior,
you should use GCC's '-fwrapv' option, which causes signed overflow to
wrap around reliably (except for division and remainder, as discussed in
the next section).

   If you need to port to platforms where signed integer overflow does
not reliably wrap around (e.g., due to hardware overflow checking, or to
highly aggressive optimizations), you should consider debugging with
GCC's '-ftrapv' option, which causes signed overflow to raise an
exception.


File: gnu-c-manual.info,  Node: Signed Integer Division,  Prev: Signed Overflow Advice,  Up: Overflow

A.5 Signed Integer Division and Integer Overflow
================================================

Overflow in signed integer division is not always harmless: for example,
on CPUs of the i386 family, dividing 'INT_MIN' by '-1' yields a SIGFPE
signal which by default terminates the program.  Worse, taking the
remainder of these two values typically yields the same signal on these
CPUs, even though the C standard requires 'INT_MIN % -1' to yield zero
because the expression does not overflow.


File: gnu-c-manual.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: Overflow,  Up: Top

GNU Free Documentation License
******************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled "History" in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          "History" section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts."  line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: gnu-c-manual.info,  Node: Index,  Prev: GNU Free Documentation License,  Up: Top

Index
*****

 [index ]
* Menu:

* accessing array elements:              Accessing Array Elements.
                                                               (line  6)
* accessing structure members:           Accessing Structure Members.
                                                               (line  6)
* accessing union members:               Accessing Union Members.
                                                               (line  6)
* arithmetic operators:                  Arithmetic Operators. (line  6)
* array elements, accessing:             Accessing Array Elements.
                                                               (line  6)
* array subscripts:                      Array Subscripts.     (line  6)
* arrays:                                Arrays.               (line  6)
* arrays as strings:                     Arrays as Strings.    (line  6)
* arrays of structures:                  Arrays of Structures. (line  6)
* arrays of unions:                      Arrays of Unions.     (line  6)
* arrays, declaring:                     Declaring Arrays.     (line  6)
* arrays, initializing:                  Initializing Arrays.  (line  6)
* arrays, multidimensional:              Multidimensional Arrays.
                                                               (line  6)
* assignment operators:                  Assignment Operators. (line  6)
* auto storage class specifier:          Storage Class Specifiers.
                                                               (line  6)
* bit fields:                            Bit Fields.           (line  6)
* bit shifting:                          Bit Shifting.         (line  6)
* bitwise logical operators:             Bitwise Logical Operators.
                                                               (line  6)
* blocks:                                Blocks.               (line  6)
* break statement:                       The break Statement.  (line  6)
* calling functions:                     Calling Functions.    (line  6)
* casts:                                 Type Casts.           (line  6)
* char data type:                        Integer Types.        (line 27)
* character constants:                   Character Constants.  (line  6)
* comma operator:                        The Comma Operator.   (line  6)
* comparison operators:                  Comparison Operators. (line  6)
* complex conjugation:                   Complex Conjugation.  (line  6)
* complex number types:                  Complex Number Types. (line  6)
* compound statements:                   Blocks.               (line  6)
* conditional expressions:               Conditional Expressions.
                                                               (line  6)
* conjugation:                           Complex Conjugation.  (line  6)
* const type qualifier:                  Type Qualifiers.      (line  6)
* constants:                             Constants.            (line  6)
* constants, character:                  Character Constants.  (line  6)
* constants, floating point:             Real Number Constants.
                                                               (line  6)
* constants, integer:                    Integer Constants.    (line  6)
* constants, real number:                Real Number Constants.
                                                               (line  6)
* continue statement:                    The continue Statement.
                                                               (line  6)
* data types:                            Data Types.           (line  6)
* data types, array:                     Arrays.               (line  6)
* data types, complex number:            Complex Number Types. (line  6)
* data types, enumeration:               Enumerations.         (line  6)
* data types, floating point:            Real Number Types.    (line  6)
* data types, integer:                   Integer Types.        (line  6)
* data types, pointer:                   Pointers.             (line  6)
* data types, primitive:                 Primitive Types.      (line  6)
* data types, real number:               Real Number Types.    (line  6)
* data types, structure:                 Structures.           (line  6)
* data types, union:                     Unions.               (line  6)
* declarations inside expressions:       Statements and Declarations in Expressions.
                                                               (line  6)
* declarations, function:                Function Declarations.
                                                               (line  6)
* declaring arrays:                      Declaring Arrays.     (line  6)
* declaring enumerations:                Declaring Enumerations.
                                                               (line  6)
* declaring pointers:                    Declaring Pointers.   (line  6)
* declaring string arrays:               Arrays as Strings.    (line 10)
* declaring structure variables:         Declaring Structure Variables.
                                                               (line  6)
* declaring structure variables after definition: Declaring Structure Variables After Definition.
                                                               (line  6)
* declaring structure variables at definition: Declaring Structure Variables at Definition.
                                                               (line  6)
* declaring union variables:             Declaring Union Variables.
                                                               (line  6)
* declaring union variables after definition: Declaring Union Variables After Definition.
                                                               (line  6)
* declaring union variables at definition: Declaring Union Variables at Definition.
                                                               (line  6)
* decrement operator:                    Incrementing and Decrementing.
                                                               (line  6)
* defining enumerations:                 Defining Enumerations.
                                                               (line  6)
* defining structures:                   Defining Structures.  (line  6)
* defining unions:                       Defining Unions.      (line  6)
* definitions, function:                 Function Definitions. (line  6)
* division, integer:                     Signed Integer Division.
                                                               (line  6)
* do statement:                          The do Statement.     (line  6)
* double data type:                      Real Number Types.    (line 21)
* else statements:                       The if Statement.     (line  6)
* enumerations:                          Enumerations.         (line  6)
* enumerations, declaring:               Declaring Enumerations.
                                                               (line  6)
* enumerations, defining:                Defining Enumerations.
                                                               (line  6)
* enumerations, incomplete:              Incomplete Types.     (line  6)
* exit status:                           The main Function.    (line 14)
* EXIT_FAILURE:                          The main Function.    (line 14)
* EXIT_SUCCESS:                          The main Function.    (line 14)
* expression statements:                 Expression Statements.
                                                               (line  6)
* expressions:                           Expressions.          (line  6)
* expressions containing statements:     Statements and Declarations in Expressions.
                                                               (line  6)
* expressions, conditional:              Conditional Expressions.
                                                               (line  6)
* extern storage class specifier:        Storage Class Specifiers.
                                                               (line  6)
* fields, bit:                           Bit Fields.           (line  6)
* float data type:                       Real Number Types.    (line 14)
* floating point constants:              Real Number Constants.
                                                               (line  6)
* floating point types:                  Real Number Types.    (line  6)
* for statement:                         The for Statement.    (line  6)
* function calls, as expressions:        Function Calls as Expressions.
                                                               (line  6)
* function declarations:                 Function Declarations.
                                                               (line  6)
* function definitions:                  Function Definitions. (line  6)
* function parameter lists, variable length: Variable Length Parameter Lists.
                                                               (line  6)
* function parameters:                   Function Parameters.  (line  6)
* function pointers, calling through:    Calling Functions Through Function Pointers.
                                                               (line  6)
* function, main:                        The main Function.    (line  6)
* functions:                             Functions.            (line  6)
* functions, calling:                    Calling Functions.    (line  6)
* functions, nested:                     Nested Functions.     (line  6)
* functions, recursive:                  Recursive Functions.  (line  6)
* functions, static:                     Static Functions.     (line  6)
* goto statement:                        The goto Statement.   (line  6)
* hello program:                         A Sample Program.     (line  6)
* hello.c:                               hello.c.              (line  6)
* identifiers:                           Identifiers.          (line  6)
* if statements:                         The if Statement.     (line  6)
* incomplete types:                      Incomplete Types.     (line  6)
* increment operator:                    Incrementing and Decrementing.
                                                               (line  6)
* indirect member access operator:       Member Access Expressions.
                                                               (line 20)
* initializing arrays:                   Initializing Arrays.  (line  6)
* initializing pointers:                 Initializing Pointers.
                                                               (line  6)
* initializing string arrays:            Arrays as Strings.    (line 18)
* initializing structure members:        Initializing Structure Members.
                                                               (line  6)
* initializing union members:            Initializing Union Members.
                                                               (line  6)
* int data type:                         Integer Types.        (line 45)
* integer constants:                     Integer Constants.    (line  6)
* integer overflow:                      Integer Overflow Basics.
                                                               (line  6)
* integer overflow <1>:                  Signed Overflow Examples.
                                                               (line  6)
* integer overflow <2>:                  Signed Overflow Advice.
                                                               (line  6)
* integer types:                         Integer Types.        (line  6)
* keywords:                              Keywords.             (line  6)
* labeled statements:                    Labels.               (line  6)
* labels:                                Labels.               (line  6)
* lexical elements:                      Lexical Elements.     (line  6)
* logical operators:                     Logical Operators.    (line  6)
* logical operators, bitwise:            Bitwise Logical Operators.
                                                               (line  6)
* long double data type:                 Real Number Types.    (line 26)
* long int data type:                    Integer Types.        (line 55)
* long long int data type:               Integer Types.        (line 70)
* loop induction:                        Optimization and Wraparound.
                                                               (line  6)
* macros, statements in expressions:     Statements and Declarations in Expressions.
                                                               (line  6)
* main function:                         The main Function.    (line  6)
* member access expressions:             Member Access Expressions.
                                                               (line  6)
* multidimensional arrays:               Multidimensional Arrays.
                                                               (line  6)
* nested functions:                      Nested Functions.     (line  6)
* null statement:                        The Null Statement.   (line  6)
* operator precedence:                   Operator Precedence.  (line  6)
* operator, decrement:                   Incrementing and Decrementing.
                                                               (line  6)
* operator, increment:                   Incrementing and Decrementing.
                                                               (line  6)
* operators:                             Expressions.          (line 27)
* operators as lexical elements:         Operators.            (line  6)
* operators, arithmetic:                 Arithmetic Operators. (line  6)
* operators, assignment:                 Assignment Operators. (line  6)
* operators, comparison:                 Comparison Operators. (line  6)
* overflow, signed integer:              Integer Overflow Basics.
                                                               (line  6)
* overflow, signed integer <1>:          Signed Overflow Examples.
                                                               (line  6)
* overflow, signed integer <2>:          Signed Overflow Advice.
                                                               (line  6)
* parameters lists, variable length:     Variable Length Parameter Lists.
                                                               (line  6)
* parameters, function:                  Function Parameters.  (line  6)
* pointer operators:                     Pointer Operators.    (line  6)
* pointers:                              Pointers.             (line  6)
* pointers to structures:                Pointers to Structures.
                                                               (line  6)
* pointers to unions:                    Pointers to Unions.   (line  6)
* pointers, declaring:                   Declaring Pointers.   (line  6)
* pointers, initializing:                Initializing Pointers.
                                                               (line  6)
* precedence, operator:                  Operator Precedence.  (line  6)
* preface:                               Preface.              (line  6)
* primitive data types:                  Primitive Types.      (line  6)
* program structure:                     Program Structure.    (line  6)
* qualifiers, type:                      Type Qualifiers.      (line  6)
* real number constants:                 Real Number Constants.
                                                               (line  6)
* real number types:                     Real Number Types.    (line  6)
* recursive functions:                   Recursive Functions.  (line  6)
* register storage class specifier:      Storage Class Specifiers.
                                                               (line  6)
* renaming types:                        Renaming Types.       (line  6)
* return statement:                      The return Statement. (line  6)
* return value of main:                  The main Function.    (line 14)
* sample program:                        A Sample Program.     (line  6)
* scope:                                 Scope.                (line  6)
* separators:                            Separators.           (line  6)
* sequence point:                        Sequence Points.      (line 12)
* shifting:                              Bit Shifting.         (line  6)
* short int data type:                   Integer Types.        (line 35)
* side effect:                           Side Effects.         (line  6)
* side effects, macro argument:          Statements and Declarations in Expressions.
                                                               (line 37)
* signed char data type:                 Integer Types.        (line 19)
* signed integer overflow:               Integer Overflow Basics.
                                                               (line  6)
* signed integer overflow <1>:           Signed Overflow Examples.
                                                               (line  6)
* signed integer overflow <2>:           Signed Overflow Advice.
                                                               (line  6)
* size of structures:                    Size of Structures.   (line  6)
* size of unions:                        Size of Unions.       (line  6)
* sizeof operator:                       The sizeof Operator.  (line  6)
* specifiers, storage class:             Storage Class Specifiers.
                                                               (line  6)
* statement, null:                       The Null Statement.   (line  6)
* statements:                            Statements.           (line  6)
* statements inside expressions:         Statements and Declarations in Expressions.
                                                               (line  6)
* statements, expression:                Expression Statements.
                                                               (line  6)
* statements, labeled:                   Labels.               (line  6)
* static functions:                      Static Functions.     (line  6)
* static linkage:                        Static Functions.     (line  6)
* static storage class specifier:        Storage Class Specifiers.
                                                               (line  6)
* storage class specifiers:              Storage Class Specifiers.
                                                               (line  6)
* string arrays, declaring:              Arrays as Strings.    (line 10)
* string arrays, initializing:           Arrays as Strings.    (line 18)
* string constants:                      String Constants.     (line  6)
* string literals:                       String Constants.     (line  6)
* strings, arrays as:                    Arrays as Strings.    (line  6)
* structure members, accessing:          Accessing Structure Members.
                                                               (line  6)
* structure members, initializing:       Initializing Structure Members.
                                                               (line  6)
* structure variables, declaring:        Declaring Structure Variables.
                                                               (line  6)
* structure variables, declaring after definition: Declaring Structure Variables After Definition.
                                                               (line  6)
* structure variables, declaring at definition: Declaring Structure Variables at Definition.
                                                               (line  6)
* structure, program:                    Program Structure.    (line  6)
* structures:                            Structures.           (line  6)
* structures, arrays of:                 Arrays of Structures. (line  6)
* structures, defining:                  Defining Structures.  (line  6)
* structures, incomplete:                Incomplete Types.     (line  6)
* structures, pointers to:               Pointers to Structures.
                                                               (line  6)
* structures, size of:                   Size of Structures.   (line  6)
* switch statement:                      The switch Statement. (line  6)
* system.h:                              system.h.             (line  6)
* ternary operator:                      Conditional Expressions.
                                                               (line  6)
* type casts:                            Type Casts.           (line  6)
* type qualifiers:                       Type Qualifiers.      (line  6)
* typedef statement:                     The typedef Statement.
                                                               (line  6)
* types:                                 Data Types.           (line  6)
* types, array:                          Arrays.               (line  6)
* types, complex number:                 Complex Number Types. (line  6)
* types, enumeration:                    Enumerations.         (line  6)
* types, floating point:                 Real Number Types.    (line  6)
* types, incomplete:                     Incomplete Types.     (line  6)
* types, integer:                        Integer Types.        (line  6)
* types, pointer:                        Pointers.             (line  6)
* types, primitive:                      Primitive Types.      (line  6)
* types, real number:                    Real Number Types.    (line  6)
* types, renaming:                       Renaming Types.       (line  6)
* types, structure:                      Structures.           (line  6)
* types, union:                          Unions.               (line  6)
* union members, accessing:              Accessing Union Members.
                                                               (line  6)
* union members, initializing:           Initializing Union Members.
                                                               (line  6)
* union variables, declaring:            Declaring Union Variables.
                                                               (line  6)
* union variables, declaring after definition: Declaring Union Variables After Definition.
                                                               (line  6)
* union variables, declaring at definition: Declaring Union Variables at Definition.
                                                               (line  6)
* unions:                                Unions.               (line  6)
* unions, arrays of:                     Arrays of Unions.     (line  6)
* unions, defining:                      Defining Unions.      (line  6)
* unions, incomplete:                    Incomplete Types.     (line  6)
* unions, pointers to:                   Pointers to Unions.   (line  6)
* unions, size of:                       Size of Unions.       (line  6)
* unsigned char data type:               Integer Types.        (line 23)
* unsigned int data type:                Integer Types.        (line 50)
* unsigned long int data type:           Integer Types.        (line 63)
* unsigned long long int data type:      Integer Types.        (line 78)
* unsigned short int data type:          Integer Types.        (line 40)
* unspecified behaviour:                 Sequence Points Constrain Expressions.
                                                               (line 88)
* variable length parameter lists:       Variable Length Parameter Lists.
                                                               (line  6)
* volatile type qualifier:               Type Qualifiers.      (line  6)
* while statement:                       The while Statement.  (line  6)
* white space:                           White Space.          (line  6)
* wraparound arithmetic:                 Integer Overflow Basics.
                                                               (line  6)
* wraparound arithmetic <1>:             Signed Overflow Examples.
                                                               (line  6)
* wraparound arithmetic <2>:             Signed Overflow Advice.
                                                               (line  6)



Tag Table:
Node: Top517
Node: Preface951
Node: Lexical Elements3267
Node: Identifiers4145
Node: Keywords5201
Node: Constants6754
Node: Integer Constants7541
Node: Character Constants11001
Node: Real Number Constants13332
Node: String Constants14699
Node: Operators16929
Node: Separators17292
Node: White Space17624
Node: Data Types19112
Node: Primitive Types19440
Node: Integer Types19655
Node: Real Number Types23675
Node: Complex Number Types26244
Ref: Complex Number Types-Footnote-126731
Node: Standard Complex Number Types26823
Node: GNU Extensions for Complex Number Types28204
Node: Enumerations29910
Node: Defining Enumerations30544
Node: Declaring Enumerations31941
Node: Unions33434
Node: Defining Unions33935
Node: Declaring Union Variables35037
Node: Declaring Union Variables at Definition35515
Node: Declaring Union Variables After Definition36239
Node: Initializing Union Members36954
Node: Accessing Union Members38163
Node: Size of Unions38824
Node: Structures39496
Node: Defining Structures39890
Node: Declaring Structure Variables41243
Node: Declaring Structure Variables at Definition41769
Node: Declaring Structure Variables After Definition42504
Node: Initializing Structure Members43232
Node: Accessing Structure Members46196
Node: Bit Fields47132
Node: Size of Structures48788
Node: Arrays49834
Node: Declaring Arrays50299
Node: Initializing Arrays51476
Node: Accessing Array Elements53798
Node: Multidimensional Arrays54662
Node: Arrays as Strings55576
Node: Arrays of Unions58148
Node: Arrays of Structures59107
Node: Pointers60608
Node: Declaring Pointers61064
Node: Initializing Pointers62037
Node: Pointers to Unions63886
Node: Pointers to Structures64960
Node: Incomplete Types66084
Node: Type Qualifiers66953
Node: Storage Class Specifiers67932
Node: Renaming Types71077
Node: Expressions and Operators71378
Node: Expressions72075
Node: Assignment Operators73908
Node: Incrementing and Decrementing78531
Node: Arithmetic Operators81224
Node: Complex Conjugation85582
Node: Comparison Operators86643
Node: Logical Operators89682
Node: Bit Shifting91933
Node: Bitwise Logical Operators94846
Node: Pointer Operators97770
Node: The sizeof Operator100332
Node: Type Casts103100
Node: Array Subscripts105551
Node: Function Calls as Expressions106634
Node: The Comma Operator107070
Node: Member Access Expressions109478
Node: Conditional Expressions110831
Node: Statements and Declarations in Expressions113464
Node: Operator Precedence117071
Node: Order of Evaluation121767
Node: Side Effects123358
Node: Sequence Points125149
Ref: Sequence Points-Footnote-1129910
Node: Sequence Points Constrain Expressions130100
Ref: Sequence Points Constrain Expressions-Footnote-1136944
Node: Sequence Points and Signal Delivery137150
Node: Statements140059
Node: Labels140698
Node: Expression Statements141521
Node: The if Statement142589
Node: The switch Statement144509
Node: The while Statement147497
Node: The do Statement148296
Node: The for Statement149076
Node: Blocks152542
Node: The Null Statement153852
Node: The goto Statement154850
Node: The break Statement156624
Node: The continue Statement157442
Node: The return Statement158042
Node: The typedef Statement159714
Node: Functions161161
Node: Function Declarations162075
Node: Function Definitions163877
Node: Calling Functions165483
Node: Function Parameters166348
Node: Variable Length Parameter Lists169839
Node: Calling Functions Through Function Pointers172242
Node: The main Function173114
Ref: The main Function-Footnote-1175431
Node: Recursive Functions175595
Node: Static Functions176436
Node: Nested Functions177111
Node: Program Structure and Scope177910
Node: Program Structure178237
Node: Scope179722
Node: A Sample Program180749
Node: hello.c181605
Node: system.h187950
Node: Overflow189573
Node: Integer Overflow Basics190713
Node: Signed Overflow Examples192432
Node: Optimization and Wraparound195925
Node: Signed Overflow Advice198877
Node: Signed Integer Division201541
Node: GNU Free Documentation License202142
Node: Index227269

End Tag Table


Local Variables:
coding: utf-8
End:
