This is gnu-c-manual.info, produced by texi2any version 6.7 from
gnu-c-manual.texi.

Copyright (C) 2007-2015 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts and no Back-Cover Texts.
A copy of the license is included in the section entitled "GNU Free
Documentation License."


File: gnu-c-manual.info,  Node: Top,  Next: Preface,  Up: (dir)

GNU C Справочное руководство
****************************

Это справочное руководство GNU C.

* Menu:

* Preface::
* Lexical Elements::
* Data Types::
* Expressions and Operators::
* Statements::
* Functions::
* Program Structure and Scope::
* A Sample Program::
* Overflow::
* GNU Free Documentation License::
* Index::


File: gnu-c-manual.info,  Node: Preface,  Next: Lexical Elements,  Prev: Top,  Up: Top

Предисловие
***********

Это справочное руководство по языку программирования C, реализованному в
GNU Compiler Collection (GCC). В частности, это руководство направлено
на документирование:

   * Стандарт ANSI C 1989 года, широко известный как "C89"
   * Стандарт ISO C 1999 года, широко известный как "C99", в той
     степени, в которой C99 реализуется через GCC
   * Текущее состояние расширений GNU для стандарта C

В этом руководстве C89 рассматривается как базовый.  Возможности C99 и
расширения GNU явно обозначены.

   По умолчанию GCC компилирует код как C89 плюс расширения GNU.
Поддерживается большая часть C99; как только станет доступна полная
поддержка, диалект компиляции по умолчанию будет C99 плюс специфичные
для GNU расширения.  (Некоторые из расширений GNU для C89 в конечном
итоге, иногда слегка измененные, стали стандартными языковыми функциями
в C99.)

   Язык C включает набор директив препроцессора, которые используются
для таких вещей, как замена текста макроса, условная компиляция и
включение файлов.  Хотя обычно препроцессор GNU C описывается в
руководстве по языку C, он подробно описан в 'The C Preprocessor',
отдельном руководстве, которое охватывает предварительную обработку для
программ C, C++, и Objective-C, поэтому здесь он не включен.

Credits
=======

Спасибо всем, кто помогал с редактированием, корректурой, идеями,
набором и администрированием, включая: Diego Andres Alvarez Marin,
Nelson H. F. Beebe, Karl Berry, Robert Chassell, Hanfeng Chen, Mark de
Volld, Antonio Diaz Diaz, dine, Andreas Foerster, Denver Gingerich, Lisa
Goldstein, Robert Hansen, Jean-Christophe Helary, Mogens Hetsholm, Teddy
Hogeborn, Joe Humphries, J. Wren Hunt, Dutch Ingraham, Adam Johansen,
Vladimir Kadlec, Benjamin Kagia, Dright Kayorent, Sugun Kedambadi, Felix
Lee, Bjorn Liencres, Steve Morningthunder, Aljosha Papsch, Matthew
Plant, Jonathan Sisti, Richard Stallman, J. Otto Tennant, Ole Tetlie,
Keith Thompson, T.F. Torrey, James Youngman, и Steve Zachar.  Тревис
Ротвелл выполняет функции сопровождающего проекта и вместе с Джеймсом
Янгманом написал основную часть текста.

   Некоторые примеры программ основаны на алгоритмах из Donald Knuth's
'The Art of Computer Programming'.

   Присылайте отчеты об ошибках и предложения на <gnu-c-manual@gnu.org>.


File: gnu-c-manual.info,  Node: Lexical Elements,  Next: Data Types,  Prev: Preface,  Up: Top

1 Лексические Элементы
**********************

В этой главе описывается лексические элементы, которые составляют
исходный код Cи после предварительной обработки.  Эти элементы
называются "токены".  Есть пять типов токенов: ключевые слова,
идентификаторы, константы, операторы и разделители.  Пропуски, иногда
требуется, чтобы разделить отдельные лексемы, это всё описано в этой
главе.

* Menu:

* Identifiers:: Идентификаторы
* Keywords:: Ключевые слова
* Constants:: Константы
* Operators:: Операторы
* Separators:: Разделители
* White Space:: Пропуски


File: gnu-c-manual.info,  Node: Identifiers,  Next: Keywords,  Up: Lexical Elements

1.1 Идентификаторы
==================

Идентификаторы представляют собой последовательность символов,
используются для обозначения переменных, функций, новых типов данных и
макросов препроцессора.  Можно также включать в идентификаторы буквы,
десятичные цифры, и символ подчеркивания '_'.

   Первый символ идентификатора не может быть цифрой.

   Строчные буквы и прописные буквы различаются, так что 'foo' и 'FOO'
два разных идентификатора.

   При использовании расширений GNU, вы можете также включать символ '$'
(знак доллара) в идентификаторах.


File: gnu-c-manual.info,  Node: Keywords,  Next: Constants,  Prev: Identifiers,  Up: Lexical Elements

1.2 Ключевые Слова
==================

Ключевые слова являются специальными идентификаторами зарезервироваными
для использования в качестве части самого языка программирования.  Вы не
можете использовать их для любых других целей.

   Вот список ключевых слов признан ANSI C89:

     auto break case char const continue default do double else enum extern
     float for goto if int long register return short signed sizeof static
     struct switch typedef union unsigned void volatile while

ISO C99 добавляет следующие ключевые слова:

     inline _Bool _Complex _Imaginary

и расширение GNU добавляет эти ключевые слова:

     __FUNCTION__ __PRETTY_FUNCTION__ __alignof __alignof__ __asm
     __asm__ __attribute __attribute__ __builtin_offsetof __builtin_va_arg
     __complex __complex__ __const __extension__ __func__ __imag __imag__
     __inline __inline__ __label__ __null __real __real__
     __restrict __restrict__ __signed __signed__ __thread __typeof
     __volatile __volatile__

В обоих ISO C99 и C89 с расширениями GNU, следующее также признаётся в
качестве ключевого слова:
     restrict


File: gnu-c-manual.info,  Node: Constants,  Next: Operators,  Prev: Keywords,  Up: Lexical Elements

1.3 Константы
=============

Константа является буквальным числовым или символьным значением,
например, '5' или ''m''.  Все константы относятся к конкретному типу
данных; Вы можете использовать явное приведение типов для указания типа
константы или позволить компилятору использовать тип по умолчанию на
основе значения константы.

* Menu:

* Integer Constants:: Целочисленные Константы
* Character Constants:: Символьные Константы
* Real Number Constants:: Константы Вещественных Чисел
* String Constants:: Строковые Константы


File: gnu-c-manual.info,  Node: Integer Constants,  Next: Character Constants,  Up: Constants

1.3.1 Целочисленные Константы
-----------------------------

Целочисленная константа представляет собой последовательность цифр, с
необязательным префиксом для обозначения системы счисления.

   Если последовательности цифр предшествует '0x' или '0X' (ноль или
ноль затем X), то константа считается шестнадцатеричным (основание 16).
Шестнадцатеричные значения используют цифры от 0 до 9, а также буквы от
'a' до 'f' и от 'A' до 'F'.  Вот некоторые примеры:

     0x2f
     0x88
     0xAB43
     0xAbCd
     0x1

   Если первая цифра 0 (ноль), а следующий символ не является 'x' или
'X', то константа считается восьмеричной (основание 8).  Восьмеричные
значения могут использовать только цифры от 0 до 7, 8 и 9 не
допускаются.  Вот некоторые примеры:

     057
     012
     03
     0241

   Во всех других случаях последовательность цифр считается десятичной
константой (основание 10).  Десятичные значения могут состоять из цифр
от 0 до 9.  Ниже приведены некоторые примеры:

     459
     23901
     8
     12

   Существуют различные типы целочисленных данных, для коротких целых,
длинных целых чисел, целых чисел и целых чисел без знака.  Вы можете
заставить целую константу быть длинным типом и/или целым числом без
знака, добавив к последовательности одну или несколько букв из
следующего списка в конце константы:

'u'
'U'
     Целочисленный тип без знака.

'l'
'L'
     Длинный целочисленный тип.

   Например, '45U' является константой с типом значения 'unsigned int
(беззнаковое целочисленное)'.  Вы также можете комбинировать буквы:
'45UL' - указывает тип значения константы как 'беззнаковое длинное
целочисленное'.  (Буквы могут быть использованы в любом порядке.)

   Оба расширения ISO C99 и GNU C добавляют целочисленные типы 'long
long int' (целочисленное двойной длинны) и 'unsigned long long int'
(беззнаковое целочисленное двойной длинны).  Вы можете использовать два
'L', чтобы получить константу 'long long int'; и добавить 'U' тогда,
кода константа является 'unsigned long long int'.  Например: '45ULL'.


File: gnu-c-manual.info,  Node: Character Constants,  Next: Real Number Constants,  Prev: Integer Constants,  Up: Constants

1.3.2 Символьные Константы
--------------------------

Символьная константа, как правило, это один символ, заключенный в
одинарные кавычки, например, ''Q''.  Символьная константа имеет тип
'int' по умолчанию.

   Некоторые символы, такие как одиночная кавычка, не могут быть
представлены буквально только самим.  Для представления таких символов,
есть несколько "escape последовательностей", которые можно использовать:

'\\'
     Символ обратная косая черта.

'\?'
     Символ вопросительный знак.

'\''
     Символ одинарная кавычка.

'\"'
     Символ двойная кавычка.

'\a'
     Звуковое оповещение.

'\b'
     Символ возврата на одну позицию.

'\e'
     <ESC> символ.  (GNU расширение.)

'\f'
     Перевод страницы.

'\n'
     Символ новой строки.

'\r'
     Символ возврат каретки.

'\t'
     Символ горизонтальная табуляция.

'\v'
     Символ вертикальная табуляция.

'\o, \oo, \ooo'
     Восьмеричное число.

'\xh, \xhh, \xhhh, ...'
     Шестнадцатеричное число.

   Чтобы использовать любую из этих управляющих последовательностей,
заключите последовательность в одинарные кавычки, и относитесь к этому,
как будто это обычный другой символ.  Например, буква м является ''м'' а
символ новой строки - это ''\n''.

   Восьмеричная escape-последовательность - это символ обратной косой
черты, за которым следует один, два или три восьмеричных цифры (от 0 до
7).  Так, например, 101 восьмеричный эквивалент 65, который является
ASCII-символом ''A''.  Таким образом, символьная константа ''101''
является тем же внутренним значением, что и символьная константа ''A''.

   Шестнадцатеричная escape-последовательность состоит из символа
обратной косой черты, за которым следует 'x' и неограниченное количество
шестнадцатеричных цифр (цифры от 0 до 9, и букв от 'a' до 'f' и от 'A'
до 'F').

   В то время как возможная длина строки шестнадцатеричных цифр не
ограничена, количество символьных констант, в любом заданном наборе
символов, ограничено.  (Широко используется расширенный набор ASCII
символов, он например, имеет в составе только 256 символов.)  Если
попытаться использовать шестнадцатеричное значение, которое находится
вне диапазона символов, получиться ошибка компиляции.


File: gnu-c-manual.info,  Node: Real Number Constants,  Next: String Constants,  Prev: Character Constants,  Up: Constants

1.3.3 Константы Вещественных Чисел
----------------------------------

Константа вещественного числа является значением, которое представляет
собой дробное (с плавающей точкой) число.  Состоит из последовательности
цифр, которые представляет собой целое число (или) "целую" часть числа,
десятичную точку, и последовательность цифр, которые представляет собой
дробную часть числа.

   Часть числа, целая или дробная часть, может быть опущена, но не обе
сразу.  Вот несколько примеров:

     double a, b, c, d, e, f;

     a = 4.7;

     b = 4.;

     c = 4;

     d = .7;

     e = 0.7;

(В третьем операторе присваивания, целая константа 4, автоматически
преобразуется из целочисленного значения в тип значения числа с
плавающей точкой.)

   Константа вещественного числа, также может дополнятся 'e' или 'E'
целочисленным показателем.  Показатель может быть положительным или
отрицательным.

     double x, y;

     x = 5e2;   /* 'x' is 5 * 100, or 500.0. */
     y = 5e-2;  /* 'y' is 5 * (1/100), or 0.05. */

   Можно добавить букву в конце константы представляющей вещественное
число, чтобы определить её тип.  Если добавить букву F (или f) к
константе вещественоого числа, то её тип будет 'float'.  Если добавить
букву L (или l), то её тип станет 'long double'.  Если не добавлено
никаких букв, то её тип будет 'double'.


File: gnu-c-manual.info,  Node: String Constants,  Prev: Real Number Constants,  Up: Constants

1.3.4 Строковые Константы
-------------------------

Строковая константа представляет собой последовательность из нуля или
более символов, цифр и управляющих последовательностей, заключенных в
двойные кавычки.  Строковая константа имеет тип "массив символов".  Все
строковые константы содержат завершающий нулевой символ ('\0') в
качестве последнего символа.  Строки хранятся в виде массива символов,
без неотъемлемого атрибута размера.  Завершающий нулевой символ
позволяет строковым функциям при обработке знать, где строка
заканчивается.

   Смежные строковые константы сцепляются (объединяются) в одну строку,
путём добавления нулевого символа завершения в конец завершающей
объединение строки.

   Строка не может содержать двойные кавычки, поскольку сама строка
заключена в двойные кавычки.  Чтобы включить символ двойной символ
кавычки в строку, используется escape-последовательность '\"'.  Можно
использовать любую из escape-последовательностей в качестве символьных
констант в строках.  Вот некоторые примеры строковых констант:

     /* Это одностроковая константа. */
     "Тутти Фрутти мороженое"

     /* Эти строковые константы будут сцеплены, так, как описано выше. */
     "Тутти " "Фрутти" " мороженное "

     /* Здесь используются две escape-последовательности. */
     "\"привет, мир!\""

Если строка слишком длинная, чтобы поместиться на одной строке, можно
использовать обратную косую '\', чтобы разбить её на отдельные строки.

     "Сегодня особый бутерброд на ржаном хлебе \
     с картофельными котлетами и вишневой содой."

Смежные строки автоматически объединяются, так что вы можете иметь
строковые константы на нескольких строка, записывая их в виде отдельных,
смежных, строк.  Например:

     "Специальный завтрак - сендвич с солониной говядины на хлебе "
     "из грубой ржаной муки и манной кашей из сельтерской воды."

тоже самое от записи

     "Специальный завтрак - сендвич с солониной говядины на хлебе \
     из грубой ржаной муки и манной кашей из сельтерской воды."

   Для того, чтобы вставить символ новой строки в строку, так чтобы, при
печати строки, она выводилась на двух различных строках, можно
использовать символ escape-последовательности новая строка '\n'.

     printf ("картофельная\nкотлета");

prints

     картофельная
     котлета


File: gnu-c-manual.info,  Node: Operators,  Next: Separators,  Prev: Constants,  Up: Lexical Elements

1.4 Операторы
=============

Оператор является специальным маркером, который выполняет операцию,
например, сложение или вычитание, с одним, двумя или тремя операндами.
Описание всех операторов можно найти в следующей главе.  *Note
Expressions and Operators::.


File: gnu-c-manual.info,  Node: Separators,  Next: White Space,  Prev: Operators,  Up: Lexical Elements

1.5 Сепараторы
==============

Сепаратор отделяет операторы.  Пробел (смотри следующий раздел) является
сепаратором для операторов.  Все остальные сепараторы - это
односимвольные операторы:

     ( ) [ ] { } ; , . :


File: gnu-c-manual.info,  Node: White Space,  Prev: Separators,  Up: Lexical Elements

1.6 Пробелы
===========

Пробел - это собирательный термин, использующийся для нескольких
символов: символ пробела, символ табуляции, символ новой строки,
вертикальная табуляция и символ перевода страницы.  Пробелы игнорируются
(вне строковых и символьных констант), и, следовательно, по желанию, за
исключением случаев, когда они используется для разделения операторов.
Это значит, что

     #include <stdio.h>

     int
     main()
     {
       printf( "привет, мир\n" );
       return 0;
     }

and

     #include <stdio.h> int main(){printf("привет, мир\n");
     return 0;}

функционально одна и та же программа.

   Хотя требуется использовать символы пробела для разделения нескольких
операторов, пробелы не требуется между операторами и операндами, ровно
так же не требуется установка пробела между несколькими сепараторами и
между тем, что они разделяют.

     /* Все записи являются допустимыми. */

     x++;
     x ++ ;
     x=y+z;
     x = y + z ;
     x=array[2];
     x = array [ 2 ] ;
     fraction=numerator / *denominator_ptr;
     fraction = numerator / * denominator_ptr ;

Кроме того, там, где допускается один пробел, допускается также и любое
количество пробелов.

     /* Эти два утверждения функционально идентичны. */
     x++;

     x
            ++       ;

   В строковых константах, пробелы и табуляции не игнорируются; скорее,
они являются частью строки.  Следовательно,

     "картофельная котлета"

это не то же самое

     "картофельная                         котлета"


File: gnu-c-manual.info,  Node: Data Types,  Next: Expressions and Operators,  Prev: Lexical Elements,  Up: Top

2 Типы Данных
*************

* Menu:

* Primitive Types:: Примитивные Типы Данных
* Enumerations:: Перечисления
* Unions:: Объединения
* Structures:: Структуры
* Arrays:: Массивы
* Pointers:: Указатели
* Incomplete Types:: Неполные Типы
* Type Qualifiers:: Квалификаторы Типов
* Storage Class Specifiers:: Спецификаторы Классов Хранения
* Renaming Types:: Переименование Типов


File: gnu-c-manual.info,  Node: Primitive Types,  Next: Enumerations,  Up: Data Types

2.1 Примитивные Типы Данных
===========================

* Menu:

* Integer Types:: Целочисленные Типы
* Real Number Types:: Типы Действительных Чисел
* Complex Number Types:: Типы Комплексных Чисел


File: gnu-c-manual.info,  Node: Integer Types,  Next: Real Number Types,  Up: Primitive Types

2.1.1 Целочисленные Типы
------------------------

Целочисленный тип данных имеет размер в диапазоне от, по меньшей мере, 8
битов, до по меньшей мере, 32 битов.  Стандарт C99 расширяет этот
диапазон, чтобы включать в себя целые числа, размеры которых, по меньшей
мере, 64 бита.  Вы должны использовать целые типы для хранения значений
целых чисел (и типа данных 'char' для хранения символов).  Минимальные
размеры и диапазоны, приведенны для этих типов; в зависимости от вашей
компьютерной платформы, эти размеры и диапазоны могут быть больше но
никак не меньше.

   В то время как эти диапазоны обеспечивают естественный порядок,
стандарт не требует, чтобы любые два типа имели различный диапазон.
Например, 'int' и 'long' могут иметь один и тот же диапазон.  Стандарт
позволяет даже 'signed char' и 'long' иметь тот же диапазон, хотя такие
платформы очень необычны.

   * 'signed char'
     8-битный 'signed char' тип данных может содержать целые значения в
     диапазоне от -128 до 127.

   * 'unsigned char'
     8-битный 'unsigned char' тип данных может содержать целые значения
     в диапазоне от 0 до 255.

   * 'char'
     В зависимости от системы, тип данных 'char' определяются как
     имеющий один и тот же диапазон, либо 'signed char', либо 'unsigned
     char' типа данных (хотя это три различных типа, однако).  По
     соглашению, вы должны использовать тип данных 'char' специально для
     хранения ASCII символов (например, '`m''), в том числе управляющих
     последовательностей (таких как '`\n'').

   * 'short int'
     16-битный 'short int' тип данных может содержать целые значения в
     диапазоне от -32,768 до 32,767.  Вы можете также обратиться к этому
     типу данных, как 'short', 'signed short int', или 'signed short'.

   * 'unsigned short int'
     16-битный 'unsigned short int' тип данных может содержать целые
     значения в диапазоне от 0 до 65,535.  Вы можете также обратиться к
     этому типу данных, как к 'unsigned short'.

   * 'int'
     32-битный 'int' тип данных может содержать целые значения в
     диапазоне от -2,147,483,648 до 2,147,483,647.  Вы можете также
     обратиться к этому типу данных, как к 'signed int' или 'signed'.

   * 'unsigned int'
     32-битный 'unsigned int' тип данных может содержать целые значения
     в диапазоне от 0 до 4,294,967,295.  Вы можете также обратиться к
     этому типу данных просто как к 'unsigned'.

   * 'long int'
     32-битный 'long int' тип данных может содержать целые значения в
     диапазоне, по меньшей мере, от -2,147,483,648 до 2,147,483,647.  (В
     зависимости от вашей системы, этот тип данных может быть 64-бит, в
     этом случае его диапазон идентичен типу 'long long int' данных.).
     Вы можете также обратиться к этому типу данных, как к 'long',
     'signed long int', или к 'signed long'.

   * 'unsigned long int'
     32-битный 'unsigned long int' тип данных может содержать целые
     значения в диапазоне, по меньшей мере, от 0 до 4,294,967,295.  (В
     зависимости от вашей системы, этот тип данных может быть 64-бит, в
     этом случае его диапазон идентичен типу 'unsigned long long int'
     данных.).  Вы можете также обратиться к этому типу данных, как к
     'unsigned long'.

   * 'long long int'
     64-битный 'long long int' тип данных может содержать целые значения
     в диапазоне от -9,223,372,036,854,775,808 до
     9,223,372,036,854,775,807.  Вы можете также обратиться к этому типу
     данных, как к 'long long', 'signed long long int' или 'signed long
     long'.  Этот тип не является частью C89, идёт как часть C99 и
     расширение GNU Cи.

   * 'unsigned long long int'
     64-битный 'unsigned long long int' тип данных может содержать целые
     значения в диапазоне, по меньшей мере, от 0 до
     18,446,744,073,709,551,615.  Вы можете также обратиться к этому
     типу данных, как к 'unsigned long long'.  Этот тип не является
     частью C89, идёт как часть C99 и расширение GNU Cи.

   Вот некоторые примеры объявления и определения целочисленных
переменных:

     int foo;
     unsigned int bar = 42;
     char quux = 'a';

Первая строка объявляет целое с именем 'foo', но не определяет его
значение; оно остается не инициализированым, и его значение не следует
считать, как нечто конкретное.


File: gnu-c-manual.info,  Node: Real Number Types,  Next: Complex Number Types,  Prev: Integer Types,  Up: Primitive Types

2.1.2 Типы Действительных Чисел
-------------------------------

Есть три типа данных, которые представляют дробные числа.  Хотя размеры
и диапазоны этих типов соответствуют в большинстве компьютерных систем,
используемых сегодня, исторически размеры этих типов варьируется от
системы к системе.  Таким образом, минимальные и максимальные значения
сохраняются в макроопределениях в библиотеке заголовочного файл
'float.h'.  В этом разделе, мы включаем имена макроопределений в месте
их возможными значениями; проверте 'float.h' вашей системы для
определенных чисел.

   * 'float'
     'float' тип данных является самым маленьким из трех типов с
     плавающей точкой, если они различаются по размеру вообще.  Его
     минимальное значение хранится в 'FLT_MIN', и не должно быть больше,
     чем '1e-37'.  Его максимальное значение сохраняется в 'FLT_MAX', и
     должно быть не менее '1e37'.

   * 'double'
     'double' тип данных, по меньшей мере, столь же большой как и тип
     'float', но может быть большим.  Его минимальное значение хранится
     в 'DBL_MIN', а его максимальное значение хранится в 'DBL_MAX'.

   * 'long double'
     'long double' тип данных, по меньшей мере, столь же большой как и
     тип 'float', и может быть большим.  Его минимальное значение
     хранится в 'LDBL_MIN', а его максимальное значение хранится в
     'LDBL_MAX'.

Все типы данных с плавающей запятой подписаны; пытаясь использовать
'unsigned float', например, вызовет ошибку компиляции.

   Вот некоторые примеры объявления и определения в переменных
действительных чисел:

     float foo;
     double bar = 114.3943;

Первая строка объявляет переменную с типом чило с плавающей точкой и
именем 'foo', но не определяет её значение; она остается не
инициализированой, и её значение не следует учитывать как нечто
конкретное.

   Типы вещественного числа, представленные в Cи, являются числами с
конечной точностью, и, соответственно, не все действительные числа могут
быть представлены точно.  Большинство компьютерных систем, которые GCC
компилирует используют бинарное представление для действительных чисел,
которое не в состоянии точно представлять числа, такие, как, например,
4,2.  По этой причине, мы рекомендуем вам не сравнивать действительные
числа для точного равенства использовать оператор '==', а проверить, что
действительные числа находятся в пределах допустимого отклонения.

   Есть другие, более тонкие последствия этих неточных представлений;
для получения более подробной информации смотреть очерки бумаг Дэвида
Голдберга 'Что каждый компьютерный ученый должен знать о арифменике с
плавающей точкой' в секции 4.2.2 Дональда Кнута 'Искусство Компьютерного
Программирования'.


File: gnu-c-manual.info,  Node: Complex Number Types,  Prev: Real Number Types,  Up: Primitive Types

2.1.3 Типы Комплексных Чисел
----------------------------

GCC ввел некоторые типы комплексных чисел как расширение C89.
Аналогичные функции были введены в C99(1), но существует ряд отличий.
Сначала мы опишем стандартные типы комплексных чисел.

* Menu:

* Standard Complex Number Types:: Стандартные типы Комплексных Чисел
* GNU Extensions for Complex Number Types:: GNU Расширение для Типов Комплексных Чисел

   ---------- Footnotes ----------

   (1) C++ также имеет поддержку комплексных чисел, но она не совместима
с типами ISO C99.


File: gnu-c-manual.info,  Node: Standard Complex Number Types,  Next: GNU Extensions for Complex Number Types,  Up: Complex Number Types

2.1.3.1 Стандартные типы Комплексных Чисел
..........................................

Комплексные типы были введены в C99.  Есть три комплексных типа:

     'float _Complex'
     'double _Complex'
     'long double _Complex'

   Имена здесь начинаются с символом подчеркивания и заглавной буквой,
чтобы избежать конфликтов с идентификаторами уже существующих программ.
Стандартный файл заголовка '<complex.h>' C99 вводит некоторые макросы,
которые делают использование сложных типов проще.

     'complex'
     Расширяется до '_Complex'.  Это позволяет переменной быть
     объявленой ​​как 'double complex', что кажется более естественным.

     'I'
     Константа типа 'const float _Complex', имеющая значение мнимой
     единицы i.

   '<complex.h>' заголовочный файл также объявляет ряд функций для
выполнения вычислений с комплексными числами, например, функциями
'creal' и 'cimag' которые, соответственно, возвращают действительные и
мнимые части числа 'double complex'.  Также предусмотрены и другие
функции, как показано в следующем примере:

     #include <complex.h>
     #include <stdio.h>

     void example (void)
     {
       complex double z = 1.0 + 3.0*I;
       printf ("Phase is %f, modulus is %f\n", carg (z), cabs (z));
     }


File: gnu-c-manual.info,  Node: GNU Extensions for Complex Number Types,  Prev: Standard Complex Number Types,  Up: Complex Number Types

2.1.3.2 GNU Расширение для Типов Комплексных Чисел
..................................................

GCC также введены комплексные типы, как расширение GNU для C89, но
написание отличается.  Комплексные типы с плавающей точкой в
​​расширении C89 GCC являются:

     '__complex__ float'
     '__complex__ double'
     '__complex__ long double'

   Расширение GCC' позволяет использовать комплексные типы, в отличии от
типов с плавающей точкой, для объявления целочисленных комплексных
типов, так что вы можете объявить комплексные символьные и комплексные
целочисленные типы; на самом деле '__complex__' может быть использован с
любым из примитивных типов данных.  Мы не дадим вам полный список всех
возможностей, но вот некоторые примеры:

   * '__complex__ float'
     '__complex__ float' тип данных имеет два компонента: реальную часть
     и мнимую часть, обе из которых относятся к типу данных 'float'.

   * '__complex__ int'
     Тип данных '__complex__ int' также имеет два компонента: реальную
     часть и мнимую часть, обе из которых относятся к типу данных 'int'.

   Для того, чтобы извлечь действительную часть комплексного числа,
используйте ключевое слово '__real__', затем выражение.  Кроме того,
используйте '__imag__' чтобы извлечь мнимую часть.

     __complex__ float a = 4 + 3i;

     float b = __real__ a;          /* 'b' это 4. */
     float c = __imag__ a;          /* 'c' это 3. */

   Этот пример создает переменную 'a' типа комплексное число с плавающей
точкой , и определяет её реальную часть, как 4 и мнимую часть, как 3.
Далее действительная часть значения переменной присваивается переменной
типа число с плавающей точкой 'b', а мнимая часть этого значения,
присваивается переменной 'c' типа числа с плавающей точкой.


File: gnu-c-manual.info,  Node: Enumerations,  Next: Unions,  Prev: Primitive Types,  Up: Data Types

2.2 Перечисления
================

Перечисление представляет собой тип пользовательских данных,
используемый для хранения постоянных целочисленных значений, и обращения
к ним по именам.  По умолчанию эти значения имеют тип 'signed int'.
Однако, вы можете использовать опцию компилятора GCC '-fshort-enums' для
использования типа наименьшего возможного числа, который будет
использоваться вместо этого.  Оба эти поведения соответствуют стандарту
C89, но смешанное использование этих вариантов в рамках одной и той же
программы может привести к несовместимости.

* Menu:

* Defining Enumerations:: Определение Перечисления
* Declaring Enumerations:: Объявление Перечисления


File: gnu-c-manual.info,  Node: Defining Enumerations,  Next: Declaring Enumerations,  Up: Enumerations

2.2.1 Определение Перечисления
------------------------------

Определяется перечисление с помощью 'enum' ключевого слова, за которым
следует имя перечисления (это необязательно), за которым следует список
имен констант (разделенных запятыми и заключены в фигурные скобки), и
заканчивается точкой с запятой.

     enum фрукты {виноград, вишня, лимон, киви};

   Этот пример определяет перечисление, 'фрукты', которое содержит
четыре постоянных целых значения, 'виноград', 'вишня', 'лимон' и 'киви',
чьи значения по умолчанию, 0, 1, 2 и 3, соответственно.  Вы также можете
указать один или несколько значений в явном виде:

     enum ешё_фрукты {банан = -17, яблоко, черника, манго};

   Этот пример определяет 'банан' как -17, а остальные значения
увеличиваются на 1: 'яблоко' является -16, 'черника' является -15 и
'манго' является -14.  Если не указано иное, значение перечисления равно
на один больше, чем предыдущее значение (и первое значение по умолчанию
равно 0).

   Вы также можете обратиться к значению перечисления, определенное
ранее в том же перечислении:

     enum вот_ещё_фрукты {кумкват, малина, персик,
                          слива = персик + 2};

   В этом примере, 'кумкват' устанавливается в 0, 'малина' в 1, 'персик'
в 2, и 'слива' в 4.

   Вы не можете использовать одно и тоже имя для перечисления 'enum' как
'struct' или 'union' в той же области.  (ВопросTypes439)


File: gnu-c-manual.info,  Node: Declaring Enumerations,  Prev: Defining Enumerations,  Up: Enumerations

2.2.2 Объявление Перечисления
-----------------------------

Вы можете объявлять переменные типа перечисления как при определении
перечисления так и позже.  Этот пример объявляет одну переменную с
именем 'мои_фрукты' типа 'enum фрукты', все в одном заявлении:

     enum фрукты {банан, яблоко, черника, манго} мои_фрукты;

в то время как в этом примере объявляется тип и переменная отдельно:

     enum фрукты {банан, яблоко, черника, манго};
     enum фрукты мои_фрукты;

   (Конечно, вы не смогли бы объявить так, не объявив вначале
перечисление 'фрукты'.)

   Хотя такие переменные относятся к типу перечисления, вы можете
присвоить им любое значение, которое вы могли бы присвоить переменной
типа 'int', включая значение других перечислений.  Кроме того, любой
переменной, которая может быть назначено значение типа 'int' может быть
присвоено значение из перечисления.

   Тем не менее, вы не можете изменить значение в перечислении, как
только оно был определено; они являются константыми значениями.
Например, это не будет работать:

     enum фрукты {банан, яблоко, черника, манго};
     банан = 15;  /* Вы не можете сделать это! */

   Перечисления могут быть использованы в сочетании с оператором
'switch', потому что компилятор может предупредить вас, если вы не
смогли обработать одно из значений перечисления.  Используя пример выше,
если ваш код обрабатывает только 'банан', 'яблоко' и 'манго', без
'черника', GCC может генерировать предупреждение.


File: gnu-c-manual.info,  Node: Unions,  Next: Structures,  Prev: Enumerations,  Up: Data Types

2.3 Объединения
===============

Объединение представляет собой тип пользовательских данных, используемый
для хранения нескольких переменных в одном и том же пространстве памяти.
Хотя вы можете получить доступ к любой из этих переменных в любое время,
вы должны читать только по одной из них в одно и то же время --
присвоения одного значения перезаписывает значения другой.
(ВопросTypes503)

* Menu:

* Defining Unions:: Определение Объединения
* Declaring Union Variables:: Объявление Переменных Объединения
* Accessing Union Members:: Доступ к Элементам Объединения
* Size of Unions:: Размер Объединений


File: gnu-c-manual.info,  Node: Defining Unions,  Next: Declaring Union Variables,  Up: Unions

2.3.1 Определение Объединения
-----------------------------

Вы определяете объединение, используя ключевое слово 'union' с
последующим объявлением элементов объединения, заключенные в фигурные
скобки.  Вы объявляете каждый элемент объединения так же, как вы обычно
объявляете переменную -- используя тип, данных за которым следует одно
или несколько имён переменных, разделенных запятыми, и заканчиваете
точкой с запятой.  Затем заканчиваете определение объединения точкой с
запятой после закрывающей скобки.

   Вы должны также включить имя для объединения между 'union' ключевым
словом и открывающей скобкой.  Это синтаксически не обязательно, но если
вы не укажите имя, вы не можете обратиться к этому типу данных
объединения в дальнейшем в программе (без 'typedef', *note The typedef
Statement::).

   Ниже приведен пример определения простого объединения для сохранения
целого числа и числа с плавающей точкой:

     union числа
       {
         int i;
         float f;
       };

   Это определяет объединение с именем 'числа', которое содержит два
элементачлена, 'i' и 'f', которые имеют тип 'int' и 'float'
соответственно.


File: gnu-c-manual.info,  Node: Declaring Union Variables,  Next: Accessing Union Members,  Prev: Defining Unions,  Up: Unions

2.3.2 Объявление Переменных Объединения
---------------------------------------

Вы можете объявлять переменные типа объединения, как при первоначальном
определении объединения, так и после его определения, если вы дали
объединению имя.

* Menu:

* Declaring Union Variables at Definition:: Объявление Переменных Объединения при Определении
* Declaring Union Variables After Definition:: Объявление Переменных Объединения После его Определения
* Initializing Union Members:: Инициализация Членов Объединения


File: gnu-c-manual.info,  Node: Declaring Union Variables at Definition,  Next: Declaring Union Variables After Definition,  Up: Declaring Union Variables

2.3.2.1 Объявление Переменных Объединения при Определении
.........................................................

Вы можете объявлять переменные типа объединения, когда вы определяете
тип объединения, помещая имена переменных после закрывающей скобки
определения объединения, но до завершающей точки с запятой.  Вы можете
объявить более чем одну такую ​​переменную, разделяя их запятыми.

     union числа
       {
         int i;
         float f;
       } первое_число, второе_число;

   Этот пример объявляет две переменные типа 'union числа',
'первое_число' и 'второе_число'.


File: gnu-c-manual.info,  Node: Declaring Union Variables After Definition,  Next: Initializing Union Members,  Prev: Declaring Union Variables at Definition,  Up: Declaring Union Variables

2.3.2.2 Объявление Переменных Объединения После его Определения
...............................................................

Вы можете объявлять переменные типа объединение после того, как вы
определили объединение, используя 'union' ключевое слово и имя, которое
вы задали типу объединения, за которым следует одно или несколько имен
переменных, разделенных запятыми.

     union числа
       {
         int i;
         float f;
       };
     union числа первое_число, второе_число;

   Этот пример объявляет две переменные типа 'union числа',
'первое_число' и 'второе_число'.


File: gnu-c-manual.info,  Node: Initializing Union Members,  Prev: Declaring Union Variables After Definition,  Up: Declaring Union Variables

2.3.2.3 Инициализация Членов Объединения
........................................

Вы можете инициализировать первый элемент переменной объявления при его
объявлении:

     union числа
       {
         int i;
         float f;
       };
     union числа первое_число = { 5 };

   В этом примере элемент 'i' в переменной 'первое_число' получает
значение 5, а элемент 'f' остаётся с недействительным значением.

   Другой способ инициализации элемента объединения - это явно указать
имя нужного элемента для инициализации.  Таким образом, вы можете
инициализировать тот элемент который хотите, а не только первый.  Есть
два способа, которые можно использовать -- либо имя элемента с
двоеточием, а затем его значение, например:

     union числа первое_число = { f: 3.14159 };

или предварить имя элемента объединения точкой и присвоить ему значение
с помощью оператора присваивания, как здесь:

     union числа первое_число = { .f = 3.14159 };

   Вы также можете инициализировать элемент объединения при объявлении
переменной объединения во время её определения:

     union числа
       {
         int i;
         float f;
       } первое_число = { 5 };


File: gnu-c-manual.info,  Node: Accessing Union Members,  Next: Size of Unions,  Prev: Declaring Union Variables,  Up: Unions

2.3.3 Доступ к Элементам Объединения
------------------------------------

Вы можете получить доступ к элементам переменной объединения с помощью
оператора доступа к элементу.  Вы помещаете имя переменной объединения
на левой стороне оператора, а имя элемента объединения с правой стороны.

     union числа
       {
         int i;
         float f;
       };
     union числа первое_число;
     первое_число.i = 5;
     первое_число.f = 3.9;

   Обратите внимание, в этом примере, что переопределяются значения как
элемента 'f' так и хранящееся в элементе 'i'.  (ВопросTypes697)


File: gnu-c-manual.info,  Node: Size of Unions,  Prev: Accessing Union Members,  Up: Unions

2.3.4 Размер Объединений
------------------------

Размер объединения равен размеру его наибольшего элемента.  Рассмотрим
первый пример объединения из этого раздела:

     union числа
       {
         int i;
         float f;
       };

Размер типа данных этого объединения такой же, как при определении
'sizeof (float)', так самый большой тип у элементов этого объединения
это 'float'.  Поскольку все элементы объединения расположены в одном и
том же пространстве памяти, размер типа данных объединения, не должен
расчитываться на возможность помещения суммы сразу всех типов элементов,
а должен быть достаточно большим, чтобы вместить самый большой из типов
содержащихся элементов.  (ВопросTypes729)


File: gnu-c-manual.info,  Node: Structures,  Next: Arrays,  Prev: Unions,  Up: Data Types

2.4 Структуры
=============

Структура - это определяемый программистом тип данных, состоящий из
переменных других типов данных (в том числе, возможно, другие типы
структур).

* Menu:

* Defining Structures:: Определение Структур
* Declaring Structure Variables:: Объявление Переменных Структуры
* Accessing Structure Members:: Доступ к Элементам Структуры
* Bit Fields:: Битовы Поля
* Size of Structures:: Размер Cтруктур


File: gnu-c-manual.info,  Node: Defining Structures,  Next: Declaring Structure Variables,  Up: Structures

2.4.1 Определение Структур
--------------------------

Вы определяете структуру, используя ключевое слово 'struct' с
последующим объявлением элементов структуры, заключенных в скобки.  Вы
объявляете каждый элемент структуры так же, как вы обычно объявляете
переменную -- используя тип данных за которым следует одно или несколько
имён переменных, разделенных запятыми, и заканчиваете точкой с запятой.
Затем завершение определения структуры с точкой с запятой после
закрывающей скобки.

   Вы должны также включать включить имя структуры между 'struct'
ключевым словом и открывающей скобкой.  Это необязательно, но если вы
опустите имя, не сможетемпотом обратиться к этому типу структуры данных
(без 'typedef', *note The typedef Statement::).

   Ниже приведен пример определения простой структуры для хранения
координат х и у точки:

     struct точка
       {
         int x, y;
       };

   Это определяет тип структуры с именем 'struct точка', которая
содержит два элемента 'x' и 'y', оба из которых имеют тип 'int'.

   Структуры (и объединения) могут содержать экземпляры других структур
и объединений, но, конечно, не самих себя.  Вполне возможно, для типов
структуры или объединения, содержать поле, которое является указателем
на тот же тип стркутуры (*note Incomplete Types::).


File: gnu-c-manual.info,  Node: Declaring Structure Variables,  Next: Accessing Structure Members,  Prev: Defining Structures,  Up: Structures

2.4.2 Объявление Переменных Структуры
-------------------------------------

Можно объявлять переменные типа структуры, когда определяется тип
структуры и после её определения, если задано имя структуре.

* Menu:

* Declaring Structure Variables at Definition:: Определение Переменной Структуры в Объявлении
* Declaring Structure Variables After Definition:: Определение Переменных Структур После Объявления
* Initializing Structure Members:: Инициализация Элементов Структуры


File: gnu-c-manual.info,  Node: Declaring Structure Variables at Definition,  Next: Declaring Structure Variables After Definition,  Up: Declaring Structure Variables

2.4.2.1 Определение Переменной Структуры в Объявлении
.....................................................

Можно объявлять переменные типа структуры, когда определяется тип
структуры, поместив имена переменных после закрывающей скобки
определения структуры, но до заключительной точки с запятой объявления.
можете объявить более чем одну такую ​​переменную, разделив их запятыми.

     struct точка
       {
         int x, y;
       } первая_точка, вторая_точка;

   Этот пример объявляет две переменные типа 'struct точка',
'первая_точка' и 'вторая_точка'.


File: gnu-c-manual.info,  Node: Declaring Structure Variables After Definition,  Next: Initializing Structure Members,  Prev: Declaring Structure Variables at Definition,  Up: Declaring Structure Variables

2.4.2.2 Определение Переменных Структур После Объявления
........................................................

Можно объявлять переменные типа структуры после определения структуры,
используя ключевое слово 'struct' и имя типа структуры, за которым
следует одно или несколько имен переменных, разделенных запятыми.

     struct точка
       {
         int x, y;
       };
     struct point первая_точка, вторая_точка;

   Этот пример объявляет две переменные типа 'struct точка',
'первая_точка' и 'втора_точка'.


File: gnu-c-manual.info,  Node: Initializing Structure Members,  Prev: Declaring Structure Variables After Definition,  Up: Declaring Structure Variables

2.4.2.3 Инициализация Элементов Структуры
.........................................

Можно инициализировать элемент типа структуры при определеннии
переменной структуры, нужным значением.

   Если не инициализировать переменную структуры, эффект зависит от
того, имеет ли она статическое хранение (*note Storage Class
Specifiers::) или нет.  Если да, то элементы с целочисленными типами
инициализируются значением 0 а элементы с типом указатель
инициализируются значением NULL; в противном случае, значение элементов
структуры является неопределенным.

   Один из способов, чтобы инициализировать структуру - это указать
значения разделённые запятыми внутри фигурных скобок.  Эти значения
присваиваются элементам структуры в том же порядке, в котором они
объявлены в объявлении структуры.

     struct точка
       {
         int x, y;
       };
     struct точка первая_точка = { 5, 10 };

   В этом примере элемент 'x' структуры 'первая_точка' получает значение
5, а элемент структуры 'y' получает значение 10.

   Другой способ инициализации элементов - это указать имя элемента для
инициализации.  Таким образом, можно инициализировать элементы в любом
порядке, и даже оставить некоторые из них не инициализироваными.  Есть
два метода, которые можно использовать.  Первый метод доступен в C99 и
как расширение C89 в GCC:

     struct точка первая_точка = { .y = 10, .x = 5 };

   Кроме того, можно опустить точку и использовать вместо этого
двоеточие вместо символа '=', хотя это расширение GNU C:

     struct точка первая_точка = { y: 10, x: 5 };

   Можно инициализировать элементы переменной типа структура, при
объявлении переменной в процессе определения структуры:

     struct точка
       {
         int x, y;
       } первая_точка = { 5, 10 };

   Кроме того, можно также опустить инициализацию некоторых элементов
переменной структуры:

     struct точка
       {
         int x, y;
         char *p;
       };
     struct pointy первая_точка = { 5 };

   Здесь 'x' устанавливается в 5, 'y' устанавливается в 0, и 'p'
инициализируется NULL. Здесь правило предписывает то, что 'y' и 'p'
инициализируются так же, как если бы они были статическими переменными.

   Вот еще один пример, который инициализирует элемент структуры,
который является сам переменной структуры:

     struct точка
       {
         int x, y;
       };

     struct прямоугольник
       {
         struct точка верхняя_левая, правая_нижняя;
       };

     struct прямоугольник мой_прямоугольник = { {0, 5}, {10, 0} };

   Этот пример определяет структуру 'прямоугольник' состоящую из двух
элементов переменных структуры 'точка'.  Затем объявляется одна
переменная типа 'struct прямоугольник' и инициализируются её элементы.
Поскольку ее элементы являются переменными с типом структура,
используется дополнительный набор скобок, окружающих элементы, которые
принадлежат к переменным структура 'точка'.  Тем не менее, эти
дополнительные скобки не требуются обязательно; они используются чтобы
человеку легче было читать код.


File: gnu-c-manual.info,  Node: Accessing Structure Members,  Next: Bit Fields,  Prev: Declaring Structure Variables,  Up: Structures

2.4.3 Доступ к Элементам Структуры
----------------------------------

Можно получить доступ к членам переменной структуры с помощью оператора
доступа к элементу 'ТОЧКА'.  Вы помещаете имя переменной структуры на
левой стороне оператора 'ТОЧКА', а имя элемента с правой стороны.

     struct точка
       {
         int x, y;
       };

     struct точка первая_точка;

     первая_точка.x = 0;
     первая_точка.y = 5;

   Также можно получить доступ к элементу переменной структуры, которая
сама является элементом переменной структуры.

     struct прямоугольник
       {
         struct точка верхняя_левая, нижняя_правая;
       };

     struct прямоугольник мой_прямоугольник;

     мой_прямоугольник.верхняя_левая.x = 0;
     мой_прямоугольник.верхняя_левая.y = 5;

     мой_прямоугольник.нижняя_правая.x = 10;
     мой_прямоугольник.нижняя_правая.y = 0;


File: gnu-c-manual.info,  Node: Bit Fields,  Next: Size of Structures,  Prev: Accessing Structure Members,  Up: Structures

2.4.4 Битовы Поля
-----------------

Можно создавать структуры с целочисленными элементами нестандартных
размеров, называемые _битовыми полями_.  Можно сделать это, указав
целочисленный элемент ('int', 'char', 'long int'), как обычно, и вставив
далее двоеточие, а затем число бит, которое элемент должен занимать и
затем завершающую точку с запятой.

     struct карта
       {
         unsigned int масть : 2;
         unsigned int старшенство : 4;
       };

   Этот пример определяет тип структуры с двумя битовыми полями, 'масть'
и 'старшенство', которые занимают 2 и 4 бита соответственно.  'suit'
может содержать значение от 0 до 3, и 'старшинство' может содержать
значение от 0 до 15.  Обратите внимание, что эти битовые поля были
объявлены как тип 'unsigned int'; если бы они были определенены обычно
как целочисленные, то их диапазон был бы от -2 до 1 и от -8 до 7,
соответственно.

   В более общем смысле, диапазон беззнакового битового поля из N бит
составляет от 0 до 2^N - 1, а диапазон знакового битового поля
составляет N бит от -(2^N) / 2 до ((2^N) / 2) - 1.

   Битовые поля могут быть указаны без имени, в целях контроля, какие
биты используются фактически внутри содержащего блока.  Однако, эффект
от этого не очень переносим, и это редко бывает полезным.  Можно
установить битовое поле размером в 0, что указывает, что последующие
битовые поля - это не дополнительные битовые поля и должны быть
упакованы в блок, содержащий предыдущее битовое поле.  Это также как
правило, не полезно.

   Нет возможности взять адрес битового поля сиспользованием оператора
взятия адреса '&' (*note Pointer Operators::).  (ВопросTypes1062)


File: gnu-c-manual.info,  Node: Size of Structures,  Prev: Bit Fields,  Up: Structures

2.4.5 Размер Cтруктур
---------------------

Размер типа структуры равен сумме размеров всех её членов, и возможно,
включая дополненин, чтобы обеспечить типу структуры выравнивание до
определенной границы байта.  Детали различаются в зависимости от
компьютерной платформы, но будет нетипичным, увидеть структуры
дополненные до выравнивания на четырёх- или восемь байтовых границах.
Это делается для того, чтобы ускорить доступ в памяти к экземплярам типа
структуры.  (ВопросTypes1074)

   В качестве расширения GNU, GCC позволяет создавать структуры без
каких-либо элементов.  Такие структуры имеют нулевой размер.

   Если требуется явно опустить заполнение для типов структур (что, в
свою очередь, уменьшает скорость доступа к структурам в памяти), то GCC
обеспечивает несколько способов отключения упаковки.  Быстрый и простой
способ заключается в использовании опции '-fpack-struct' компилятора.
Для получения более подробной информации об отключенмм упаковку,
пожалуйста, обратитесь к руководству GCC, которое соответствует вашей
версии компилятора.


File: gnu-c-manual.info,  Node: Arrays,  Next: Pointers,  Prev: Structures,  Up: Data Types

2.5 Массивы
===========

Массив представляет собой структуру данных, которая позволяет хранить
один или несколько элементов в памяти последовательно.  В Cи, элементы
массива индексируются с нулевого значения индекса, а не с единицы.

* Menu:

* Declaring Arrays:: Объявление Массивов
* Initializing Arrays:: Инициализация Массивов
* Accessing Array Elements:: Доступ к Элементам Массива
* Multidimensional Arrays:: Многомерные Массивы
* Arrays as Strings:: Строки как Массивы
* Arrays of Unions:: Массивы Объединений
* Arrays of Structures:: Массивы Структур


File: gnu-c-manual.info,  Node: Declaring Arrays,  Next: Initializing Arrays,  Up: Arrays

2.5.1 Объявление Массивов
-------------------------

Объявляется массив, указанием типа данных для его элементов, его имени и
количества элементов которые он может хранить.  Вот пример, который
объявляет массив, который может хранить десять целых чисел:

     int мой_массив[10];

   Для стандартного кода Cи, количество элементов в массиве, должно быть
указано положительным значением.

   В качестве расширения GNU, число элементов может быть нулевым.
Нулевая длина массивы являются полезна в качестве последнего элемента
структуры, который на самом деле является заголовком для объекта
переменной длинны:

     struct line
     {
       int length;
       char contents[0];
     };

     {
       struct line *this_line = (struct line *)
         malloc (sizeof (struct line) + this_length);
       this_line -> length = this_length;
     }

   Другое расширение GNU позволяет объявить размер массива с помощью
переменных, а не только с помощью констант.  Например, вот определение
функции, которое объявляет массив, используя свой параметр, как значение
количества элементов массива:

     int
     my_function (int number)
     {
       int my_array[number];
       ...;
     }


File: gnu-c-manual.info,  Node: Initializing Arrays,  Next: Accessing Array Elements,  Prev: Declaring Arrays,  Up: Arrays

2.5.2 Инициализация Массивов
----------------------------

Можно инициализировать элементы массива при его объявлении, перечисляя
значения инициализации, разделенных запятыми, в фигурных скобок.  Вот
пример:

     int my_array[5] = { 0, 1, 2, 3, 4 };

   Не нужно явно инициализировать все элементы массива.  Например, этот
код инициализирует первые три элемента массива, как указано, а все
остальные инициализирует значением по умолчанию, в этом случае равного
нулю:

     int my_array[5] = { 0, 1, 2 };

   При использовании стандарта ISO C99 или C89 с расширениями GNU, можно
инициализировать элементы массива не по порядку, указывая индекс массива
для инициализации.  Чтобы достич этого, дополнительно включаетя индекс
массива в скобках, и, возможно, оператор присваивания, перед значением.
Вот пример:

     int мой_массив[5] = { [2] 5, [4] 9 };
Или, используя оператор присваивания:

     int мой_массив[5] = { [2] = 5, [4] = 9 };

Оба этих примера эквивалентны:

     int мой_массив[5] = { 0, 0, 5, 0, 9 };

   При использовании расширений GNU, можно инициализировать диапазон
элементов значением, указав первые и последние индексы, в виде ' [FIRST]
... [LAST] '.  Вот пример:

     int новый_массив[100] = { [0 ... 9] = 1, [10 ... 98] = 2, 3 };

   Это инициализирует элементы с индексами от 0 до 9 в значение 1,
элементы с индексом от 10 до 98 в значение 2, а элемент 99 в значение 3.
(Также можноявно написать '[99] = 3').  Кроме того, обратите внимание,
что _должны быть_ пробелы с обеих сторон выражения '...'.

   Если инициализировать каждый элемент массива, то не нужно указывать
размер массива; его размер определяется числом элементов инициализации.
Вот пример:

     int мой_массив[] = { 0, 1, 2, 3, 4 };

   Хотя здесь явно не указывается, что массив состоит из пяти элементов,
используется 'мой_массив[5]' инициализируя пять элементов, основываясь
на фактическое колличество.

   С другой стороны, если указать, какие элементы инициализируются, то
размер массива равен наибольшему значению индекса инициализированного
элемента плюс один.  Например:

     int мой_массив[] = { 0, 1, 2, [99] = 99 };

   В этом примере, только четыре элемента инициализации, но последний
инициализированный элемент массива имеет индекс 99, таким образом,
массив состоит из 100 элементов.


File: gnu-c-manual.info,  Node: Accessing Array Elements,  Next: Multidimensional Arrays,  Prev: Initializing Arrays,  Up: Arrays

2.5.3 Доступ к Элементам Массива
--------------------------------

Можно получить доступ к элементам массива, указав имя массива, а затем
индекс элемента, заключенный в квадратные скобки.  Следует помнить, что
элементы массива нумеруются, начиная с нуля.  Вот пример:

     my_array[0] = 5;

   Это присваивает значение 5 первому элементу в массиве, в нулевой
позиции.  Можно рассматривать отдельные элементы массива, как переменные
любого типа данных из которых состоит массив.  Например, если есть
массив, заполненный данными типа структура, можно получить доступ к
элементам структуры, так: (ВопросTypes1277)

     struct точка
     {
       int x, y;
     };
     struct точка точка_массив[2] = { {4, 5}, {8, 9} };
     точка_массив[0].x = 3;


File: gnu-c-manual.info,  Node: Multidimensional Arrays,  Next: Arrays as Strings,  Prev: Accessing Array Elements,  Up: Arrays

2.5.4 Многомерные Массивы
-------------------------

Можно создавать многомерные массивы или "массивы массивов".  Делается
это, добавлением дополнительного набора скобок и указания длинны массива
для каждого вложенного массива, если нужно указать колличество
элементов, которое массив будет иметь.  Например, ниже объявление для
двумерного массива, который содержит пять элементов в каждом элементе
(массив из двух элементов массивов, каждый из которых, сам состоит из
пяти элементов массива):

     int двух_уровневый_массив[2][5] { {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10} };

   Доступ к элементу многомерного массива осуществляется путём указания
желаемого индекса обоих массивов:

     двух_уровневый_массив[1][3] = 12;

   В нашем примере, 'двух_уровневый_массив[0]' это сам массив.  Элемент
'двух_уровневый_массив[0][2]' за которым следует
'двух_уровневый_массив[0][3]', а не 'двух_уровневый_массив[1][2]'.


File: gnu-c-manual.info,  Node: Arrays as Strings,  Next: Arrays of Unions,  Prev: Multidimensional Arrays,  Up: Arrays

2.5.5 Строки как Массивы
------------------------

Можно использовать массив символов для хранения строки (*note String
Constants::).  Массив может содержать и буквенные и небуквенные символы.

   Когда объявляется массив, можно указать количество элементов, которые
он будет иметь.  Это число будет максимальным количеством символов,
которые может содержать строка, включая нулевой символ завершения
строки.  Если выбирается этот вариант, то не нужно инициализировать
массив при его объявлении.  Кроме того, можно просто инициализировать
массив значением, и тогда его размер будет точно достаточно большим,
чтобы вместить все строки, который использовались для его инициализации.

   Есть два различных способа инициализации массива.  Можно указать
список символов, разделенных запятыми и заключенных в фигурные скобки,
или можно указать строку, заключённую в двойные кавычки.

   Вот несколько примеров:

     char синий[26];
     char желтый[26] = {'ж', 'е', 'л', 'т', 'ы', 'й', '\0'};
     char оранжевый[26] = "оранжевый";
     char серый[] = {'с', 'е', 'р', 'ы', 'й', '\0'};
     char лосось[] = "лосось";

   В каждом из этих случаев нулевой символ '\0' всегда завершает строку,
даже если он явно не указано.  (Обратите внимание, что если
инициализировать строку, используя массив отдельных символов, то нулевой
символ _требуется_ указывать.  Он может появится произвольно, но это
редкий случай, и не следует на него полагаться.)

   После инициализации, нельзя присвоить массиву новый строковый литерал
с помощью оператора присваивания.  Например, это _не сработает_:

     char лемон[26] = "заварной крем";
     лемон = "соус стейк";      /* Ошибка! */

Однако, есть функции в библиотеке GNU C, которые выполняют операции (в
том числе копирования) на строковых массивах.  Можете изменить один
символ за один раз, с помощью доступа к отдельным элементам строки, как
и с любым другим массивом:

     char имя[] = "юля";
     имя[0] = 'а';

   Возможно явно указать количество элементов в массиве, а затем
инициализировать его, используя строку, которая имеет больше символов,
чем колличество элементов в массиве.  Это не хорошая идея.  Заданная
превышающая по длинне строка _не_ переопределит ранее заданный размер
массива, и при компиляции сгенерируется предупреждение.  Поскольку
исходный размер массива не изменяется, та часть строки, которая
превышает исходный размер записывается в смежные ячейки памяти, которые
не были выделена для этого.


File: gnu-c-manual.info,  Node: Arrays of Unions,  Next: Arrays of Structures,  Prev: Arrays as Strings,  Up: Arrays

2.5.6 Массивы Объединений
-------------------------

Можно создать массив типа объединение так же, как и массив примитивного
типа данных.

     union числа
       {
         int i;
         float f;
       };
     union числа массив_чисел [3];

   Этот пример создает 3-элементный массив типа 'union числа' в
переменной, с именем 'массив_чисел'.  Также можно инициализировать
первый элемент массива 'числа':

     union числа массив_чисел [3] = { {3}, {4}, {5} };

Дополнительные внутренние скобки не являются обязательными.

   После инициализации, можно получить доступ к элементам объединения в
массиве с помощью оператора доступа к элементу 'точка (.)'.  Имя массива
и номер элемента (заключенного в скобках) слева от оператора, а имя
элемента справа.

     union числа массив_чисел [3];
     массив_чисел[0].i = 2;


File: gnu-c-manual.info,  Node: Arrays of Structures,  Prev: Arrays of Unions,  Up: Arrays

2.5.7 Массивы Структур
----------------------

Можно создать массив типа структура так же, как и массив примитивного
типа данных.

     struct точка
       {
         int x, y;
       };
     struct точка массив_точек [3];

   Этот пример создает 3-элементный массив типа 'struct точка' в
переменной с именем 'массив_точек'.  Также можно инициализировать
значениями элементы структур массива:

     struct точка массив_точек [3] = { {2, 3}, {4, 5}, {6, 7} };

   Как и в случае инициализации структур, которые содержат элементы
структуры, установка дополнительных внутренних скобок не является
обязательным.  Но, если используются дополнительные фигурные скобки, то
можно частично инициализировать некоторые структуры в массиве или
полностью инициализировать остальные по желанию:

     struct точка массив_точек [3] = { {2}, {4, 5}, {6, 7} };

   В этом примере первому элементу массива устанавливается только
значение структуры элементe 'x'.  Фигурные скобки, указывают присвоить
значение 4 элементу 'x' второго элемента массива, _не_ элементу 'y'
первого элемента, как это было бы в случае без указания фигурных скобок.

   После инициализации, можно получить доступ к элементам массива,
элементам структуры с помощью оператора доступа к элементу 'точка (.)'.
Имя массива и номер элемента (заключенный в скобках) устанавливается
слева от оператора, а имя элемента справа.

     struct точка массив_точек [3];
     массив_точек[0].x = 2;
     массив_точек[0].y = 3;


File: gnu-c-manual.info,  Node: Pointers,  Next: Incomplete Types,  Prev: Arrays,  Up: Data Types

2.6 Указатели
=============

Указатели хранят адреса памяти сохраннённых констант или переменных.
Для любого типа данных, включая как примитивные типы, так и определяемые
типы, можно создать указатель, который содержит адрес памяти экземпляра
этого типа.

* Menu:

* Declaring Pointers:: Объявление Указателей
* Initializing Pointers:: Инициализация Указателей
* Pointers to Unions:: Указатели на Объединения
* Pointers to Structures:: Указатели на Структуры


File: gnu-c-manual.info,  Node: Declaring Pointers,  Next: Initializing Pointers,  Up: Pointers

2.6.1 Объявление Указателей
---------------------------

Указатель объявляется указанием его имени и типа данных.  Тип данных
указывает на то, какой тип имеет переменная по этому адресу в памяти для
указателя.

   Для того, чтобы объявить указатель, включают (*note Pointer
Operators::) оператор косвенного обращения перед идентификатором.  Вот
общая форма декларации указателя:

     ТИП-ДАННЫХ * ИМЯ;

Пробел не является обязательным вокруг оператора косвенного обращения:

     ТИП-ДАННЫХ *ИМЯ;
     ТИП-ДАННЫХ* ИМЯ;

   Вот пример того, чтобы объявить указатель содержащий адрес переменной
типа 'int':

     int *ip;

   Будьте осторожны: при объявлении нескольких указателей в одном
операторе, нужно явно объявить каждую переменную как указатель, с
помощью оператора разыменования (он же косвенного обращения):

     int *один, *два;  /* Два указателя. */
     int *один, два;   /* Указатель на переменную с типом 'int' и
                       целочисленная переменная. */


File: gnu-c-manual.info,  Node: Initializing Pointers,  Next: Pointers to Unions,  Prev: Declaring Pointers,  Up: Pointers

2.6.2 Инициализация Указателей
------------------------------

Можно инициализировать указатель, при его объявлении, присвоив ему адрес
переменной.  Например, следующий код объявляет переменную 'int' 'i' и
указатель, который инициализируется адресом 'i':

     int i;
     int *ip = &i;

   Обратите внимание на использование оператора взятие адреса (*note
Pointer Operators::), используемого для получения адреса памяти
переменной.  После того, как объявлен указатель, _не_ требуется
использовать оператор разыменования с именем указателя при назначении
ему нового адреса.  Наоборот, это значение используется для того, что бы
изменить значение переменной, на адрес которой он указывает, а не
значение самого указателя.  Например:

     int i, j;
     int *ip = &i;  /* 'ip' теперь содержит адрес 'i'. */
     ip = &j;       /* 'ip' теперь содержит адрес 'j'. */
     *ip = &i;      /* 'j' теперь содержит адрес 'i'. */

   Значение, хранящееся в указателе является целым числом:
местоположение в пространстве памяти компьютера.  Если есть желание,
можно присвоить значение указателю в явном виде с помощью литералов
целых чисел, приведя указатель к соответствующему типу.  Тем не менее,
не рекомендуется такая практика, если нет жёсткого контроля над тем, что
хранится в памяти, и точно знаете, что происходит.  Слишком легко
случайно перезапись то, что не требовалося.  В большинстве случаев
применения этой техники также делает код непереносимым.

   Важно отметить, что если не инициализировать указатель адресом
какого-либо существующего объекта, это не отразится нигде, и вероятно,
приведёт к сбою программы, при попытки использовать его (формально,
такого рода проявления называют "неопределенное поведение").


File: gnu-c-manual.info,  Node: Pointers to Unions,  Next: Pointers to Structures,  Prev: Initializing Pointers,  Up: Pointers

2.6.3 Указатели на Объединения
------------------------------

Можно создать указатель типа объединение так же, как и указатель на
примитивный тип данных.

     union числа
       {
         int i;
         float f;
       };
     union числа первый_набор = {4};
     union числа *числа_указатель = &первый_набор;

   Этот пример создаёт новый тип объединения, 'union числа' и объявляет
(и инициализирует первый элемент) переменную этого типа с именем
'первый_набор'.  Наконец, объявляется указатель типа 'union числа', и
дает ему адрес 'первый_набор'.

   Можно получить доступ к членам переменной объединения через
указатель, но вы не можете больше использовать обычный оператор доступа
к элементу.  Вместо этого, требуется использовать оператор косвенного
доступа к элементу (*note Member Access Expressions::).  Продолжая
предыдущий пример, следующий пример будет менять значение первого
элемента 'первый_набор':

     number_ptr -> i = 450;

   Теперь элемент 'i' в 'первый_набор' содержит 450.


File: gnu-c-manual.info,  Node: Pointers to Structures,  Prev: Pointers to Unions,  Up: Pointers

2.6.4 Указатели на Структуры
----------------------------

Можно создать указатель с типом структура так же, как и указатель на
примитивный тип данных.

     struct рыба
       {
         float длинна, ширина;
       };
     struct рыба лосось = {4.3, 5.8};
     struct рыба *рыба_указатель = &лосось;

   Этот пример создает новый тип структуры, 'struct рыба' и заявляет (и
инициализирует) переменную этого типа с именем 'лосось'.  Наконец,
объявляется указатель типа 'struct рыба', и даётся ему адрес переменной
'лосось'.

   Можно получить доступ к элементам переменной структуры через
указатель, но нельзя больше использовать обычный оператор доступа к
элементу.  Вместо этого требуется использовать оператор косвенного
доступа к элементу (*note Member Access Expressions::).  Продолжая
предыдущий пример, следующий пример изменит значения элемента 'лосось':

     рыба_указатель -> длинна = 5.1;
     рыба_указатель -> ширина = 6.2;

   Теперь элементы 'длинна' и 'ширина' в 'лосось' являются 5,1 и 6,2,
соответственно.


File: gnu-c-manual.info,  Node: Incomplete Types,  Next: Type Qualifiers,  Prev: Pointers,  Up: Data Types

2.7 Неполные Типы
=================

Можно определить структуры, объединения и перечисления без перечисления
их элементов (или значений, в случае перечислений).  Это производит
неполный тип.  Можно объявлять переменные неполных типов и создавать и
работать с указателями на эти типы.

     struct точка;

   В какой-то момент позже в вашей программе потребуется завершить этот
тип.  Это можно сделать, определив его, как обычно:

     struct точка
       {
         int x, y;
       };

   Этот метод обычно используется для связанных списков:

     struct отдельный_связанный_список
       {
         struct отдельный_связанный_список *следующий;
         int x;
         /* здесь возможно другие элементы */
       };
     struct отдельный_связанный_список *список_начало;


File: gnu-c-manual.info,  Node: Type Qualifiers,  Next: Storage Class Specifiers,  Prev: Incomplete Types,  Up: Data Types

2.8 Квалификаторы Типов
=======================

Есть два типа квалификаторов, которые можно ДОБАВЛЯТЬ при объявлении
переменных, которые влияют на доступ к ней: 'const' и 'volatile'.

   'const' определяет переменную только для чтения; после её
инициализации,её значение не может быть изменено.

     const float pi = 3.14159f;

В дополнение к предупреждениям компилятора, которые сигнализируют о
изменении константных значений, объявления переменных с квалификатором
'const' помогает компилятору в оптимизации кода.

   'volatile' явно сообщает компилятору, что переменная будет менять
своё значение, и то что рассматривается безполезным для компилятора,
например доступ к переменной (например, с помощью указателей), не должно
им оптимизироваться.  Можно использовать объявления переменных с
квалификатором 'volatile' для хранения данных, которые обновляются с
помощью функций обратного вызова или обработчиков сигналов.  *note
Sequence Points and Signal Delivery::.

     volatile float текущаяТемпература = 40.0;


File: gnu-c-manual.info,  Node: Storage Class Specifiers,  Next: Renaming Types,  Prev: Type Qualifiers,  Up: Data Types

2.9 Спецификаторы Классов Хранения
==================================

Есть четыре спецификатора классов хранения, которыми можно ДОПОЛНЯТЬ
объявления переменных, которые изменяют, как переменные хранятся в
памяти: 'auto', 'extern', 'register', и 'static'.

   Можно использовать спецификатор 'auto' для переменных, которые
являются локальными для функции, и значение которых должно быть
отброшены после возврата из функции, в которой переменные были
объявлены.  Это поведение по умолчанию для переменных, объявленных
внутри функций.

     void
     foo (int значение)
     {
       auto int x = значение;
       ...
       return;
     }

   Спецификатор 'register' почти идентичен 'auto' по назначению, за
исключением того, что он также указывает компилятору, что переменная
будет активно использоваться, и, если это возможно, должна храниться в
регистре.  Нельзя использовать оператор взятия адреса, чтобы получить
адрес переменной, объявленной с спецификатором 'register'.  Это
означает, что не получиться обратиться к элементам массива, объявленного
с классом хранения 'register'.  На самом деле единственное, где
пригодится испоьзование такого массива, это измерение его размера с
помощью 'sizeof'.  GCC обычно делает правильный выбор о том, какие
значения требуется хранить в регистрах, и поэтому квалификатор
'register' не часто используется.

   Спецификатор 'static', по существу, отрабатывает противоположно
'auto': при применении к переменным внутри функции или блока, эти
переменные сохраняют свое значение даже тогда, когда функция или блок
закончены.  Это известно как "длительное статическое зранение".

     int
     sum (int x)
     {
       static int sumSoFar = 0;
       sumSoFar = sumSoFar + x;
       return sumSoFar;
     }

Можно также объявить переменную (или функцию) на верхнем уровне (то
есть, не внутри функции) используя спецификатор 'static'; такие
переменные видны (глобальные переменные) для текущего исходного файла
(но не для других исходных файлов).  Это к сожалению даёт двойной смысл
спецификатору 'static'; это второе значение известно как "статическая
связь".  Две функции или переменные, имеющие статическую связь в
отдельных файлах полностью изолированы; ни одна из них не видна за
пределами файла, в котором она объявлена.

   Неинициализированные переменные, объявленные с испльзованием
спецификатора 'extern' получают стандартные значения по умолчанию '0',
'0.0' или 'NULL', в зависимости от типа переменной.
Неинициализированные переменные, которые объявлены с использованием
спецификатора 'auto' или 'register' (в том числе когда используется
спецификатор по умолчанию 'auto') остаются неинициализированным, и,
следовательно, не следует рассматривать то, что хранит
неинициализированная переменная.

   'extern' полезно для объявления переменных, которые должны быть
видимыми для всех исходных файлов, которые входят в проект.  Нельзя
инициализировать переменную в объявлении с использовании спецификатора
'extern', так как фактически не выделяется место для хранения переменной
во время её объявления.  Нужно использовать объявление с использованием
спецификатора 'extern' (обычно в заголовочном файле, который включается
другими исходными файлами, которые должны получить доступ к переменной)
где не требуется фактическое выделения места для переменной и
использовать не-'extern' объявления в противном случае.  Объявления
'extern' может повторяться несколько раз.

     extern int номерКлиента;

     ...

     int номерКлиента = 0;

   *Note Program Structure and Scope::, для дополнительное информации.


File: gnu-c-manual.info,  Node: Renaming Types,  Prev: Storage Class Specifiers,  Up: Data Types

2.10 Переименование Типов
=========================

Иногда это удобно, чтобы дать новое имя типу.  Можно сделать это с
помощью оператора 'typedef'.  *Note The typedef Statement::, для
получения дополнительной информации.


File: gnu-c-manual.info,  Node: Expressions and Operators,  Next: Statements,  Prev: Data Types,  Up: Top

3 Выражения и Операторы
***********************

* Menu:

* Expressions::
* Assignment Operators::
* Incrementing and Decrementing::
* Arithmetic Operators::
* Complex Conjugation::
* Comparison Operators::
* Logical Operators::
* Bit Shifting::
* Bitwise Logical Operators::
* Pointer Operators::
* The sizeof Operator::
* Type Casts::
* Array Subscripts::
* Function Calls as Expressions::
* The Comma Operator::
* Member Access Expressions::
* Conditional Expressions::
* Statements and Declarations in Expressions::
* Operator Precedence::
* Order of Evaluation::


File: gnu-c-manual.info,  Node: Expressions,  Next: Assignment Operators,  Up: Expressions and Operators

3.1 Выражения
=============

"Выражение" состоит, по меньшей мере, из одного операнда и содержит ноль
или более операторов.  Операнды - это типизированные объекты, такие как
константы, переменные и вызовы функций, которые возвращают значение.
Вот некоторые примеры:

     47
     2 + 2
     cosine(3.14159) /* Мы предполагаем, это возвращает значение с плавающей
     точкой. */

   Круглые скобки для группировки подвыражений:

     ( 2 * ( ( 3 + 10 ) - ( 2 * 6 ) ) )

Вложенные выражения вычисляются первыми.  В приведенном выше примере,
вначале оцениваются выражения '3 + 10' и '2 * 6', затем оцениваются
полученные выражения '13' и '12', соответственно.  Затем '12' вычитается
из '13', в результате чего получается '1'.  Наконец, '1' умножается на
'2', в результате чего появляется '2'.  Самые внешние круглые скобки в
примере не являются обязательными.

   "Оператор" определяет операцию, которая будет выполняться над его
операндом(ами).  Операторы могут иметь один, два или три операнда, в
зависимости от оператора.


File: gnu-c-manual.info,  Node: Assignment Operators,  Next: Incrementing and Decrementing,  Prev: Expressions,  Up: Expressions and Operators

3.2 Операторы Присваивания
==========================

Операторы присваивания сохраняют значения в переменных.  Си обеспечивает
несколько вариантов операторов присваивания.

   Стандартный оператор присваивания '=' просто сохранит значение
правого операнда в переменную, указанную в левом операнде.  Как и со
всеми операторами присваивания, левый операнд (обычно называемый как
"lvalue (левое значение)") не может быть буквальным или постоянным
значением.

     int x = 10;
     float y = 45.12 + 2.0;
     int z = (2 * (3 + function () ));

     struct foo {
       int bar;
       int baz;
     } quux = {3, 4};

Обратите внимание, что, в отличие от других операторов присваивания,
описанных ниже, можно использовать простой оператор присваивания для
хранения значений структурного типа.

   Составные операторы присваивания выполняют операцию с участием как
левого, так и правый операнда, затем присваивают полученное выражение
левому операнду.  Вот список составных операторов присваивания и краткое
описание того, что они делают:

   * '+='

     Складывает два операнда вместе, затем присваивает результат
     сложения левому операнду.

   * '-='

     Вычитает правый операнд из левого операнда, затем присваивает
     результат вычитания левому операнду.

   * '*='

     Перемножает два операнда, затем присваивает результат умножения
     левому операнду.

   * '/='

     Делит левый операнд на правый операнд, присваивает результат
     деления левому операнду.

   * '%='

     Выполняет деление по модулю деление двух операндов, присваивает
     результат деления левому операнду.

   * '<<='

     Выполненяет операцию сдвига влево с левым операндом, сдвигая на
     число битов, заданное с помощью правого операнда, присваивает
     результат сдвига левому операнду.

   * '>>='

     Выполняет операцию сдвига вправо с левым операндом, сдвигая на
     число битов, заданное с помощью правого операнда, и присваивает
     результат сдвига левому операнду.

   * '&='

     Выполняет поразрядную операцию 'И' для двух операндов, и
     присваивает результат операции левому операнду.

   * '^='

     Выполняет поразрядную операцию 'исключающего ИЛИ' для двух
     операндов, и присваивает результат операции левому операнду.

   * '|='

     Выполняет поразрядную операцию 'ИЛИ' для двух операндов, и
     присваивает результат операции левому операнду.

   Ниже приведен пример использования одного из составных операторов
присваивания:

     x += y;

Поскольку нет никаких влияющих побочных эффектов при оценки переменной
'x' как lvalue (левого значения), приведенный выше код дает тот же
результат, что и код:

     x = x + y;


File: gnu-c-manual.info,  Node: Incrementing and Decrementing,  Next: Arithmetic Operators,  Prev: Assignment Operators,  Up: Expressions and Operators

3.3 Увеличение и Уменьшение
===========================

Оператор инкремента '++' добавляет 1 (еденицу) к своему операнду.
Операнд должен быть либо переменной одного из примитивных типов данных,
указателем или переменной перечисления.  Можжно применить оператор
инкремента либо до, либо после операнда.  вот несколько примеров:

     char w = '1';
     int x = 5;
     char y = 'B';
     float z = 5.2;
     int *p = &x;

     ++w;   /* 'w' теперь символ '2' (не число 2). */
     x++;   /* 'x' теперь 6. */
     ++y;   /* 'y' теперь 'C' (в системах ASCII). */
     z++;   /* 'z' теперь 6.2. */
     ++p;   /* 'p' теперь '&x' + 'sizeof(int)'. */

(Обратите внимание, что увеличивающийся указатель имеет смысл только
если есть основания полагать, что новое значение указателя будет
допустимым адресом памяти.)

   Префиксное приращение, добавляет 1 к операнду перед вычислением
операнда.  Постфиксное приращение добавляет 1 после того, как операнд
вычислен.  В предыдущих примерах, изменение положения оператора не будет
иметь никакого значения.  Однако, бывают случаи, когда это имеет
значение:

     int x = 5;
     printf ("%d \n", x++); /* Распечатает 'x', а затем увеличит его. */
     /* Вывод 5, хотя переменная 'x' теперь равна 6. */
     printf ("%d \n", ++x); /* Приращение к 'x', а затем печать его. */
     /* Вывод и переменная 'x' теперь равна 7. */

Вывод приведенного выше примера:

     5
     7

   Кроме того, можно вычесть 1 из операнда с помощью оператора
декремента:

     int x = 5;

     x--; /* 'x' теперь 4. */

Понятия префикс и постфикс, применяются также и с оператором инкремента.


File: gnu-c-manual.info,  Node: Arithmetic Operators,  Next: Complex Conjugation,  Prev: Incrementing and Decrementing,  Up: Expressions and Operators

3.4 Арифметические Операторы
============================

Си обеспечивает операторы для стандартных арифметических операций:
сложения, вычитания, умножения деления, деление по модулю и отрицание.
Использование этих операторов просто; вот несколько примеров:

     /* Сложение. */
     x = 5 + 3;
     y = 10.23 + 37.332;
     quux_pointer = foo_pointer + bar_pointer;

     /* Вычитание. */
     x = 5 - 3;
     y = 57.223 - 10.903;
     quux_pointer = foo_pointer - bar_pointer;

Можно складывать и вычитать указатели памяти, но нельзя перемножать и
делить их.

     /* Умножение. */
     x = 5 * 3;
     y = 47.4 * 1.001;

     /* Деление. */
     x = 5 / 3;
     y = 940.0 / 20.2;

Целочисленное деление положительных значений обрезает по направлению к
нулю, так что 5/3 равен 1.  Однако, если один из операндов является
отрицательным, то направление округления зависит от реализации.  *note
Signed Integer Division:: для информации о переполнении в знаковом
целочисленном делении.

   Оператор деление по модулю '%' используется, чтобы получить остаток
от деления его двух операндов.  Операнды устанавливаются по обе стороны
от оператора, и имеет значение, какой операнд на какой стороне: '3 % 5'
или '5 % 3' имеют разный результат.  Операнды должны быть выражениями
примитивного типа данных.

     /* Деление по модулю. */
     x = 5 % 3;
     y = 74 % 47;

Деление по модулю возвращает остаток, полученный после выполнения
деления целых чисел двух операндов.  Операнды должны быть примитивного
целого типа.

     /* Отрицание. */
     int x = -5;
     float y = -3.14159;

   Если операнд используемый с оператором отрицания имеет беззнаковый
тип данных, то результат не станет отрицательным, а будет иметь
максимальное значение беззнакового типа данных, за вычетом значения
операнда.

   Многие системы используют в коде арифметику с дополнением до двух, и
на таких системах самое отрицательное значение, знакового типа, может
находится дальше от нуля, чем самое положительное значение.  Например,
на одной платформе, эта программа:

     #include <limits.h>
     #include <stdio.h>

     int main (int argc, char *argv[])
     {
       int x;
       x = INT_MAX;
       printf("INT_MAX  = %d\n", x);
       x = INT_MIN;
       printf("INT_MIN  = %d\n", x);
       x = -x;
       printf("-INT_MIN = %d\n", x);
       return 0;
     }

   Производит этот вывод:

     INT_MAX  = 2147483647
     INT_MIN  = -2147483648
     -INT_MIN = -2147483648

   Можно также применить положительный оператор для числового выражения:

     int x = +42;

Числовые значения считаются положительными, если явно не сделать его
отрицательным, поэтому этот оператор не оказывает никакого влияния на
работу программы.


File: gnu-c-manual.info,  Node: Complex Conjugation,  Next: Comparison Operators,  Prev: Arithmetic Operators,  Up: Expressions and Operators

3.5 Комплексное Сопряжение
==========================

В качестве расширения GNU, можно использовать оператор комплексного
сопряжения '~', выполняет комплексное сопряжение на операнде -- то есть,
он меняет знак мнимой составляющей.  Операнд должен быть выражением типа
комплесного числа.  Вот пример:

     __complex__ int x = 5 + 17i;

     printf ("%d  \n", (x * ~x));

   Так как мнимое число (a + bi) умноженное на его сопряжённое число
равное a^2 + b^2, приведенное выше выражение 'printf' выведет на
печатать число 314, которое получилось из выражения 25 + 289.


File: gnu-c-manual.info,  Node: Comparison Operators,  Next: Logical Operators,  Prev: Complex Conjugation,  Up: Expressions and Operators

3.6 Операторы Сравнения
=======================

Можно использовать операторы сравнения для определения того, как два
операнда соотносятся друг с другом: они равны друг другу, один больше,
чем другой, один меньше другого, и так далее.  При использовании любого
из операторов сравнения, результат всегда равен 1 или 0, то есть
является истинной или ложью, соответственно.

   (В следующих примерах кода, переменные 'x' and 'y' содержат любые два
выражения арифметического типа или указателя.)

   Оператор равенства '==' тестирует свои два операнда на равенство.
Результат равен 1, если операнды равны, и 0, если операнды не равны.

     if (x == y)
       puts ("x равен y");
     else
       puts ("x не равен y");

   Оператор неравенства '!=' тестирует свои два операнда на неравенство.
Результат равен 1, если операнды не равны, и 0, если операнды _являются_
равными.

     if (x != y)
       puts ("x не равен y");
     else
       puts ("x равен y");

   Сравнение значений с плавающей точкой для точного равенства или
неравенства может привести к неожиданным результатам.  *note Real Number
Types:: для получения дополнительной информации.

   Можно сравнивать указатели на функции для равенства или неравенства;
сравнение проверяет, указывают ли указатели на одну и ту же функцию или
нет.

   Помимо равенства и неравенства, есть операторы, которые можно
использовать для тестирования того, меньше, больше, меньше или равной,
больше или равно одно значение другого значения.  Вот некоторые примеры
кода, которые иллюстрируют использование этих операторов:

     if (x < y)
       puts ("x меньше y");

     if (x <= y)
       puts ("x меньше или равно y");

     if (x > y)
       puts ("x больше y");

     if (x >= y)
       puts ("x больше или равно y");


File: gnu-c-manual.info,  Node: Logical Operators,  Next: Bit Shifting,  Prev: Comparison Operators,  Up: Expressions and Operators

3.7 Логические Операторы
========================

Логические операторы проверяют значение истинности пары операндов.
Любое выражение отлично от нуля считается истинным в Си, в то время как
выражение, значение которого является ноль считается ложным.

   Логический оператор 'И' - '&&' проверяет, если два выражения истинны.
Если первое выражение ложно, то второе выражение не вычисляется.

     if ((x == 5) && (y == 10))
       printf ("x равно 5 и y равно 10");

   Логический оператор 'или' - '||' проверяет, если хотя бы одно из двух
выражений истинным.  Если первое выражение истинно, то второе выражение
не вычисляется.

     if ((x == 5) || (y == 10))
        printf ("x равно 5 или y равно 10");

   Можете предварять логическое выражение оператором отрицания 'не' -
'!', который переворачивает значение истинности:

     if (!(x == 5))
       printf ("x не равно 5");

   Так как второй операнд в паре логического выражения не обязательно
вычисляется, возможно написать код с неинтуитивными результатами:

     if (foo && x++)
       bar();

В случае когда оценка 'foo' не будет равна нулю, то не только произойдёт
вызов 'bar', но и значение 'x' будет увеличино.  Если требуется
увеличивать 'x' независимо от значения 'foo', нужно сделать приращение
за пределами выражения 'И'.


File: gnu-c-manual.info,  Node: Bit Shifting,  Next: Bitwise Logical Operators,  Prev: Logical Operators,  Up: Expressions and Operators

3.8 Битовый Сдвиг
=================

Использование оператора '<<' сдвиг влево, сдвинет биты своего первого
операнда влево.  Второй операнд обозначает количество битовых мест для
сдвига.  Биты, сдвинутые на левой стороне значения отбрасываются; новые
биты, добавленные на правой стороне все будет установлены в 0.

     x = 47;    /* 47 это 00101111 в двоичном представлении. */
     x << 1;    /* 00101111 << 1 после сдвига равно 01011110. */

   Точно так же оператор '>>' сдвига вправо, сдвинет биты своего первого
операнда вправо.  Биты смещённые с правой стороны отбрасываются; новые
биты, добавленные на левой стороне _обычно_ устанавливаются в 0, но если
первый операнд является знаковым отрицательным значением, то добавленные
биты будут либо 0 _либо_ любым другим значением, которое ранее было в
самой крайней левой позиции бита.

     x = 47;   /* 47 это 00101111 в двоичном представлении. */
     x >> 1;   /* 00101111 >> 1 после сдвига вправо теперь 00010111. */

   Для обоих операторов '<<' и '>>', если второй операнд больше битовой
ширины первого операнда или второй операнд является отрицательным,
поведение операторов не определено.

   Можно использовать операторы сдвига для выполнения множества
интересных трюков.  Например, для работы с датой - учитывая дату с днём
​​месяца пронумерованной в 'd', месяца пронцмерованного 'm', и года
пронумерованного 'y', можно хранить всю дату в одном числе 'x':

     int d = 12;
     int m = 6;
     int y = 1983;
     int x = (((y << 4) + m) << 5) + d;

Можно теперь извлечь исходный день, месяц и год из 'x', используя
комбинацию операторов сдвига и модульного деления:

     d = x % 32;
     m = (x >> 5) % 16;
     y = x >> 9;


File: gnu-c-manual.info,  Node: Bitwise Logical Operators,  Next: Pointer Operators,  Prev: Bit Shifting,  Up: Expressions and Operators

3.9 Побитовые Логические Операторы
==================================

Cи предоставляет операторы для выполнения побитового соединения 'И',
'ИЛИ', 'исключающего ИЛИ' и 'НЕ' (дополнения).

   Побитовое соединение 'И' анализирует каждый бит двух операндов, и
когда два соответствующих бита установлены в 1, результирующий бит
устанавливается в 1.  Во всех остальных случаях, результирующий бит
устанавливается в 0.  Ниже приведен пример того, как это работает,
используя двоичные числа:

     11001001 & 10011011 = 10001001

   Побитовое соединение 'ИЛИ' анализирует каждый бит в двух операндах, и
когда два соответствующих биты установлены в 0, то результирующий бит
устанавливается в 0.  Во всех остальных случаях, результирующий бит
устанавливается в 1.

     11001001 | 10011011 = 11011011

   Побитовое соединение 'исключающее ИЛИ' анализирует каждый бит в двух
операндах, и когда два соответствующих бита отличны по установленному
значению, то результирующий бит устанавливается в 1.  Во всех остальных
случаях, результирующий бит устанавливается в 0.

     11001001 ^ 10011011 = 01010010

   Побитовое соединение 'НЕ' меняет значение каждого бита в операнде на
противоположное:

     ~11001001 = 00110110

   В Cи, эти операторы можно использовать только с операндами
целочисленного типа (или символьного), а также для обеспечения
максимальной переносимости следует использовать только оператор
побитового отрицания с беззнаковыми целочисленными типами.  Вот
некоторые примеры использования этих операторов в коде Cи:

     unsigned int foo = 42;
     unsigned int bar = 57;
     unsigned int quux;

     quux = foo & bar;
     quux = foo | bar;
     quux = foo ^ bar;
     quux = ~foo;


File: gnu-c-manual.info,  Node: Pointer Operators,  Next: The sizeof Operator,  Prev: Bitwise Logical Operators,  Up: Expressions and Operators

3.10 Операторы Указателей
=========================

Можно использовать оператор взятия адреса '&' для получения адреса
памяти объекта.

     int x = 5;
     int *pointer_to_x = &x;

   Не следует использовать этот оператор, чтобы получить адрес функции,
хотя можно так:

     extern int foo (void);
     int (*fp1) (void) = foo; /* fp1 указатель на foo */
     int (*fp2) (void) = &foo; /* fp2 также указывает на foo */

   Указатели на функции и указатели на данные не совместимы, в том
смысле, что не получиться сохранить адрес функции в указателе на данные,
а затем скопировать этот указатель в указатель на функцию и вызвать
потом функцию успешно.  Это может работать на некоторых системах, но это
непереносимая техника.

   В качестве расширения GNU для C89, можно также получить адрес метки
используя оператор взятия адреса метки '&&'.  Результатом будет
указатель 'void*', который может быть использован оператором 'goto'.
*Note The goto Statement::.

   Учитывая адрес памяти, хранящийся в указателе, можно использовать
оператор косвенного обращения (разыменования) '*', чтобы получить
значение, хранящееся по адресу.  (Это называется "разыменованием"
указателя.)

     int x = 5;
     int y;
     int *ptr;

     ptr = &x;    /* 'ptr' теперь хранит адрес 'x'. */

     y = *ptr;    /* 'y' получает значение, хранящееся по адресу
                     которое сохранено в 'ptr'. */

Избегайте использование разыменования указателей, которые не были
инициализированы в известную ячейку памяти.


File: gnu-c-manual.info,  Node: The sizeof Operator,  Next: Type Casts,  Prev: Pointer Operators,  Up: Expressions and Operators

3.11 Оператор Получения Размера
===============================

Можно использовать оператор 'sizeof', чтобы получить размер (в байтах)
операнда содержащего тип данных.  Операнд может быть указан с
фактическим спецификатором типа (например, 'int' или 'float'), а также
быть любым допустимым выражением.  Когда операнд является именем типа,
он должен быть заключен в скобки.  Вот некоторые примеры:

     size_t a = sizeof(int);
     size_t b = sizeof(float);
     size_t c = sizeof(5);
     size_t d = sizeof(5.143);
     size_t e = sizeof a;

   Результат оператора 'sizeof' имеет имя типа 'size_t', которое
определено в файле заголовка '<stddef.h>'.  'size_t' является
беззнаковым целочисленным типом, может быть идентичен 'unsigned int' или
'unsigned long int', что меняется от системы к системе.

   'size_t' тип часто бывает удобным типом для индексации цикла, так как
это позволяет иметь возможность удерживать значение количества элементов
в любом массиве, что не получиться при использовании индексации например
с типом 'int'.

   Оператор 'sizeof' может использоваться для автоматического вычисления
количества элементов в массиве:

     #include <stddef.h>
     #include <stdio.h>

     static const int values[] = { 1, 2, 48, 681 };
     #define ARRAYSIZE(x) (sizeof x/sizeof x[0])

     int main (int argc, char *argv[])
     {
         size_t i;
         for (i = 0; i < ARRAYSIZE(values); i++)
         {
             printf("%d\n", values[i]);
         }
         return 0;
     }

   Есть два случая, когда этот метод не работает.  Во-первых, когда
элемент массива имеет нулевой размер (GCC поддерживает структуры
нулевого размера как расширение GNU). Во-вторых, если массив фактически
является параметром функции (*note Function Parameters::).


File: gnu-c-manual.info,  Node: Type Casts,  Next: Array Subscripts,  Prev: The sizeof Operator,  Up: Expressions and Operators

3.12 Приведение Типов
=====================

Можно использовать приведение типа, чтобы явно указать, что выражение
относится к определенному типу данных.  Такое приведение состоит из
спецификатора типа, заключенного в скобках, за которым следует
выражение.  Для обеспечения правильного приведения, нужно также
заключить выражение, которое следует за спецификатором типа в скобках.
Вот пример:

     float x;
     int y = 7;
     int z = 3;
     x = (float) (y / z);

   В этом примере, поскольку 'y' и 'z' оба являются целыми числами,
выполняется целочисленное деление, 'x' это переменная с плавающей точкой
и принимает вычисленное выражение деления - значение 2.  Здесь явное
приведение результата деления к типу 'float' не делает ничего хорошего,
потому что вычисленное значение 'y/z' уже усечено до 2.

   Чтобы устранить эту проблему, необходимо преобразовать тип одного из
операндов опрации деления в тип с плавающей точкой до выполнения
деления:

     float x;
     int y = 7;
     int z = 3;
     x = (y / (float)z);

Здесь, значение с плавающей точкой, близкое к 2.333..., присваивается
'x'.

   Приведение типа работает только со скалярными типами (то есть с
целочисленными типами, типими числа с плавающей точкой и типами
указатель).  Таким образом, это допустимо:

     struct fooTag { /* коллекция ... */ };
     struct fooTag foo;
     unsigned char byteArray[8];

     foo = (struct fooType) byteArray; /* Ошибка! */


File: gnu-c-manual.info,  Node: Array Subscripts,  Next: Function Calls as Expressions,  Prev: Type Casts,  Up: Expressions and Operators

3.13 Индексация Массива
=======================

Можно получить доступ к элементам массива, указав имя массива и индекс
массива (или индекс или номер элемента), заключенного в квадратные
скобки.  Ниже приведен пример целочисленного массива с именем
'my_array':

     my_array[0] = 5;

   Выражение индекс массива 'A[i]' определяется как идентично выражению
'(*((A)+(i)))'.  Это означает, что многие виды использования имени
массива эквивалентно выражению с указателем.  Это также означает, что
нельзя индексировать массив, имеющий класс хранения 'register'.


File: gnu-c-manual.info,  Node: Function Calls as Expressions,  Next: The Comma Operator,  Prev: Array Subscripts,  Up: Expressions and Operators

3.14 Вызовы Функций как Выражения
=================================

Вызов любой функции, которая возвращает значение, является выражением.

     int function(void);
     ...
     a = 10 + function();


File: gnu-c-manual.info,  Node: The Comma Operator,  Next: Member Access Expressions,  Prev: Function Calls as Expressions,  Up: Expressions and Operators

3.15 Оператор Запятая
=====================

Можно использовать оператор запятая ',' для разделения двух (якобы
связанных) выражений.  Например, первое выражение может задавать
значение, которое используется вторым выражением:
     x++, y = x * x;

   Чаще всего, оператор запятая используется в конструкции оператора
'for', как здесь:

     /* Использование оператора запятая в 'for' конструкции. */

     for (x = 1, y = 10;  x <=10 && y >=1;  x++, y--)
       {
         ...
       }

Это позволяет удобно устанавливать, контролировать и изменять несколько
управлящих выражений конструкции 'for'.

   Запятая также используется для разделения параметров функции; Однако,
это _не_ оператор запятая в действии.  В самом деле, если оператор
запятой использовать как мы уже обсуждали здесь, в вызове функции, то
компилятор будет интерпретировать это как вызов функции с дополнительным
параметром.

   Если требуется использовать запятую в качестве аргумента функции,
нужно поставить скобки вокруг неё.  Это потому, что запятая в списке
аргументов функции имеет другой смысл: она разделяет аргументы.  Таким
образом,

     foo (x,  y=47,  x,  z);

интерпретируется как вызов функции с четырьмя аргументами, но

     foo (x,  (y=47,  x),  z);

Это вызов функции с использованием трёх аргументов.  (Второй аргумент
это - выражение '(y=47, x)'.)


File: gnu-c-manual.info,  Node: Member Access Expressions,  Next: Conditional Expressions,  Prev: The Comma Operator,  Up: Expressions and Operators

3.16 Доступ к Членам Выражения
==============================

Можно использовать оператор '.' для доступа через переменную к элементу
структуры или объединения.  Имя переменной структуры располагается с
левой стороны, а и имя члена коллекции с правой стороны оператора.

     struct point
     {
       int x, y;
     };

     struct point first_point;

     first_point.x = 0;
     first_point.y = 5;

   Также можно получить доступ через переменную к членам структуры или
объединения с помощью указателя, используя опреатор косвенного доступа к
члену структуры '->'.  Выражение 'x->y' эквивалентно выражению '(*x).y'.

     struct fish
       {
         int length, weight;
       };

     struct fish salmon;

     struct fish *fish_pointer = &salmon;

     fish_pointer->length = 3;
     fish_pointer->weight = 9;

   *Note Pointers::.


File: gnu-c-manual.info,  Node: Conditional Expressions,  Next: Statements and Declarations in Expressions,  Prev: Member Access Expressions,  Up: Expressions and Operators

3.17 Условные Выражения
=======================

Можно использовать условный оператор, чтобы выполнить оценку или его
второго операнда либо третьего, на основании значения истинности первого
операнда.  Вот пример:

     a ? b : c

   Если выражение 'a' истинно, то вычисляется выражение 'b' и
результатом всего выражения является оцененное значение выражения 'b'.
В противном случае, вычисляется выражение 'c' и результатом всего
выражения будет вычисленное значение выражения 'c'.

   Выражения 'b' and 'c' должны быть совместимыми.  То есть, они оба
должны быть

  1. арифметическими типами
  2. совместимыми структурами 'struct' или типами 'union'
  3. указателями на совместимые типы (один из которых может быть
     указателем NULL)

   В качестве альтернативы, один операнд является указателем, а другой
является указателем 'void*'.

   Вот пример

     a = (x == 5) ? y : z;

   Здесь, если 'x' равен 5, то 'a' получит значение 'y'.  В противном
случае, 'a' получит значение 'z'.  Это можно рассматривать как метод
стенографии для написания простого заявления 'if'...'else'.  Следующий
пример выполнения той же задачи, как и в предыдущем:

     if (x == 5)
         a = y;
     else
         a = z;

   Если первый операнд условного оператора является оценивается в
истину, то третий операнд никогда не оценивается.  Аналогичным образом,
если первый операнд оценен в ложь, тогда второй операнд никогда не
оценивается.  Первый операнд всегда оценивается.


File: gnu-c-manual.info,  Node: Statements and Declarations in Expressions,  Next: Operator Precedence,  Prev: Conditional Expressions,  Up: Expressions and Operators

3.18 Выражения в Объявлениях
============================

В качестве расширения GNU Cи, можо построить выражение с помощью
составного оператора, заключенного в круглых скобках.  Это позволяет
включать в выражения циклы, указатели и локальные переменные.

   Напомним, что составной оператор (также известный как блок)
представляет собой последовательность операторов заключённую в фигурные
скобки.  В этой конструкции круглые скобки заключают в себя фигурные
скобки.  Вот пример:

     ({ int y = function (); int z;
         if (y > 0) z = y;
        else z = - y;
        z; })

   Это является допустимым (хотя и несколько более сложным, чем это
необходимо) выражением для абсолютного значения функции 'function ()'.

   Последним элементом в составном операторе должно быть выражение, за
которым следует оператор точки с запятой; значение этого подвыражения
служит заключительным значением всей конструкции.  (Если используется
какой-то другой тип в качестве последнего составного оператора в
фигурных скобках, конструкция возвращает значение типа 'void', и, таким
образом, не имеет возвращаемого значения.)

   Эта функция особенно полезна для "безопасного" объявления макроса
(так что каждый операнд был оценен ровно один раз).  Например, функция
"maximum" обычно определяется как макрос в стандартном Cи следующим
образом:

     #define max(a,b) ((a) > (b) ? (a) : (b))

Но это определение вычисляет либо 'a' либо 'b' дважды, с искажёнными
зультатами, если вычисление операнда имеет побочные эффекты.  В GNU Cи,
если известен тип операндов (здесь давайте предположим 'int'), можно
определить безопасный макрос следующим образом:

     #define maxint(a,b) \
       ({int _a = (a), _b = (b); _a > _b ? _a : _b; })

   Если тип операнда не известен, можно сделать это, использовав
'typeof' для выражения или именованного типа.

   Встроенный оператор 'typeof' не допускается использовать для
константных выражений, таких как константное значение перечисления,
размер битового поля или начальное значение статической переменной.


File: gnu-c-manual.info,  Node: Operator Precedence,  Next: Order of Evaluation,  Prev: Statements and Declarations in Expressions,  Up: Expressions and Operators

3.19 Приоритет Операторов
=========================

Если выражение содержит несколько операторов, такое как 'a + b * f()',
операторы группируются на основе правил "приоритета".  Например,
действия этого выражения состоит из вызова функции 'f' без аргументов,
умножения её результата выполнения на 'b' и затем добавление к
получившемуся результату 'a'.  Вот как правила приоритета операторов Cи,
определят последовательность оценки этого выражения.

   Ниже приведен список типов выражений, представленных в порядке,
начиная с наивысшего приоритета.  Иногда два или более оператора имеют
одинаковый приоритет, тогда все эти операторы выполняются по очереди
слева направо, если не явно не задано иное.

  1. Оператор вызова функции, индексации массива и выражение доступа к
     члену структуры.

  2. Унарные операторы, в том числе логическое отрицание, побитовое
     дополнение, инкрементация, декрементация, унарный плюс, унарный
     минус, оператор косвенного обращения, оператор взятия адреса,
     приведения типов и 'sizeof' выражения.  Когда несколько унарных
     операторов указаны подряд, идущие позже, вычисляются раньше чем
     идущие впереди них: '!-x' означает '!(-x)'.

  3. Multiplication, division, and modular division expressions.

  4. Выражения сложения и вычитания.

  5. Выражения поразрядного сдвига.

  6. Выражения Большее чем, меньше чем, больше или равно чем, меньше или
     равно чем.

  7. Выражения проверки равенства и неравенства.

  8. Побитовые выражения 'AND (И)'.

  9. Побитовые выражения '^ (Исключающее ИЛИ)'.

  10. Побитовые выражения 'OR (ИЛИ)'.

  11. Логические выражения 'AND (И)'.

  12. Логические выражения 'OR (ИЛИ)'.

  13. Условные выражения (использование '?:').  При использовании в
     качестве подвыражений, они оцениваются справа налево.

  14. Все выражения присваивания, в том числе составное присваивание.
     Когда несколько операторов присваивания появляются как подвыражения
     в составе одного большого выражения, они вычисляются справа налево.

  15. Выражения оператора запятая.

   Приведенный выше перечень несколько суховат и, по-видимому прост и не
покажет скрытых некоторых подводных камней.  Возьмём такой пример:

     foo = *p++;

   Здесь 'p' увеличиваются как побочный эффект выражения, но 'foo'
принимает значение '*(p++)', а не '(*p)++', так как унарные операторы
выполняются справа налево.  Есть и другие примеры потенциальных
сюрпризов, скрывающихся за завесом приоритета вычисления операторов Cи.
По этой причине, если есть малейший риск непонимания читателем смысла
программы, нужно использовать круглые скобки, чтобы ясно задать смысл
выражения.


File: gnu-c-manual.info,  Node: Order of Evaluation,  Prev: Operator Precedence,  Up: Expressions and Operators

3.20 Порядок Вычисления
=======================

В Cи нельзя предполагать, что несколько подвыражений вычисляются в
порядке, который кажется естественным.  Например, рассмотрим выражение
'++a * f()'.  Означает ли это приращение 'a' до или после вызова функции
'f'?  Компилятор может сделать это в любом порядке, так что нельзя
сделать точное предположение.

   Это руководство объясняет абстрактную семантику языка Cи.  Однако
реальный компилятор преобразует исходный код в конкретные действия на
реальном компьютере, и может изменить порядок операций в интересах
эффективности.  Соответствие между написанным текстом программы и тем
какие действия на самом деле выполнит компьютер определяются в терминах
_побочных эффектов_ и _точек последовательности_.

* Menu:

* Side Effects::
* Sequence Points::
* Sequence Points Constrain Expressions::
* Sequence Points and Signal Delivery::


File: gnu-c-manual.info,  Node: Side Effects,  Next: Sequence Points,  Up: Order of Evaluation

3.20.1 Побочные Эффекты
-----------------------

К "побочному эффекту" относится одно из следующих действий:
  1. доступ к объекту 'volatile'
  2. изменение объекта
  3. изменение файла
  4. вызов функции, выполняющая один из указанных выше побочных эффектов

   По существу, это внешне видимые эффекты запуска программы.  Они
называются побочными эффектами, потому что они являются следствием
'оценки' выражения за пределами фактического результирующего значения
выражения.

   Компилятор может выполнять операции вашей программы в порядке,
отличающийся от порядка, вытекающего из исходного кода вашей программы,
при условии, что в конце концов отработают все необходимые побочные
эффекты.  Компилятору также позволено полностью опустить некоторые
операции; например, он может пропустить часть оценки выражения, если он
уверен, что значение не используется, и оценка этой части выражения не
будет производить никаких необходимых побочных эффектов.


File: gnu-c-manual.info,  Node: Sequence Points,  Next: Sequence Points Constrain Expressions,  Prev: Side Effects,  Up: Order of Evaluation

3.20.2 Точки Последовательности
-------------------------------

Еще одно требование к компилятору является то, что побочные эффекты
должны проявляться в правильном порядке.  Для того, чтобы обеспечить это
без чрезмерного ограничения компилятора, стандарты C89 и C90 определяют
список точек последовательности.  "Точка последовательности"
представляется одним из следующих действий:

  1. после вызова функции (после завершения оценки аргумента)
  2. после левостороннего операнда оператора 'AND (И)' '&&'
  3. после левого операнда оператора 'OR (ИЛИ)' '||'
  4. после левого операнда оператора запятая ','
  5. после первого операнда тернарного оператора 'a ? b : c'
  6. после полного объявления (1)
  7. после выражения инициализации
  8. после конструкций выражений (т.е.  выражение с последующим ';')
  9. после объявления управляющих конструкций 'if' или 'switch'
  10. после объявления управляющего выражения 'while' или 'do'
  11. после объявления любого из трех управляющих выражений 'for'
  12. после выражения оператора возврата
  13. непосредственно перед возвращением библиотечной функции
  14. после действий, связанных с элементом форматированного I/O (как
     это используется, например, с 'strftime' или 'printf' и 'scanf'
     родственных функций).
  15. непосредственно перед и после вызова функции сравнения (как это
     происходит, например, при использовании 'qsort')

   В точке последовательности, все побочные эффекты оценки предыдущих
выражений должны быть завершены, и никакие побочных эффектов последующих
оценок выражений не имеют смысла.

   Это может показаться трудным для понимания, но есть и другой способ,
чтобы рассмотреть это.  Представьте, что вы написали библиотеку
(некоторые из функции являются внешними и, возможно, другие нет) и
скомпилировал её, разрешается вызов одной из этих функций из внешнего
кода.  Определения приведённые выше гарантируют, что в момент вызова
вашей функции, данные, которые ей перадаются, имеют согласованное
значение, заданное виртуальной машиной, и любые данные, возвращаемые
вашей функцией имеют состояние, которое также будет согласовано с
виртуальной машиной.  Это включает в себя данные, доступные с помощью
указателей (т.е.  не только параметры функций и идентификаторы с внешним
связыванием).

   Вышесказанное является небольшим упрощением, поскольку существуют
компиляторы, которые выполняют оптимизацию программы в целом, уже во
время компоновки.  Важно отметить, однако, хотя они могут выполнять
оптимизации, видимые побочные эффекты программы должны быть такими же,
как если бы они были получены с помощью виртуальной машины.

   ---------- Footnotes ----------

   (1) полное объявление - это объявление функции или объекта, который
не является частью другого объекта


File: gnu-c-manual.info,  Node: Sequence Points Constrain Expressions,  Next: Sequence Points and Signal Delivery,  Prev: Sequence Points,  Up: Order of Evaluation

3.20.3 Ограничение Выражений Точками Последовательности
-------------------------------------------------------

Фрагмент кода
     i = i + 1;
   это вполне нормально, и нет сомнений в том, что происходит во многих
программах.  Тем не менее, вполне аналогичный фрагмент кода
     i = ++i + 1;
   немного сложнее понять; каково окончательное значение 'i'?  Стандарты
Cи (как C89 и C99)запрещают эту конструкцию в соответствии программ.

   Между двух точек последовательности,
  1. объект может иметь свое сохраненное значение модифицированное не
     более одного раза в ходе оценки выражения
  2. предварительное значение объекта должно быть только для чтения,
     чтобы определить значение для сохранения.

   Первый из этих двух условий запрещают выражения типа 'foo(x=2, ++x)'.
Второе условие запрещает такие выражения, как 'a[i++] = i'.

'int x=0; foo(++x, ++x)'
     Не допускается для соответствия программы, модифицировать 'x'
     дважды, прежде чем оценка аргумента завершена.
'int x=0; bar((++x,++x))'
     Позволено, функция 'bar' принимает один аргумент (в аргументе
     передано два значения), и есть точка последовательности - оператор
     запятая.
'*p++ || *p++'
     Позволено, существует точка последовательности на '||'.
'int x = 1, y = x++;'
     Позволено, существует точка последовательности после полного
     описания 'x'.
'x=2; x++;'
     Позволено, существует точка последовательности в конце первого
     оператора выражения.
'if (x++ > MAX) x = 0;'
     Позволено, существует точка последовательности в конце управляющего
     выражения 'if'(1).
'(x=y) ? ++x : x--;'
     Позволено, существует точка последовательности перед '?', и только
     один из двух следующих выражений оцениваются.
'int *p=malloc(sizeof(*p)), *q=p; *p=foo(); bar((*p)++,(*q)++);'
     Не допустимо, объект в 'p' модифицируется дважды, прежде чем оценка
     аргументов 'bar' завершена.  Тот факт, что это делается один раз
     через 'p' и один раз через 'q' не имеет никакого значения, так как
     они указывают на один и тот же объект.

   Вернемся к примеру, мы использовали, чтобы представить проблему
порядка оценки, '++a * f()'.  Предположим, что код на самом деле
выглядит следующим образом:

     static int a = 1;

     static int f (void)
     {
       a = 100;
       return 3;
     }

     int foo (void)
     {
        return ++a * f();
     }

   Разрешён ли этот код в соответствии стандартам программы?  Хотя
выражение в 'foo' модифицирует 'a' дважды, это не проблема.  Давайте
посмотрим на два возможных случаях.

Правый операнд 'f()' оценивается первым. Поскольку 'f'
     возвращает значение, отличное от void (неопределенно), выражение
     должно содержать 'return' объявление.  Таким образом, существует
     точка последовательности в конце выражения возврата.  Это
     происходит между модификацией 'a', при работе 'f' и оценки левого
     операнда.
Левый операнд '++a' вычисляется первым. Во-первых, 'a'
     увеличивается.  Затем вычисляются аргументы 'f' (их нет).  Затем
     существует точка последовательности перед фактическим вызовом 'f'.

   Итак, мы видим, что наша программа соответствует стандарту.  Обратите
внимание, что приведенное выше рассуждение фактически не зависит от
деталей тела функции 'f'.  Это зависит только от того, что функция
содержит что-то, что заканчивающееся точкой последовательности - в нашем
примере это оператор возврата, но оператор выражения или полное описание
также подойдёт.

   Тем не менее, результат выполнения этого кода зависит от порядка
вычисления операндов '*'.  Если левый операнд вычисляется первым, 'foo'
возвращает 6.  В противном случае она возвращает 303.  Стандарт Cи не
определяет, в каком порядке операнды должны быть оценены, а также не
требует реализации документирования порядка и не требует придерживаться
такого порядка.  Эффект этого кода "не определённ", а это означает, что
может произойти одно из нескольких конкретных вещей, но стандарты Cи не
определяют что именно произойдёт в этом случае.

   ---------- Footnotes ----------

   (1) Однако, если, например 'MAX' является 'INT_MAX' и 'x' имеет тип
'int', мы явно имеем проблему с переполнением.  *Note Overflow::.


File: gnu-c-manual.info,  Node: Sequence Points and Signal Delivery,  Prev: Sequence Points Constrain Expressions,  Up: Order of Evaluation

3.20.4 Точки Последовательности и Доставка Сигналов
---------------------------------------------------

Сигналы в основном описаны в руководстве GNU C Library, а не в этом
документе, несмотря на это, стандарты Cи рассматривают компилятор и
библиотеку Cи вместе как "реализацию".

   Когда сигнал получен, это будет происходить между точками
последовательности.  Побочные эффекты на 'volatile' объектов до
предыдущей точки последовательности будет учтены, но другие обновления,
возможно, ещё не произошли.  Это относится даже к прямым присвоениям,
таким как 'x=0;', так как код, сгенерированный для этого заявления может
потребовать более одной команды, а это означает, что его отработка может
быть прервана на полпути его выполнения, путем доставки сигнала.

   Стандарт Си весьма ограничивает с доступом к данным внутри
обработчика сигнала.  Они могут использовать 'auto' переменные, но с
точки зрения чтения или записи других объектов, они должны быть
'volatile sig_atomic_t'.  В 'volatile' типе гарантируется, что доступ к
переменной в других частях программы не охватывает точки
последовательности и использование 'sig_atomic_t' типа обеспечивает
поведение, при котором изменения в переменной являются атомарными
относительно доставки сигнала.

   Стандарт POSIX также позволяет небольшое количество библиотечных
функций для вызова из обработчика сигнала.  Эти функции называются
набором функций "безопасных-фссинхронных-сигналовa".  Если ваша
программа предназначена для запуска на системе POSIX, но не в других
системах, вы можете смело вызывать их из обработчика сигнала тоже.


File: gnu-c-manual.info,  Node: Statements,  Next: Functions,  Prev: Expressions and Operators,  Up: Top

4 Инструкции
************

Инструкция вызывает действия и управляет потоком выполнения в
программах.  Можно написать инструкцию, которая не будет делать вообще
ничего, или делать бесполезное действие.

* Menu:

* Labels::
* Expression Statements::
* The if Statement::
* The switch Statement::
* The while Statement::
* The do Statement::
* The for Statement::
* Blocks::
* The Null Statement::
* The goto Statement::
* The break Statement::
* The continue Statement::
* The return Statement::
* The typedef Statement::


File: gnu-c-manual.info,  Node: Labels,  Next: Expression Statements,  Up: Statements

4.1 Метки
=========

Можно устанавливать идентификацию метками мест исходного кода, для
использования в будущем оператором 'goto' (*note The goto Statement::).
Метка состоит из идентификатора (например, такого, которые используются
для имен переменных), с последующим двоеточием.  Вот пример:

     treet:

   Имена меток не конфликтуют с другими идентификаторами:

     int treet = 5;    /* 'treet' это переменная. */
     treet:            /* 'treet' это метка. */

   Стандартные мандаты ISO C требуют, что за меткой следовало, по
крайней мере, одно выражение, возможно, пустой оператор (*note The Null
Statement::).  GCC будет компилировать код, который не соответствует
этому требованию, но это может повлечь проблемы с переносимостью.


File: gnu-c-manual.info,  Node: Expression Statements,  Next: The if Statement,  Prev: Labels,  Up: Statements

4.2 Выражения Инструкций
========================

Можно превратить любое выражение в инструкцию, добавив точку с запятой в
конце выражения.  Вот некоторые примеры:

     5;
     2 + 2;
     10 >= 9;

   В каждом из них, все, что происходит - это вычисление каждого
выражения.  Тем не менее, это действо бесполезно, потому что нигде не
сохраняется результат, здесь происходит только оценка выражений.
Компилятор может игнорировать подобные инструкции.

   Инструкции выражений тогда полезны, когда имеется побочный эффект,
такой как сохранение значения, вызов функции, или (это эзотерическое)
вызов сбоя в программе.  Вот несколько полезных примеров:

     x++;
     y = x + 25;
     puts ("Привет, пользователь!");
     *cucumber;

   Последняя из этих инструкций, '*cucumber;', потенциально может
вызвать сбой в программе, если значение 'cucumber' вместе не является
допустимым указателем и было объявлено не как 'volatile'.


File: gnu-c-manual.info,  Node: The if Statement,  Next: The switch Statement,  Prev: Expression Statements,  Up: Statements

4.3 Конструкция 'if'
====================

Можно использовать условную конструкцию 'if', чтобы выполнить часть
программы, на основе оценки истинности заданного выражения.  Вот общий
вид конструкции 'if':

     if (ТЕСТ)
       ТОГДА-ЧАСТЬ
     else
       ИНАЧЕ-ЧАСТЬ

   Если выражение ТЕСТ оценено в значение истинна, то вычисляется
ТОГДА-ЧАСТЬ а часть ИНАЧЕ-ЧАСТЬ нет.  Если выражение ТЕСТ оценено в
значение ложь, то ТОГДА-ЧАСТЬ не выполняется, а выполняется ИНАЧЕ-ЧАСТЬ.
Выражение 'else' не является обязательным.

   Вот конкретный пример:

     if (x == 10)
       puts ("x это 10");

   Если выражение 'x == 10' оценивается как истинна, то выполняется
инструкция 'puts ("x это 10");'.  Если 'x == 10' оценивается в значение
ЛОЖЬ, то инструкция 'puts ("x это 10");' не выполняется.  Ниже приведен
пример с использованием 'else':

     if (x == 10)
       puts ("x это 10");
     else
       puts ("x не 10");

   Можно использовать ряд инструкций 'if' для проверки нескольких
условий:

     if (x == 1)
       puts ("x это 1");
     else if (x == 2)
       puts ("x это 2");
     else if (x == 3)
       puts ("x это 3");
     else
       puts ("x что-то другое");

   Эта функция вычисляет и отображает дату Пасхи для заданного года 'y':

     void
     датаПасхи (int y)
     {
       int n = 0;
       int g = (y % 19) + 1;
       int c = (y / 100) + 1;
       int x = ((3 * c) / 4) - 12;
       int z = (((8 * c) + 5) / 25) - 5;
       int d = ((5 * y) / 4) - x - 10;
       int e = ((11 * g) + 20 + z - x) % 30;

       if (((e == 25) && (g > 11)) || (e == 24))
         e++;

       n = 44 - e;

       if (n < 21)
         n += 30;

       n = n + 7 - ((d + n) % 7);

       if (n > 31)
         printf ("Пасха: %d Апрель %d", n - 31, y);
       else
         printf ("Пасха: %d Март %d", n, y);
     }


File: gnu-c-manual.info,  Node: The switch Statement,  Next: The while Statement,  Prev: The if Statement,  Up: Statements

4.4 Переключатель 'switch'
==========================

Можно использовать оператор 'switch' для сравнения одного выражения с
другими для последующего выполнения ряда вспомогательных инструкций,
основанных на результатах сравнения.  Вот общий вид переключателя
'switch':

     switch (ТЕСТ)
       {
         case СРАВНИТЬТЕСТ-1:
           ЕСЛИ-СООТВЕТСТВУЕТ-СРАВНИТЬТЕСТ-1
         case СРАВНИТЬТЕСТ-2:
           ЕСЛИ-СООТВЕТСТВУЕТ-СРАВНИТЬТЕСТ-2
         ...
         default:
           СООТВЕТСТВИЕ-ПО-УМОЛЧАНИЮ
       }

   Инструкция 'switch' сравнивает ТЕСТ с каждым из выражений вариантов
СРАВНИТЬТЕСТ-N, пока не находится то, которое удовлетворяет TEST.  Затем
выполняются вложенные инструкции выбранного варианта.  Все сравниваемые
выражения, должны быть целочисленного типа, и выражения СРАВНИТЬТЕСТ-N
должны быть константами целочисленного типа, как константа целого числа
(например, буквальное целое число или выражение, построенное из
литералов целых чисел).

   При желании можно указать вариант по умолчанию.  Если ТЕСТ не имеет
соответствия ни к одному из конкретных вариантов, перечисленных до
варианта по умолчанию, то выполняются инструкции варианта по умолчанию.
Традиционно, вариант по умолчанию записывается в конце всех вариантов,
но это не обязательно.

     switch (x)
       {
         case 0:
           puts ("x это 0");
           break;
         case 1:
           puts ("x это 1");
           break;
         default:
           puts ("x что-то другое");
           break;
       }

   Использование инструкции 'break' в каждом из вариантов, приводит к
тому, что, в случае выиграша вариантом, выполняются вложенные
утверждения и управление потоком выполнения передаётся после всей
конструкции переключателя 'switch', в обход выполнения всех оставшихся
инструкций переключателя:

     int x = 0;
     switch (x)
       {
         case 0:
           puts ("x это 0");
         case 1:
           puts ("x это 1");
         default:
           puts ("x что-то другое");
       }

Вывод этого же примера без инструкции 'break;':

     x is 0
     x is 1
     x is что-то другое

   Это часто не желательно.  Инструкции 'break;' в конце каждого
варианта перенаправляет поток выполнения программы в точку, сразу после
конструкции переключателя 'switch'.

   В качестве расширения GNU C, можно также указать диапазон
последовательных целочисленных значений в одной метке 'case', как здесь:

     case НАЧАЛО ... ПРЕДЕЛ:

Это имеет тот же эффект, что и соответствующее число отдельных 'case'
меток, по одному для каждого целочисленного значения в диапазоне от
НАЧАЛО до ПРЕДЕЛ включительно.

   Эта функция особенно полезна для диапазонов кодов символов ASCII:

     case 'A' ... 'Z':

   Будьте осторожны, не нужно добавлять пробелы вокруг '...', иначе это
может быть разобрано неправильно, при использовании с целочисленными
значениями.  Например, не нужно писать следующим образом:

     case 1 ... 5:

вместо этого требуется писать так:

     case 1...5:

   Распространено использовать конструкцию переключателя 'switch' для
обработки различных возможных значений конструкции 'errno'.  В этом
случае, для переносимости программы, нужно следить за макросами, которые
используют значение 'errno', которое на самом деле имеет такое же
значение, например как 'EWOULDBLOCK' и 'EAGAIN'.


File: gnu-c-manual.info,  Node: The while Statement,  Next: The do Statement,  Prev: The switch Statement,  Up: Statements

4.5 Конструкция 'while'
=======================

Конструкция 'while' является инструкцией цикла с условием в начале
цикла.  Вот общая форма конструкции 'while':

     while (ТЕСТ)
       ИНСТРУКЦИИ

   Инструкция 'while' вначале оценивает условие ТЕСТ.  Если выражение
ТЕСТ вычислено как истинна, выполняются ИНСТРУКЦИИ, а затем ТЕСТ
оценивается вновь.  ИНСТРУКЦИИ продолжают выполняться до тех пор, пока
условие ТЕСТ оценивается как истина после каждого выполнения инструкций
ИНСТРУКЦИИ.

   Этот пример печатает целые числа от нуля до девяти:

     int counter = 0;
     while (counter < 10)
       printf ("%d ", counter++);

   Инструкция 'break' может также вызвать выход из цикла 'while'.


File: gnu-c-manual.info,  Node: The do Statement,  Next: The for Statement,  Prev: The while Statement,  Up: Statements

4.6 Конструкция 'do'
====================

Конструкция 'do' является инструкцией цикла с условием в конце цикла.
Вот общая форма конструкции 'do':

     do
       ИНСТРУКЦИИ
     while (ТЕСТ);

   Конструкция 'do' вначале выполняет ИНСТРУКЦИИ.  После этого,
оценивается условие ТЕСТ.  Если ТЕСТ оценено в истину, то выполняются
ИНСТРУКЦИИ снова.  ИНСТРУКЦИИ продолжают выполняться до тех пор, пока
условие ТЕСТ будет оцениватся в истину, после каждого выполнения
ИНСТРУКЦИИ.  Этот пример также печатает целые числа от нуля до девяти:

     int x = 0;
     do
       printf ("%d ", x++);
     while (x < 10);

   Инструкция 'break' может также произвести выход из цикла 'do'.


File: gnu-c-manual.info,  Node: The for Statement,  Next: Blocks,  Prev: The do Statement,  Up: Statements

4.7 Конструкция 'for'
=====================

Конструкция 'for' является инструкцией цикла, структура которой
позволяет легко производить инициализацию переменной, проверку условного
выражения и модификацию подконтрольной переменной.  Это очень удобно для
создания счёта контролируемых циклов.  Вот общая форма конструкции
'for':

     for (ИНИЦИАЛИЗАЦИЯ; УСЛОВИЕ; ШАГ)
       ИНСТРУКЦИЯ

   В конструкции 'for' вначале единократно вычисляется выражение
ИНИЦИАЛИЗАЦИЯ.  Затем вычисляется выражение УСЛОВИЕ.  Если результат
оценки выражения УСЛОВИЕ устанавливается в ложь, то цикл завершается и
программа продолжает выполнение, не вычисляя выражение ИНСТРУКЦИЯ, уже
после всей конструкции.  В противном случае, если УСЛОВИЕ оценивается в
истину, то вычисляется выражение ИНСТРУКЦИЯ.  Наконец, оценивается
выражение ШАГ, и следующая итерация цикла начинается снова с оценки
выражения УСЛОВИЕ.

   Чаще всего, в выражении ИНИЦИАЛИЗАЦИЯ присваивается значения одной
или нескольким переменным, которые обычно используются в качестве
счётчиков, УСЛОВИЕ сравнивает значения этих переменных с заранее
заданным выражением,выражение ШАГ модифицирует значения этих переменных.
Вот один пример, который печатает целые числа от нуля до девяти:

     int x;
     for (x = 0; x < 10; x++)
       printf ("%d ", x);

   Во-первых, выполняется инструкция ИНИЦИАЛИЗАЦИЯ - 'x = 0;',
присваивается переменной 'x' значение 0.  Затем, выполняется инструкция
УСЛОВИЕ - 'x < 10;', так как 'x' меньше, чем 10, то значение инструкции
устанавливается в истину и выполняется инструкция 'инструкция' и 'x'
печатается (в теле цикла).  Затем 'x' увеличивается в инструкции ШАГ и
цикл переходит снова к оценки выражения УСЛОВИЕ.

   Все три из выражений конструкции 'for' не являются обязательными, и
любая комбинация из трёх - является допустимой.  Так как первое
выражение вычисляется только один раз, наиболее часто это выражение
опущено.  Также можно переписать приведенный выше пример, как:

     int x = 1;
     for (; x <= 10; x++)
       printf ("%d ", x);

В этом примере, 'x' получает свое значение до начала конструкции 'for'.

   Если опущена инструкция УСЛОВИЕ, то конструкция 'for' произведёт
бесконечный цикл (если не поставить инструкцию 'break' или 'goto' где-то
в инструкции ИНСТРУКЦИИ).  Это похоже на использование в качестве
выражения УСЛОВИЕ константого значения '1', что сделает значение условия
всегда истинным.

   Эта конструкция 'for' начинает печатать числа с 1, а затем
продолжается до бесконечности, всегда перед печатью, 'x' увеличивается
на 1:

     for (x = 1; ; x++)
       printf ("%d ", x);

   Если опущенно выражение ШАГ, то не будет никакого процеса завершения
цикла-- по крайней мере, в разрезе нормального функционирования
конструкции 'for'.

   Этот пример печатает номер 1 снова и снова, бесконечно:

     for (x = 1; x <= 10;)
       printf ("%d ", x);

   Нельзя использовать оператор запятая (*note The Comma Operator::) для
мониторинга нескольких переменных в условии конструкции 'for', потому
что, оператор запятая, отбрасывает результат оценки своего левого
операнда.  Пример цикла:

     int x, y;
     for (x = 1, y = 10; x <= 10, y >= 1; x+=2, y--)
       printf ("%d %d\n", x, y);

Вывод:

     1 10
     3 9
     5 8
     7 7
     9 6
     11 5
     13 4
     15 3
     17 2
     19 1

   Если необходимо проверить два условия, нужно будет использовать
оператор '&&':

     int x, y;
     for (x = 1, y = 10; x <= 10 && y >= 1; x+=2, y--)
       printf ("%d %d\n", x, y);

   Инструкция 'break' может также произвести выход из цикла 'for'.

   Ниже приведен пример функции, которая вычисляет сумму квадратов
последовательных чисел, заданных в диапазоне от начального значения
числа, до максимально допустимого значения итоговой суммы:

     int
     sum_of_squares (int start, int end)
     {
       int i, sum = 0;
       for (i = start; i <= end; i++)
         sum += i * i;
       return sum;
     }


File: gnu-c-manual.info,  Node: Blocks,  Next: The Null Statement,  Prev: The for Statement,  Up: Statements

4.8 Блоки
=========

"Блок" представляет собой набор из нуля или более инструкций,
заключенных в фигурные скобки.  Блоки также известны как "составные
инструкции".  Часто, блок используется как тело конструкции 'if' или в
конструкциях цикла, чтобы группировать инструкции вместе.

     for (x = 1; x <= 10; x++)
       {
         printf ("значение x это %d\n", x);

         if ((x % 2) == 0)
           printf ("%d это чётное\n", x);
         else
           printf ("%d это нечётное\n", x);
       }

   Также можно помещать блоки внутри других блоков:

     for (x = 1; x <= 10; x++)
       {
         if ((x % 2) == 0)
           {
             printf ("x значение это %d\n", x);
             printf ("%d чётное число\n", x);
           }
         else
           {
             printf ("x значение это %d\n", x);
             printf ("%d не чётное число\n", x);
           }
       }

   Можно объявлять переменные внутри блока; такие переменные являются
локальными по отношению к этому блоку.  В C89, объявление переменных
должно происходить до их использования в инструкциях и поэтому иногда
полезно ввести блок конкретно только для этой цели:

     {
       int x = 5;
       printf ("%d\n", x);
     }
     printf ("%d\n", x);   /* Ошибка компиляции! 'x' существует
                            только в предыдущем блоке. */


File: gnu-c-manual.info,  Node: The Null Statement,  Next: The goto Statement,  Prev: Blocks,  Up: Statements

4.9 Инструкция Null
===================

"NULL инструкция" - просто точка с запятой.

     ;

   Null инструкция ничего не делает.  Нигде не хранит значения.  Не
вызывает трату времени во время выполнения программы.

   Чаще всего, пустой оператор используется как в теле инструкции цикла,
или в качестве одного или нескольких выражений инструкции 'for'.  Вот
пример инструкции 'for', где используется инструкция 'Null', как тело
цикла (вычисляется целочисленный квадратный корень из значения 'n',
просто для удовольствия):

     for (i = 1; i*i < n; i++)
       ;

   Вот еще один пример, который использует 'Null' инструкцию в качестве
тела цикла 'for', а также производит вывод:

     for (x = 1; x <= 5; printf ("x сейчас %d\n", x), x++)
       ;

   Инструкция 'Null' также используется следом за меткой, в противном
случае, метка была бы последней в блоке.


File: gnu-c-manual.info,  Node: The goto Statement,  Next: The break Statement,  Prev: The Null Statement,  Up: Statements

4.10 Инструкция 'goto'
======================

Можно использовать инструкцию 'goto' для безоговорочного перехода к
другому месту в программе.  Вот общий вид инструкции 'goto':

     goto МЕТКА;

   Указана метка для перехода оператором 'goto', когда программа
достигает этой метки.  *Note Labels::.  Вот пример:

     goto end_of_program;
     ...
     end_of_program:

   Метка может распологаться в той же функции, что и инструкция 'goto' и
передавать управление туда, инструкция 'goto' не может перевести
управление выполнения к метке расположенной в другой функции.

   Инструкцию 'goto' _можно_ использовать для ИМИТАЦИИ цикла, но не
рекомендуется так поступать -- программа становится трудной для чтения,
и GCC не сможет оптимизировать такой код.  Нужно использовать
конструкции циклов 'for', 'while' и 'do' вместо инструкции 'goto', когда
это возможно.

   В качестве расширения, GCC позволяет инструкции 'goto' осуществлять
переход к адресу, указанному в переменной 'void*'.  Для того, чтобы это
совершить, нужно взять адрес метки с помощью одинарного оператора '&&'
(не '&').  Вот надуманный пример:

     enum Play { ROCK=0, PAPER=1, SCISSORS=2 };
     enum Result { WIN, LOSE, DRAW };

     static enum Result turn (void)
     {
       const void * const jumptable[] = {&&rock, &&paper, &&scissors};
       enum Play opp;                /* opponent's play */
       goto *jumptable[select_option (&opp)];
      rock:
       return opp == ROCK ? DRAW : (opp == PAPER ? LOSE : WIN);
      paper:
       return opp == ROCK ? WIN  : (opp == PAPER ? DRAW : LOSE);
      scissors:
       return opp == ROCK ? LOSE : (opp == PAPER ? WIN  : DRAW);
     }


File: gnu-c-manual.info,  Node: The break Statement,  Next: The continue Statement,  Prev: The goto Statement,  Up: Statements

4.11 Инструкция 'break'
=======================

Можно использовать инструкцию 'break', чтобы прервать выполнение
конструкций 'while', 'do', 'for', или 'switch'.  Вот пример:

     int x;
     for (x = 1; x <= 10; x++)
       {
         if (x == 8)
           break;
         else
           printf ("%d ", x);
       }

   Этот пример печатает числа от 1 до 7.  Когда 'x' увеличивается до 8,
выражение условия 'x == 8' возвращает результат истина и выполняется
инструкция 'break', завершающая выполнение инструкции цикла 'for'
преждевременно.

   Если присутствует инструкция 'break' внутри инструкции цикла или
инструкции 'switch', которая сама находится внутри инструкции цикла или
инструкции 'switch', то инструкция 'break' сработывает только для
вложенного цикла или 'switch'.


File: gnu-c-manual.info,  Node: The continue Statement,  Next: The return Statement,  Prev: The break Statement,  Up: Statements

4.12 Инструкция 'continue'
==========================

Можно использовать инструкцию 'continue' в циклах для прекращения
текущей итерации цикла и перехода к следующей итерации.  Вот пример:

     for (x = 0; x < 100; x++)
       {
         if (x % 2 == 0)
           continue;
         else
           sum_of_odd_numbers + = x;
       }

   Если поставить инструкцию 'continue' внутри цикла, который сам
находится внутри цикла, то это повлияет только на внутренний цикл.


File: gnu-c-manual.info,  Node: The return Statement,  Next: The typedef Statement,  Prev: The continue Statement,  Up: Statements

4.13 Инструкция 'return'
========================

Можно использовать инструкцию 'return' для прекращения выполнения
функции и возврата управления программе из функцию, которая её вызвала.
Вот общая форма инструкции 'return':

     return ВОЗВРАЩАЕМОЕ-ЗНАЧЕНИЕ;

   ВОЗВРАЩАЕМОЕ-ЗНАЧЕНИЕ является необязательным выражением для
возврата.  Если тип возвращаемого знечения функции объявлен как 'void',
то функция возвращает значение неопределено.  Можно, однако,
использовать оператор 'return' без указания возвращаемого значения.

   Если возвращаемый тип значения функции не совпадает с указанным типом
ВОЗВРАЩАЕМОЕ-ЗНАЧЕНИЕ и автоматическое преобразование типа не может быть
выполнено, то возвращаемое значение ВОЗВРАЩАЕМОЕ-ЗНАЧЕНИЕ является
неопределенно.

   Если функция возвращает значение типа отличным от 'void', то
инструкция 'return' допустима, если функция вызывается в контексте,
который требует возврата значения.  Например:

     x = cosine (y);

   В этом случае функции 'cosine' была вызвана в контексте требования
возврата значения, так что бы значение могло быть присвоено 'x'.

   Даже в условиях, когда не требуется использовать возвращаемое
значение функции, плохая идея вызов функции с возвращаемым не-'void'
типом значения, опускать это значение.  В GCC, можно использовать
параметр командной строки '-Wreturn-type' для выдачи предупреждений,
если опускается возвращаемое значение при вызове таких функций.

   Вот некоторые примеры использования оператора 'return', как в
функциях с возвращаемым типом значения 'void' и так и значением с типом
не-'void':

     void
     print_plus_five (int x)
     {
       printf ("%d ", x + 5);
       return;
     }

     int
     square_value (int x)
     {
       return x * x;
     }


File: gnu-c-manual.info,  Node: The typedef Statement,  Prev: The return Statement,  Up: Statements

4.14 Инструкция 'typedef'
=========================

Можно использовать инструкцию 'typedef' для создания новых имен для
типов данных.  Вот общая форма инструкции 'typedef':

     typedef ПРЕЖДНЕЕ-ИМЯ-ТИПА НОВОЕ-ИМЯ-ТИПА

   ПРЕЖДНЕЕ-ИМЯ-ТИПА этого имя существующего типа данных, возможно
объявленного с использованием более чем одного спецификатора (например,
'unsigned long int').  НОВОЕ-ИМЯ-ТИПА является назачением нового имени
для данного типа, и должно быть допустимым идентификатором.  Создание
этого нового имени для заданного типа не прекращает существование
прежднего.  Вот некоторые примеры:

     typedef unsigned char byte_type;
     typedef double real_number_type;

В случае пользовательских типов данных, можно использовать 'typedef' для
создания нового имени типа, сразу при при определении типа:

     typedef struct fish
     {
       float weight;
       float length;
       float probability_of_being_caught;
     } fish_type;

Для того, чтобы определить новый тип массива, вначале указывается тип
элементов массива, затем количество элементов и, в конце определения,
указывается имя нового типа:

     typedef char array_of_bytes [5];
     array_of_bytes five_bytes = {0, 1, 2, 3, 4};

   При выборе имени типу, нужно избегать завершение имени типа суффиксом
'_t'.  Компилятор позволит это сделать, но POSIX резервирует
использование '_t' суффикса в именах типов стандартных библиотек.


File: gnu-c-manual.info,  Node: Functions,  Next: Program Structure and Scope,  Prev: Statements,  Up: Top

5 Функции
*********

Можно написать функции для разделения частей программы на подпроераммы.
Чтобы написать функцию, необходимо, по крайней мере создать определение
функции.  Это хорошая идея также иметь явное объявление функции.  Это не
требуется в обязательном порядке, но неявное объявление по умолчанию
может не соответствовать самой функции, и во время компиляции могут
возникнуть предупреждения.

   В каждой программе требуется, по меньшей мере, одна функция, которая
именуется 'main'.  То есть, место с чего начинается выполнение
программы.

* Menu:

* Function Declarations::
* Function Definitions::
* Calling Functions::
* Function Parameters::
* Variable Length Parameter Lists::
* Calling Functions Through Function Pointers::
* The main Function::
* Recursive Functions::
* Static Functions::
* Nested Functions::


File: gnu-c-manual.info,  Node: Function Declarations,  Next: Function Definitions,  Up: Functions

5.1 Объявление Функции
======================

В объявление функции, указывается имя функции, список параметров и тип
возвращаемого функцией значения.  Объявление функции заканчивается
точкой с запятой.  Вот общий вид:

     ТИП-ВОЗВРАЩАЕМОГО-ЗНАЧЕНИЯ ИМЯ-ФУНКЦИИ (СПИСОК-ПАРАМЕТРОВ);

   ТИП-ВОЗВРАЩАЕМОГО-ЗНАЧЕНИЯ указывает тип данных значения,
возвращаемого функцией.  Можно объявить функцию, которая не возвращает
ничего, используя тип возвращаемого значения 'void'.

   ИМЯ-ФУНКЦИИ может быть любой допустимый идентификатор (*note
Identifiers::).

   СПИСОК-ПАРАМЕТРОВ состоит из нуля или более параметров, разделенных
запятыми.  Типичная запись параметра состоит из типа данных и
необязательного имени параметра.  Также объявляется функция, которая
имеет переменное число параметров (*note Variable Length Parameter
Lists::), или не содержит совсем параметров, отмечается с помощью
'void'.  Полностью отсутствующий СПИСОК-ПАРАМЕТРОВ, также указывает на
то, что функция не использует никаких параметров, но лучше явное
указание отсутствия с помощью 'void'.

   Вот пример объявления функции с двумя параметрами:

     int foo (int, double);

   Если включить имя параметра, имя следует непосредственно после
указания типа данных, например:

     int foo (int x, double y);

   Имя параметра может быть любой идентификатор (*note Identifiers::), и
если есть более одного параметра, нельзя использовать одно и то же имя,
более одного раза в одном объявлении.  Имена параметров в объявлении не
обязательно должны совпадать с именами в определении.

   Объявление функции требуется до первого использования этой функции.
Можно поместить его в заголовочный файл и использовать директиву
'#include', чтобы включить объявление этой функцию в любых файлах
исходного кода, которые используют функцию.


File: gnu-c-manual.info,  Node: Function Definitions,  Next: Calling Functions,  Prev: Function Declarations,  Up: Functions

5.2 Определение функции
=======================

Определение функции, служит для того, чтобы указать, что функция на
самом деле делает.  Определение функции состоит из информации: имени
функции, типа возвращаемого значения, типов и именах параметров, тела
функции.  Тело функции представляет собой ряд инструкций, заключенных в
скобки, на самом деле это просто блок (*note Blocks::).

   Вот общий вид определения функции:

     ТИП-ВОЗВРАЩАЕМОГО-ЗНАЧЕНИЯ
     ИМЯ-ФУНКЦИИ (СПИСОК-ПАРАМЕТРОВ)
     {
       ТЕЛО-ФУНКЦИИ
     }

   ТИП-ВОЗВРАЩИЕМОГО-ЗНАЧЕНИЯ и ИМЯ-ФУНКЦИИ такие же, как используются в
объявлении функции (*note Function Declarations::).  СПИСОК-ПАРАМЕТРОВ
такой же, как и список параметров, используемый в объявлении функции
(*note Function Declarations::), за исключением того, что _обязательно_
включаются имена параметров в определении функции.

   Вот простой пример определения функции -- она ​​принимает два целых
числа в качестве её параметров и возвращает их сумму в возвращаемом
значении:

     int
     add_values (int x, int y)
     {
       return x + y;
     }

   Для совместимости с оригинальным C, также требуется указать тип
параметров функции _после_ закрывающей скобкой списка параметров, так:

     int
     add_values (x, y)
         int x, int y;
     {
       return x + y;
     }


   Тем не менее, не рекомендуется этот стиль кодирования; это может
вызвать тонкие проблемы с приведением типов, наряду с другими
проблемами.


File: gnu-c-manual.info,  Node: Calling Functions,  Next: Function Parameters,  Prev: Function Definitions,  Up: Functions

5.3 Вызов Функции
=================

Можно вызвать функцию, используя её имя и передав значения параметров.
Вот общий вид вызова функции:

     ИМЯ-ФУНКЦИИ (ПАРАМЕТРЫ)

   Вызов функции может составить целую инструкцию, или может быть
использован в качестве подвыражения.  Вот пример полной инструкции
вызова функции:

     foo (5);

В этом примере функция 'foo' вызывается с параметром '5'.

   Ниже приведен пример вызова функции, используемый в качестве
подвыражения:

     a = square (5);

Предпологая, что функция 'square' возводит в квадрат ее параметр,
приведенный выше пример присваивает значение 25 переменной 'a'.

   Если список параметров принимает более одного аргумента, то отдельные
параметры разделяются запятой:

     a = quux (5, 10);


File: gnu-c-manual.info,  Node: Function Parameters,  Next: Variable Length Parameter Lists,  Prev: Calling Functions,  Up: Functions

5.4 Параметры Функции
=====================

Параметр функции может быть любым выражением -- буквальным значением,
значением, сохраненным в переменной, адресом в памяти, или более сложным
выражением путём объединения этого.

   В теле функции, параметр является локальной копией значения,
переданного в функцию, поэтому нельзя изменить само переданное
параметром значение, изменяя его локальную копию.

     int x = 23;
     foo (x);
     ...
     /* Определение функции 'foo'. */
     int foo (int a)
     {
       a = 2 * a;
       return a;
     }

В этом примере, даже если 'a' параметр изменяется в функции 'foo',
переменная 'x', которая передается функции как параметр не меняется.
Если требуется использовать функцию, чтобы изменить исходное значение
'x', используется вызов функции в операторе присваивания:

     x = foo (x);

   Если значение, передаваемое функции в качестве параметра является
адресом памяти (то есть указателем), то можно получить доступ (и
изменить) данные, хранящиеся в памяти по адресу.  Благодаря этому
достигается эффект, схожий передачи в параметре по ссылке в других
языках, но это не то же самое: адрес в памяти - это просто значение, так
же как и любое другое значение, и само по себе не может быть изменено.
Разница между передачей указателя и передачи целого числа состоим в том,
что можно использовать значение указателя в пределах тела функции.

   Вот пример вызова функции в качестве указателя в параметре:

     void
     foo (int *x)
     {
       *x = *x + 42;
     }
     ...
     int a = 15;
     foo (&a);

Формальный параметр для функции имеет тип указатель-на-тип-'int', и
функция вызывается с передачей в качестве параметра значения адреса
переменной типа 'int'.  Разыменовав указатель в пределах тела функции,
можно получить и изменить значение, находящееся по значению адреса.
Выше изменяется значение переменной 'a' в значение '57'.

   Даже если не требуется изменение значения, сохраненного в адресе,
передавая адрес переменной, а не саму переменную саму по себе, может
быть полезным, если тип переменной слишком велик, и необходима экономия
памяти или ограничить влияние на производительность при копировании
параметра.  Например:

     struct foo
     {
       int x;
       float y;
       double z;
     };

     void bar (const struct foo *a);

В том случае, если работа выпролняется на компьютере с не очень большими
адресами памяти, он будет занимать меньше памяти, передача указателя на
структуру, чем передача экземпляря структуры.

   Один из типов параметров, который всегда передаётся как указатель -
это любой вид массива:

     void foo (int a[]);
     ...
     int x[100];
     foo (x);

В этом примере, вызов функции 'foo' с параметром 'a' не производит
копированее всего массива в локальную переменную параметра 'foo',
передаётся в параметре 'x' указатель на первый элемент массива 'x'.
Нужно проявлять осторожность: в пределах функции, нельза использовать
'sizeof', чтобы определить размер массива 'x'--'sizeof' вместо этого
укажет размер указателя 'x'.  Действительно, указаный выше код
эквивалентен:

     void foo (int *a);
     ...
     int x[100];
     foo (x);

Явное указание длины массива в объявлении параметра не поможет.  Если
действительно нужно передать массив по значению, можно обернуть его в
'struct', хотя это редко бывает полезно (обычно достаточно передавать
указатель с 'const'-спецификатором, чтобы показать, что вызваший код не
должен изменять массив).


File: gnu-c-manual.info,  Node: Variable Length Parameter Lists,  Next: Calling Functions Through Function Pointers,  Prev: Function Parameters,  Up: Functions

5.5 Список Параметров Функции Переменной Длинны
===============================================

Можно написать функцию, которая принимает переменное число аргументов,
такие функции называются "вариативными функциями".  Чтобы получить это,
функция должна иметь, по меньшей мере, один параметр известного типа
данных, а остальные параметры являются необязательными и могут
различаться по количеству и типу данных.

   Перечисляются начальные параметры, как обычно, но после этого,
используется многоточие: '...'.  Вот пример прототипа функции:

     int add_multiple_values (int number, ...);

   Для работы с дополнительными параметрами в определении функции, нужно
использовать макросц, которые определены в библиотеке заголовочного
файла '<stdarg.h>', так что требуется включить '#include' этот файл.
Подробное описание этих макросов, раздел 'The GNU C Library' руководства
по переменному числу параметров функций.

   Вот пример:

     int
     add_multiple_values (int number, ...)
     {
       int counter, total = 0;

       /* Объявляется переменная типа 'va_list'. */
       va_list parameters;

       /* Вызов функции 'va_start'. */
       va_start (parameters, number);

       for (counter = 0; counter < number; counter++)
         {
           /* Получение значений дополнительных параметров. */
           total += va_arg (parameters, int);
         }

       /* Итоговое присвоение переменной 'parameters'. */
       va_end (parameters);

       return total;
     }

   Для использования дополнительных параметров, нужно знать, сколько их
есть.  Это количество может варьироваться, поэтому не задаётся жестко,
но если не известно точное количество необязательных параметров, то
могут возникнуть трудности, когда требуется прекратить использование
функции 'va_arg'.  В приведенном выше примере, первый параметр функции
'add_multiple_values', 'number', это количество для передачи
необязательных параметров.  Таким образом, можно вызвать функцию так:

     sum = add_multiple_values (3, 12, 34, 190);

   Первый параметр указывает на то, сколько дополнительных параметров
следуют за ним.

   Кроме того, можно обратить внимание, что на самом деле не нужно
использовать функцию 'va_end'.  В самом деле, при использовании GCC
совсем ничего не произойдёт.  Тем не менее, можно включить это для
обеспечения максимальной совместимости с другими компиляторами.

   *Note Variadic Functions: (libc)Variadic Functions.


File: gnu-c-manual.info,  Node: Calling Functions Through Function Pointers,  Next: The main Function,  Prev: Variable Length Parameter Lists,  Up: Functions

5.6 Вызов Функции Через Указатель на Функцию
============================================

Можно также вызвать функцию, используя на неё указателя.  Оператор
разыменования '*' не является обязательным при выполнении этого.

     #include <stdio.h>

     void foo (int i)
     {
       printf ("foo %d!\n", i);
     }

     void bar (int i)
     {
       printf ("%d bar!\n", i);
     }

     void message (void (*func)(int), int times)
     {
       int j;
       for (j=0; j<times; ++j)
         func (j);  /* (*func) (j); будет эквивалентно. */
     }

     void example (int want_foo)
     {
       void (*pf)(int) = &bar; /* The & is optional. */
       if (want_foo)
         pf = foo;
       message (pf, 5);
     }


File: gnu-c-manual.info,  Node: The main Function,  Next: Recursive Functions,  Prev: Calling Functions Through Function Pointers,  Up: Functions

5.7 Функция 'main'
==================

Каждая программа требует, по меньшей мере, одну функцию, которая имеет
имя 'main'.  Это то, где программа начинает выполняться.  Не нужно
писать объявление или прототип функции 'main', но требуется определить
её.

   Возвращаемый тип значения функции 'main' всегда тип 'int'.  Не
требуется обязательно указывать тип возвращаемого значения 'main', но
можно.  Тем не менее, _нельзя_ указать, что возвращаемое значение имеет
тип отличныей от 'int'.

   В общем, возвращаемое значение функцей 'main' указывает "статус
возврата" программы.  Нулевое значение или EXIT_SUCCESS указывает на
успех и EXIT_FAILURE указывает на ошибку.  В противном случае, значение
возвращаемого значения зависит от реализации.

   Достижение выполнением программы '}' в конце тела функции 'main' без
указания возврата значения или использовании 'return' без указания
возвращаемого значения (то есть, 'return;') являются эквивалентными.  В
C89, эффект этого не определен, но в C99 эффект эквивалентен вызову
'return 0;'.

   Можно написать функцию 'main' не имеющую никаких параметров (то есть,
как 'int main (void)'), или принимающую параметры из командной строки.
Вот очень простая функция 'main' без параметров:

     int
     main (void)
     {
       puts ("Всем привет!");
       return 0;
     }

   Чтобы принять параметры командной строки, необходимо иметь два
параметра в функции 'main', 'int argc' с последующим 'char *argv[]'.
Можно изменить имена этих параметров, но они должны иметь типы
данных--'int' и массив указателей на тип 'char'.  'argc' указывает
количество параметров командной строки, в том числе параметр с именем
самой программы.  'argv' представляет собой массив параметров, как
строки символов.  'argv[0]', первый элемент в массиве, это имя
программы, как и набирается в командной строке(1); любые следующие
элементы массива являются параметрами, которые следуют за именем
программы.

   Ниже приведен пример функции 'main', которая принимает параметры
командной строки, и выводит то, что передаётся этими параметрами:

     int
     main (int argc, char *argv[])
     {
       int counter;

       for (counter = 0; counter < argc; counter++)
         printf ("%s\n", argv[counter]);

       return 0;
     }

   ---------- Footnotes ----------

   (1) Редко, 'argv[0]' может быть NULL указателем (в этом случае 'argc'
это 0) или 'argv[0][0]' может быть нулевым символом.  В любом случае,
'argv[argc]' является NULL указателем.


File: gnu-c-manual.info,  Node: Recursive Functions,  Next: Static Functions,  Prev: The main Function,  Up: Functions

5.8 Рекурсивные Функции
=======================

Можно написать функцию, которая является рекурсивной -- функцией,
которая вызывает саму себя.  Ниже приведен пример, вычисления факториала
целого числа:

     int
     factorial (int x)
     {
       if (x < 1)
         return 1;
       else
         return (x * factorial (x - 1));
     }

   Нужно быть осторожным, что не написать функцию, которая является
бесконечно рекурсивной.  В приведенном выше примере, как только 'x'
равно 1, то рекурсия останавливается.  Однако, в следующем примере,
рекурсия не останавливается, пока программа не будет прервана
принудительно или пока не произойдёт переполнение памяти:

     int
     watermelon (int x)
     {
       return (watermelon (x));
     }

   Функции могут быть конечно косвенно рекурсивными.
(ВопросFunctions579)


File: gnu-c-manual.info,  Node: Static Functions,  Next: Nested Functions,  Prev: Recursive Functions,  Up: Functions

5.9 Статические Функции
=======================

Можно определить статическую функцию, если требуется совершать её вызов
из любого места в пределах исходного файла, в котором она определена:

     static int
     foo (int x)
     {
       return x + 42;
     }

Это полезно, если строится библиотека многоразового использования
функций и она включает в себя некоторые подпрограммы, которые не должно
быть вызваны конечным пользователем.

   Функции, которые определены таким образом, имеют так сказать,
"статическую связь".  К сожалению, 'static' ключевое слово имеет
несколько значений; *note Storage Class Specifiers::.


File: gnu-c-manual.info,  Node: Nested Functions,  Prev: Static Functions,  Up: Functions

5.10 Вложенные Функции
======================

В качестве расширения GNU C, можно определить функции внутри других
функций, метод, известный как вложенности функций.

   Ниже приведен пример функции факториала хвостовой рекурсии,
определенной с помощью вложенной функции:

     int
     factorial (int x)
     {
       int
       factorial_helper (int a, int b)
       {
         if (a < 1)
         {
           return b;
         }
         else
         {
           return factorial_helper ((a - 1), (a * b));
         }
       }

      return factorial_helper (x, 1);
     }

   Внимание, вложенные функции должны быть определены вместе с
объявлениями переменных в начале функции, а все остальные инструкции
следуют строго после.


File: gnu-c-manual.info,  Node: Program Structure and Scope,  Next: A Sample Program,  Prev: Functions,  Up: Top

6 Структура Программы и Области
*******************************

Теперь, когда показаны все из основных элементов программ C, пришло
время взглянуть на общую картину.

* Menu:

* Program Structure::
* Scope::


File: gnu-c-manual.info,  Node: Program Structure,  Next: Scope,  Up: Program Structure and Scope

6.1 Структура Программы
=======================

Программа C может существовать полностью в пределах одного исходного
файла, но чаще всего, любая нетривиальная программа будет состоять из
нескольких пользовательских заголовочных и исходных файлов, а также
включать в себя связи с файлами из существующих библиотек.

   По соглашению, заголовочные файлы (с расширением ".h") содержат
объявления переменных и функций, а исходные файлы (с расширением ".c")
содержат соответствующие определения.  Исходные файлы могут также
хранить объявление, если эти объявления объектов не предназначаются для
использования из кода других файлов.  Тем не менее, заголовочные файлы
почти наверняка не будут содержать каких-либо определений.

   Например, при написании функции, которая вычисляет квадратные корни и
требуется реализация возможности доступа к ней из функций, определённых
не в том же файле, где определена вызываемая функция, тогда нужно
поместить объявление функции в заголовочный файл (файв с расширением
".h"):

     /* sqrt.h */

     double
     computeSqrt (double x);

Этот заголовочный файл может быть включен в другие исходные файлы, где
требуется использование этой функцию, и не нужно даже знать, как это
было реализовано.

   Реализация самой функции, может затем быть помещена в определённый
исходный файл (с расширением имени файла ".c"):

     /* sqrt.c */
     #include "sqrt.h"

     double
     computeSqrt (double x)
     {
       double result;
       ...
       return result;
     }


File: gnu-c-manual.info,  Node: Scope,  Prev: Program Structure,  Up: Program Structure and Scope

6.2 Связывание
==============

Связывание относится к тому, что части программы "видят" объявленный
объект.  Объявленный объект может быть виден только в пределах
конкретной функции, в пределах определенного файла или может быть виден
всему набору файлов, путем включения заголовочных файлов и использования
при объявлении идентификатора 'extern'.

   Если явно не указано иное, объявление, сделанное на верхнем уровне
файла (т.е.  не в нутри функции), видно для всего файла, в том числе
внутри функции, но не видно за пределами файла.

   Объявления, сделанные внутри функции видны только в пределах этой
функции.

   Вновь созданные объявления, затеняют предыдущие объявления, например:

     int x = 5;
     int y = x + 10;

будет работать, но:

     int x = y + 10;
     int y = 5;

не будет.

   *Note Storage Class Specifiers::, для получения дополнительной
информации об изменении связывания объявленных объектов.  Также смотреть
*note Static Functions::.


File: gnu-c-manual.info,  Node: A Sample Program,  Next: Overflow,  Prev: Program Structure and Scope,  Up: Top

7 Примеры Программ
******************

Чтобы завершить наше описание C, вот полная программа, написанная на C,
состоящая как из исходного файла C, так и из файла заголовка.  Эта
программа является расширенной версией типичной программы "привет мир" и
служит примером того, как форматировать и структурировать код C для
использования в программах для FSF Project GNU. (Вы всегда можете
загрузить самую последнюю версию этой программы, включая образцы
make-файлов и другие примеры создания программного обеспечения GNU, с
'http://www.gnu.org/software/hello'.)

   Эта программа использует возможности препроцессора; для описания
макросов препроцессора смотреть 'The C Preprocessor', доступна как часть
документации GCC.

* Menu:

* hello.c::
* system.h::


File: gnu-c-manual.info,  Node: hello.c,  Next: system.h,  Up: A Sample Program

7.1 'hello.c'
=============

     /* hello.c -- распечатать приветственное сообщение и выйти.

        Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
        2005, 2006, 2007 Free Software Foundation, Inc.

        Это бесплатное программное обеспечение; вы можете распространять и/или
        изменять его в соответствии с условиями Стандартной общественной лицензии
        GNU, опубликованной Free Software Foundation; либо версии 3, либо (по
        вашему выбору) любой более поздней версии.

        Эта программа распространяется в надежде, что она будет полезной, но
        БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ; даже без подразумеваемой гарантии
        КОММЕРЧЕСКОЙ ЦЕННОСТИ или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ. Подробнее
        смотреть Стандартную общественную лицензию GNU.

        Вы должны были получить копию Стандартной общественной лицензии GNU вместе
        с этой программой; если нет, напишите в Free Software Foundation,
        Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */

     #include <config.h>
     #include "system.h"

     /* Строка, содержащая имя, с которым вызывается программа.  */
     const char *program_name;

     static const struct option longopts[] =
     {
       { "greeting", required_argument, NULL, 'g' },
       { "help", no_argument, NULL, 'h' },
       { "next-generation", no_argument, NULL, 'n' },
       { "traditional", no_argument, NULL, 't' },
       { "version", no_argument, NULL, 'v' },
       { NULL, 0, NULL, 0 }
     };

     static void print_help (void);
     static void print_version (void);

     int
     main (int argc, char *argv[])
     {
       int optc;
       int t = 0, n = 0, lose = 0;
       const char *greeting = NULL;

       program_name = argv[0];

       /* Установить локаль через LC_ALL.  */
       setlocale (LC_ALL, "");

     #if ENABLE_NLS
       /* Установить домен текстового сообщения.  */
       bindtextdomain (PACKAGE, LOCALEDIR);
       textdomain (PACKAGE);
     #endif

       /* Даже у вывода есть свои тонкости.  Устройство /dev/full на GNU/Linux
       можно использовать для проверки правильности проверки записи.  Например,
       hello >/dev/full должно завершиться неудачно.  При выходе, если какая-либо
       запись не удалась, измените статус возврата.  Это реализовано в модуле
       Gnulib "closeout"..  */
       atexit (close_stdout);

       while ((optc = getopt_long (argc, argv, "g:hntv", longopts, NULL)) != -1)
         switch (optc)
           {
           /* Одна из целей здесь - немедленный выход после --help и --version в
           соответствии со стандартами кодирования GNU.  */
           case 'v':
             print_version ();
             exit (EXIT_SUCCESS);
             break;
           case 'g':
             greeting = optarg;
             break;
           case 'h':
             print_help ();
             exit (EXIT_SUCCESS);
             break;
           case 'n':
             n = 1;
             break;
           case 't':
             t = 1;
             break;
           default:
             lose = 1;
             break;
           }

       if (lose || optind < argc)
         {
           /* Распечатать сообщение об ошибке и выйти.  */
           if (optind < argc)
             fprintf (stderr, _("%s: дополнительный операнд: %s\n"),
     		 program_name, argv[optind]);
           fprintf (stderr, _("Попробуйте `%s --help' для доп. информации.\n"),
                    program_name);
           exit (EXIT_FAILURE);
         }

       /* Распечатать сообщение приветствия и выйти. */
       if (t)
         printf (_("привет, мир\n"));

       else if (n)
         /* ПЕРЕВОДЧИКИ: используйте символы рисования прямоугольников или другие
         причудливые вещи, если ваша кодировка (например, UTF-8) это позволяет.
         В этом случае добавьте следующее примечание:

            [Примечание.  Для наилучшего просмотра используйте локаль UTF-8.]
         */
     	printf (_("\
     +---------------+\n\
     | Привет, мир!  |\n\
     +---------------+\n\
     "));

       else
         {
           if (!greeting)
             greeting = _("Привет, мир!");
           puts (greeting);
         }

       exit (EXIT_SUCCESS);
     }



     /* Распечатать справочную информацию.  Это длинное сообщение разделено на
     несколько частей, чтобы переводчики могли выровнять разные блоки и
     идентифицировать различные части.  */

     static void
     print_help (void)
     {
       /* ПЕРЕВОДЧИКИ: --help output 1 (synopsis) не-заворачивать */
             printf (_("\
     Использовать: %s [OPTION]...\n"), program_name);

       /* ПЕРЕВОДЧИКИ: --help output 2 (краткое описание)
          не-оборачивать */
       fputs (_("\
     Распечатайте дружелюбное, настраиваемое приветствие.\n"), stdout);

       puts ("");
       /* ПЕРЕВОДЧИКИ: --help вывод 3: опции 1/2
          не-оборачивать */
       fputs (_("\
       -h, --help          отобразить эту справку и выйти\n\
       -v, --version       отобразить информацию о версии и выйти\n"), stdout);

       puts ("");
       /* TRANSLATORS: --help output 4: options 2/2
          no-wrap */
       fputs (_("\
       -t, --traditional       use traditional greeting format\n\
       -n, --next-generation   use next-generation greeting format\n\
       -g, --greeting=TEXT     TEXT текст сообщения приветствия\n"), stdout);

       printf ("\n");
       /* ПЕРЕВОДЧИКИ: --help вывод 5 (завершить)
          ПЕРЕВОДЧИКИ: заполнитель указывает адрес сообщения об ошибке для
          этого приложения.  Пожалуйста, добавьте _another line_ с адресом для
          ошибок перевода.
          не-оборачивать */
       printf (_("\
     Report bugs to <%s>.\n"), PACKAGE_BUGREPORT);
     }



     /* Версия для печати и информация об авторских правах.  */

     static void
     print_version (void)
     {
       printf ("привет (GNU %s) %s\n", PACKAGE, VERSION);
       /* xgettext: no-wrap */
       puts ("");

       /* Важно отделить год от остальной части сообщения, как это сделано здесь,
       чтобы избежать необходимости повторно переводить сообщение, когда
       наступает новый год.  */
       printf (_("\
     Copyright (C) %s Free Software Foundation, Inc.\n\
     License GPLv3+: GNU GPL version 3 or later\
     <http://gnu.org/licenses/gpl.html>\n\
     Это бесплатное программное обеспечение: можно изменять и\
     распространять его.\n\
     НИКАКИХ ГАРАНТИЙ в пределах, разрешенных законом..\n"),
                   "2007");
     }


File: gnu-c-manual.info,  Node: system.h,  Prev: hello.c,  Up: A Sample Program

7.2 'system.h'
==============

     /* system.h: системно-зависимые объявления; включите это в первую очередь.
        Copyright (C) 1992, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
        2005, 2006, 2007 Free Software Foundation, Inc.

        Это бесплатное программное обеспечение; вы можете распространять и/или
        изменять его в соответствии с условиями Стандартной общественной лицензии
        GNU, опубликованной Free Software Foundation; либо версии 3, либо (по
        вашему выбору) любой более поздней версии.

        Эта программа распространяется в надежде, что она будет полезной, но
        БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ; даже без подразумеваемой гарантии
        КОММЕРЧЕСКОЙ ЦЕННОСТИ или ПРИГОДНОСТИ ДЛЯ КОНКРЕТНОЙ ЦЕЛИ. Подробнее
        смотреть Стандартную общественную лицензию GNU.

        Вы должны были получить копию Стандартной общественной лицензии GNU вместе
        с этой программой; если нет, напишите в Free Software Foundation,
        Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
        Copyright (C) 1996, 2005, 2006, 2007 Free Software Foundation, Inc.

     #ifndef HELLO_SYSTEM_H
     #define HELLO_SYSTEM_H

     /* Предположим, что заголовки ANSI C89 доступны.  */
     #include <locale.h>
     #include <stdio.h>
     #include <stdlib.h>
     #include <string.h>

     /* Используйте заголовки POSIX.  Если они недоступны, мы используем замену,
     предоставленную gnulib.  */
     #include <getopt.h>
     #include <unistd.h>

     /* Интернационализация.  */
     #include "gettext.h"
     #define _(str) gettext (str)
     #define N_(str) gettext_noop (str)

     /* Проверить на наличие ошибок при записи.  */
     #include "closeout.h"

     #endif /* HELLO_SYSTEM_H */


File: gnu-c-manual.info,  Node: Overflow,  Next: GNU Free Documentation License,  Prev: A Sample Program,  Up: Top

Appendix A Переполнение
***********************

[Это приложение, написанное в основном Полом Эггертом, взято из
руководства GNU Autoconf.  Мы подумали, что было бы полезно включить
сюда.  -TJR]

   На практике многие переносимые программы на C предполагают, что
знаковое целочисленное переполнение надежно оборачивается с
использованием арифметики с дополнением до двух.  Тем не менее, в
стандарте C говорится, что поведение программы при переполнении не
определено, и в некоторых случаях программы на C не работают в некоторых
современных реализациях, потому что их переполнениене обрабатывается,
как ожидали их авторы.  И наоборот, в целочисленном остатке со знаком
стандарт C требует поведения переполнения, которое обычно не
реализуется.  (ВопросOverflow17)

* Menu:

* Integer Overflow Basics::      Почему целочисленное переполнение - проблема
* Signed Overflow Examples::     Примеры кода, предполагающие переплнение
* Optimization and Wraparound::  Оптимизация, нарушающая циклические
                                 обработки
* Signed Overflow Advice::       Практические советы по вопросам
                                 подписанного переполнения
* Signed Integer Division::      'INT_MIN / -1' и 'INT_MIN % -1'


File: gnu-c-manual.info,  Node: Integer Overflow Basics,  Next: Signed Overflow Examples,  Up: Overflow

A.1 Основы Целочисленного Переполнения
======================================

В таких языках, как C, беззнаковое целочисленное переполнение надежно
оборачивается; например, 'UINT_MAX + 1' дает ноль.  Это гарантируется
стандартом C и переносимо на практике, если не указаны агрессивные
нестандартные параметры оптимизации, подходящие только для специальных
приложений.

   Напротив, стандарт C говорит, что целочисленное переполнение со
знаком приводит к неопределенному поведению, когда программа может
делать что угодно, включая сброс ядра или переполнение буфера.  Плохое
поведение может даже предшествовать переполнению.  Такое переполнение
может произойти во время сложения, вычитания, умножения, деления и
сдвига влево.

   Несмотря на это требование стандарта, многие программы на C
предполагают, что подписанное целочисленное переполнение молча
оборачивается по модулю двойки, используя арифметику дополнения до двух,
если приводится полученное значение к целочисленному типу со знаком или
сохраняется в целочисленной переменной со знаком.  Если используются
консервативные флаги оптимизации, такие программы обычно переносимы на
подавляющем большинстве современных платформ, за некоторыми
исключениями, обсуждаемыми позже.

   По историческим причинам стандарт C также допускает реализации с
дополнением до единици или знаковой величиной арифметики, но в настоящее
время можно с уверенностью предполагать дополнение до двух.

   Кроме того, переполнение может произойти при преобразовании значения
вне допустимого диапазона в целочисленный тип со знаком.  Здесь
стандартная реализация должна определять, что происходит, но это может
включать в себя создание исключения.  На практике все известные
реализации в этом случае поддерживают обход без вывода сообщений,
поэтому не нужно беспокоиться о других возможностях.


File: gnu-c-manual.info,  Node: Signed Overflow Examples,  Next: Optimization and Wraparound,  Prev: Integer Overflow Basics,  Up: Overflow

A.2 Примеры Кода, Предполагающего Переполнение Цикла
====================================================

Уже давно существует противоречие между тем, что стандарт C требует для
целочисленного переполнения со знаком, и тем, что обычно предполагают
программы C. Стандарт допускает агрессивную оптимизацию, основанную на
предположении, что переполнение никогда не происходит, но многие
практические программы на C полагаются на обертывание переполнения.  Эти
программы не соответствуют стандарту, но они обычно работают на
практике, потому что авторы компиляторов по понятным причинам не хотят
реализовывать оптимизацию, которая нарушит работу многих программ, если,
возможно, пользователь не укажет агрессивную оптимизацию.

   Стандарт C говорит, что если программа имеет целочисленное
переполнение со знаком, ее поведение не определено, а неопределённое
поведение может даже свидеьельствовать переполнению.  Возьмем крайний
пример:

     if (password == expected_password)
       allow_superuser_privileges ();
     else if (counter++ == INT_MAX)
       abort ();
     else
       printf ("%d несоответствие паролей\n", counter);

Если переменная типа 'int' 'counter' равняется 'INT_MAX', 'counter++'
приведёт к переполнению и поведение станет неопределённым, поэтому
стандарт C позволяет компилятору оптимизировать условие '(counter++ ==
INT_MAX)' и вызов 'abort'.  Хуже того, если более ранняя ошибка в
программе позволяет компилятору сделать вывод о том, что 'counter ==
INT_MAX' или 'counter' уже привело к переполнению, стандарт C позволяет
компилятору оптимизировать проверку пароля и генерировать код, который
безоговорочно разрешает привилегии суперпользователя.

   Несмотря на это требование стандарта, код C долгое время предполагал
циклическую арифметику после подписанного переполнения, и все известные
практические реализации C поддерживают некоторые идиомы C, которые
предполагают циклическую арифметику со знаком, даже если идиомы не
соответствуют строго стандарту.  Если ваш код похож на следующие
примеры, он почти наверняка будет работать с реальными компиляторами.

   Вот пример, полученный из реализации 'atoi' для Unix 7-го издания.
(1979-01-10):

     char *p;
     int f, n;
     ...
     while (*p >= '0' && *p <= '9')
       n = n * 10 + *p++ - '0';
     return (f ? -n : n);

Даже если входная строка находится в пределах допустимого диапазона, на
большинстве современных машин это имеет знаковое переполнение при
вычислении самого отрицательного целого числа (переполнение '-n') или
значения, близкого к крайнему целому числу (переполнение первого '+').

   Вот еще один пример, полученный из реализации 'rand' 7-го издания
(1979-01-10).  Здесь программист ожидает, что и умножение, и сложение
обернутся при переполнении:

     static long int randx = 1;
     ...
     randx = randx * 1103515245 + 12345;
     return (randx >> 16) & 077777;

   В следующем примере, полученном из реализации 'mktime' библиотеки 2.5
GNU C (2009-09-09), код предполагает циклическую арифметику в '+' для
обнаружения подписанного переполнения:

     time_t t, t1, t2;
     int sec_requested, sec_adjustment;
     ...
     t1 = t + sec_requested;
     t2 = t1 + sec_adjustment;
     if (((t1 < t) != (sec_requested < 0))
         || ((t2 < t1) != (sec_adjustment < 0)))
       return -1;

   Если код выглядит как эти примеры, он, вероятно, безопасен, даже если
он не строго соответствует стандарту C. Это может привести к мысли, что
обычно можно предполагать циклический переход при переполнении, но это
не всегда верно, как можно увидеть в следующем разделе.


File: gnu-c-manual.info,  Node: Optimization and Wraparound,  Next: Signed Overflow Advice,  Prev: Signed Overflow Examples,  Up: Overflow

A.3 Оптимизация, Которые Нарушают Циклическую Арифметику
========================================================

Компиляторы иногда создают код, несовместимый с циклической
целочисленной арифметикой.  Простым примером является алгебраическое
упрощение: компилятор может преобразовать '(i * 2000) / 1000' в 'i * 2',
потому что он предполагает, что 'i * 2000' не переполняется.  Перевод не
эквивалентен оригиналу, когда происходит переполнение: например, в
типичном случае 32-битного подписанного двойного дополнения обертывания
'int', если 'i' имеет тип 'int' и значение '1073742', исходное выражение
возвращает -2147483, но оптимизированная версия возвращает математически
правильный значение 2147484.

   Более тонко, оптимизации индукции цикла часто используют
неопределенное поведение подписанного переполнения.  Рассмотрим
следующую надуманную функцию 'sumc':

     int
     sumc (int lo, int hi)
     {
       int sum = 0;
       int i;
       for (i = lo; i <= hi; i++)
         sum ^= i * 53;
       return sum;
     }

Чтобы избежать умножения на 53 при каждом прохождении цикла,
оптимизирующий компилятор может внутренне преобразовать 'sumc' в
эквивалент следующего:

     int
     transformed_sumc (int lo, int hi)
     {
       int sum = 0;
       int hic = hi * 53;
       int ic;
       for (ic = lo * 53; ic <= hic; ic += 53)
         sum ^= ic;
       return sum;
     }

Это преобразование разрешено стандартом C, но недопустимо для арифметики
с циклическим переносом при 'INT_MAX / 53 < hi', потому что в этом
случае переполнение в вычислительных выражениях, таких как 'hi * 53',
может привести к тому, что выражение 'i <= hi' даст значение, отличное
от преобразованного выражения 'ic <= hic'.

   По этой причине компиляторы, которые используют индукцию цикла и
аналогичные методы, часто не поддерживают надежную арифметику цикла,
когда задействована переменная индукции цикла, такая как 'ic'.
Поскольку переменные индукции цикла генерируются компилятором и не
отображаются в исходном коде, не всегда легко сказать, влияет ли
проблема на ваш код.  (ВопросOverflow224)

   Вряд ли какой-либо код на самом деле зависит от арифметики
циклического преобразования в подобных случаях, поэтому на практике эти
оптимизации индукции цикла почти всегда полезны.  Однако крайние случаи
в этой области могут вызвать проблемы.  Например:

     int j;
     for (j = 1; 0 < j; j *= 2)
       test (j);

Здесь цикл пытается перебрать все степени двойки, которые может
представлять 'int', но стандарт C позволяет компилятору оптимизировать
сравнение и сгенерировать бесконечный цикл при условии, что поведение не
определено при переполнении.  На момент написания этой статьи эта
оптимизация не производилась ни одной производственной версии GCC с
'-O2', но могла выполняться другими компиляторами или более агрессивными
вариантами оптимизации GCC, и разработчики GCC не решили, будет ли она
продолжать работать с GCC и '-O2'.  .


File: gnu-c-manual.info,  Node: Signed Overflow Advice,  Next: Signed Integer Division,  Prev: Optimization and Wraparound,  Up: Overflow

A.4 Практические Советы по Вопросам Подписанного Переполнения
=============================================================

В идеале самый безопасный подход - полностью избежать переполнения целых
чисел со знаком.  Например, вместо умножения двух целых чисел со знаком
вы можете преобразовать их в целые числа без знака, умножить значения
без знака, а затем проверить, находится ли результат в диапазоне со
знаком.

   Однако переписывать код таким образом будет неудобно, особенно если
значения со знаком могут быть отрицательными.  Кроме того, это может
снизить производительность.  Использование беззнаковой арифметики для
проверки переполнения особенно болезненно при переносимости и
эффективности при работе с целочисленными типами, такими как 'uid_t',
ширина и подписи которых варьируются от платформы к платформе.

   Более того, многие приложения C повсеместно предполагают циклическое
поведение, и обычно нелегко найти и удалить все эти предположения.
Следовательно, вместо того, чтобы переписывать код, часто бывает полезно
поддерживать нестандартный код, предполагающий циклический переход при
переполнении.  В оставшейся части этого раздела делается попытка дать
практические советы для этой ситуации.

   Если ваш код хочет обнаружить целочисленное переполнение со знаком в
'sum = a + b', обычно безопасно использовать выражение, подобное '(sum <
a) != (b < 0)'.

   Если в вашем коде используется индекс цикла со знаком, убедитесь, что
индекс не может переполниться вместе со всеми выражениями со знаком,
полученными из индекса.  Вот надуманный пример проблемного кода с двумя
случаями переполнения.

     for (i = INT_MAX - 10; i <= INT_MAX; i++)
       if (i + 1 < 0)
         {
           report_overflow ();
           break;
         }

Из-за двух переполнений компилятор может оптимизировать или
преобразовать два сравнения способом, несовместимым с допущением
обертывания.

   Если в коде используется такое выражение, как '(i * 2000) / 1000', и
действительно требуется, чтобы умножение повторялось при переполнении,
используется для этого беззнаковая арифметика, например, '((int) (i *
2000u)) / 1000'.

   Если код предполагает циклическое поведение и нужно изолировать его
от любых оптимизаций GCC, которые не смогут поддерживать это поведение,
огда используется опция GCC's '-fwrapv', которая заставляет подписанное
переполнение надежно переноситься (за исключением омтатка от деления,
как обсуждается в следующем раздел).

   Если нужно выполнить перенос на платформы, где подписанное
целочисленное переполнение не надежно завершается (например, из-за
проверки аппаратного переполнения или из-за очень агрессивных
оптимизаций), следует рассмотреть возможность отладки с опцией GCC's
'-ftrapv', которая вызывает подписанное переполнение, вызывающее
исключение.


File: gnu-c-manual.info,  Node: Signed Integer Division,  Prev: Signed Overflow Advice,  Up: Overflow

A.5 Целочисленное Деление со Знаком и Целочисленное Переполнение
================================================================

Переполнение при целочисленном делении со знаком не всегда безобидно:
например, на процессорах семейства i386 деление 'INT_MIN' на '-1' дает
сигнал SIGFPE, который по умолчанию завершает программу.  Хуже того,
получение оставшейся части этих двух значений обычно дает один и тот же
сигнал для этих процессоров, даже несмотря на то, что стандарт C
требует, что бы 'INT_MIN % -1' возвращал ноль, потому что выражение не
переполняется.


File: gnu-c-manual.info,  Node: GNU Free Documentation License,  Next: Index,  Prev: Overflow,  Up: Top

GNU Free Documentation License
******************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled "History" in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          "History" section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts."  line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: gnu-c-manual.info,  Node: Index,  Prev: GNU Free Documentation License,  Up: Top

Index
*****

 [index ]
* Menu:

* accessing array elements:              Accessing Array Elements.
                                                               (line  6)
* accessing structure members:           Accessing Structure Members.
                                                               (line  6)
* accessing union members:               Accessing Union Members.
                                                               (line  6)
* arithmetic operators:                  Arithmetic Operators. (line  6)
* array elements, accessing:             Accessing Array Elements.
                                                               (line  6)
* array subscripts:                      Array Subscripts.     (line  6)
* arrays:                                Arrays.               (line  6)
* arrays as strings:                     Arrays as Strings.    (line  6)
* arrays of structures:                  Arrays of Structures. (line  6)
* arrays of unions:                      Arrays of Unions.     (line  6)
* arrays, declaring:                     Declaring Arrays.     (line  6)
* arrays, initializing:                  Initializing Arrays.  (line  6)
* arrays, multidimensional:              Multidimensional Arrays.
                                                               (line  6)
* assignment operators:                  Assignment Operators. (line  6)
* auto storage class specifier:          Storage Class Specifiers.
                                                               (line  6)
* bit fields:                            Bit Fields.           (line  6)
* bit shifting:                          Bit Shifting.         (line  6)
* bitwise logical operators:             Bitwise Logical Operators.
                                                               (line  6)
* blocks:                                Blocks.               (line  6)
* break statement:                       The break Statement.  (line  6)
* calling functions:                     Calling Functions.    (line  6)
* casts:                                 Type Casts.           (line  6)
* char data type:                        Integer Types.        (line 29)
* character constants:                   Character Constants.  (line  6)
* comma operator:                        The Comma Operator.   (line  6)
* comparison operators:                  Comparison Operators. (line  6)
* complex conjugation:                   Complex Conjugation.  (line  6)
* complex number types:                  Complex Number Types. (line  6)
* compound statements:                   Blocks.               (line  6)
* conditional expressions:               Conditional Expressions.
                                                               (line  6)
* conjugation:                           Complex Conjugation.  (line  6)
* const type qualifier:                  Type Qualifiers.      (line  6)
* constants:                             Constants.            (line  6)
* constants, character:                  Character Constants.  (line  6)
* constants, floating point:             Real Number Constants.
                                                               (line  6)
* constants, integer:                    Integer Constants.    (line  6)
* constants, real number:                Real Number Constants.
                                                               (line  6)
* continue statement:                    The continue Statement.
                                                               (line  6)
* data types:                            Data Types.           (line  6)
* data types, array:                     Arrays.               (line  6)
* data types, complex number:            Complex Number Types. (line  6)
* data types, enumeration:               Enumerations.         (line  6)
* data types, floating point:            Real Number Types.    (line  6)
* data types, integer:                   Integer Types.        (line  6)
* data types, pointer:                   Pointers.             (line  6)
* data types, primitive:                 Primitive Types.      (line  6)
* data types, real number:               Real Number Types.    (line  6)
* data types, structure:                 Structures.           (line  6)
* data types, union:                     Unions.               (line  6)
* declarations inside expressions:       Statements and Declarations in Expressions.
                                                               (line  6)
* declarations, function:                Function Declarations.
                                                               (line  6)
* declaring arrays:                      Declaring Arrays.     (line  6)
* declaring enumerations:                Declaring Enumerations.
                                                               (line  6)
* declaring pointers:                    Declaring Pointers.   (line  6)
* declaring string arrays:               Arrays as Strings.    (line  9)
* declaring structure variables:         Declaring Structure Variables.
                                                               (line  6)
* declaring structure variables after definition: Declaring Structure Variables After Definition.
                                                               (line  6)
* declaring structure variables at definition: Declaring Structure Variables at Definition.
                                                               (line  6)
* declaring union variables:             Declaring Union Variables.
                                                               (line  6)
* declaring union variables after definition: Declaring Union Variables After Definition.
                                                               (line  6)
* declaring union variables at definition: Declaring Union Variables at Definition.
                                                               (line  6)
* decrement operator:                    Incrementing and Decrementing.
                                                               (line  6)
* defining enumerations:                 Defining Enumerations.
                                                               (line  6)
* defining structures:                   Defining Structures.  (line  6)
* defining unions:                       Defining Unions.      (line  6)
* definitions, function:                 Function Definitions. (line  6)
* division, integer:                     Signed Integer Division.
                                                               (line  6)
* do statement:                          The do Statement.     (line  6)
* double data type:                      Real Number Types.    (line 22)
* else statements:                       The if Statement.     (line  6)
* enumerations:                          Enumerations.         (line  6)
* enumerations, declaring:               Declaring Enumerations.
                                                               (line  6)
* enumerations, defining:                Defining Enumerations.
                                                               (line  6)
* enumerations, incomplete:              Incomplete Types.     (line  6)
* exit status:                           The main Function.    (line 16)
* EXIT_FAILURE:                          The main Function.    (line 16)
* EXIT_SUCCESS:                          The main Function.    (line 16)
* expression statements:                 Expression Statements.
                                                               (line  6)
* expressions:                           Expressions.          (line  6)
* expressions containing statements:     Statements and Declarations in Expressions.
                                                               (line  6)
* expressions, conditional:              Conditional Expressions.
                                                               (line  6)
* extern storage class specifier:        Storage Class Specifiers.
                                                               (line  6)
* fields, bit:                           Bit Fields.           (line  6)
* float data type:                       Real Number Types.    (line 15)
* floating point constants:              Real Number Constants.
                                                               (line  6)
* floating point types:                  Real Number Types.    (line  6)
* for statement:                         The for Statement.    (line  6)
* function calls, as expressions:        Function Calls as Expressions.
                                                               (line  6)
* function declarations:                 Function Declarations.
                                                               (line  6)
* function definitions:                  Function Definitions. (line  6)
* function parameter lists, variable length: Variable Length Parameter Lists.
                                                               (line  6)
* function parameters:                   Function Parameters.  (line  6)
* function pointers, calling through:    Calling Functions Through Function Pointers.
                                                               (line  6)
* function, main:                        The main Function.    (line  6)
* functions:                             Functions.            (line  6)
* functions, calling:                    Calling Functions.    (line  6)
* functions, nested:                     Nested Functions.     (line  6)
* functions, recursive:                  Recursive Functions.  (line  6)
* functions, static:                     Static Functions.     (line  6)
* goto statement:                        The goto Statement.   (line  6)
* hello program:                         A Sample Program.     (line  6)
* hello.c:                               hello.c.              (line  6)
* identifiers:                           Identifiers.          (line  6)
* if statements:                         The if Statement.     (line  6)
* incomplete types:                      Incomplete Types.     (line  6)
* increment operator:                    Incrementing and Decrementing.
                                                               (line  6)
* indirect member access operator:       Member Access Expressions.
                                                               (line 20)
* initializing arrays:                   Initializing Arrays.  (line  6)
* initializing pointers:                 Initializing Pointers.
                                                               (line  6)
* initializing string arrays:            Arrays as Strings.    (line 17)
* initializing structure members:        Initializing Structure Members.
                                                               (line  6)
* initializing union members:            Initializing Union Members.
                                                               (line  6)
* int data type:                         Integer Types.        (line 47)
* integer constants:                     Integer Constants.    (line  6)
* integer overflow:                      Integer Overflow Basics.
                                                               (line  6)
* integer overflow <1>:                  Signed Overflow Examples.
                                                               (line  6)
* integer overflow <2>:                  Signed Overflow Advice.
                                                               (line  6)
* integer types:                         Integer Types.        (line  6)
* keywords:                              Keywords.             (line  6)
* labeled statements:                    Labels.               (line  6)
* labels:                                Labels.               (line  6)
* lexical elements:                      Lexical Elements.     (line  6)
* logical operators:                     Logical Operators.    (line  6)
* logical operators, bitwise:            Bitwise Logical Operators.
                                                               (line  6)
* long double data type:                 Real Number Types.    (line 27)
* long int data type:                    Integer Types.        (line 57)
* long long int data type:               Integer Types.        (line 73)
* loop induction:                        Optimization and Wraparound.
                                                               (line  6)
* macros, statements in expressions:     Statements and Declarations in Expressions.
                                                               (line  6)
* main function:                         The main Function.    (line  6)
* member access expressions:             Member Access Expressions.
                                                               (line  6)
* multidimensional arrays:               Multidimensional Arrays.
                                                               (line  6)
* nested functions:                      Nested Functions.     (line  6)
* null statement:                        The Null Statement.   (line  6)
* operator precedence:                   Operator Precedence.  (line  6)
* operator, decrement:                   Incrementing and Decrementing.
                                                               (line  6)
* operator, increment:                   Incrementing and Decrementing.
                                                               (line  6)
* operators:                             Expressions.          (line 27)
* operators as lexical elements:         Operators.            (line  6)
* operators, arithmetic:                 Arithmetic Operators. (line  6)
* operators, assignment:                 Assignment Operators. (line  6)
* operators, comparison:                 Comparison Operators. (line  6)
* overflow, signed integer:              Integer Overflow Basics.
                                                               (line  6)
* overflow, signed integer <1>:          Signed Overflow Examples.
                                                               (line  6)
* overflow, signed integer <2>:          Signed Overflow Advice.
                                                               (line  6)
* parameters lists, variable length:     Variable Length Parameter Lists.
                                                               (line  6)
* parameters, function:                  Function Parameters.  (line  6)
* pointer operators:                     Pointer Operators.    (line  6)
* pointers:                              Pointers.             (line  6)
* pointers to structures:                Pointers to Structures.
                                                               (line  6)
* pointers to unions:                    Pointers to Unions.   (line  6)
* pointers, declaring:                   Declaring Pointers.   (line  6)
* pointers, initializing:                Initializing Pointers.
                                                               (line  6)
* precedence, operator:                  Operator Precedence.  (line  6)
* preface:                               Preface.              (line  6)
* primitive data types:                  Primitive Types.      (line  6)
* program structure:                     Program Structure.    (line  6)
* qualifiers, type:                      Type Qualifiers.      (line  6)
* real number constants:                 Real Number Constants.
                                                               (line  6)
* real number types:                     Real Number Types.    (line  6)
* recursive functions:                   Recursive Functions.  (line  6)
* register storage class specifier:      Storage Class Specifiers.
                                                               (line  6)
* renaming types:                        Renaming Types.       (line  6)
* return statement:                      The return Statement. (line  6)
* return value of main:                  The main Function.    (line 16)
* sample program:                        A Sample Program.     (line  6)
* scope:                                 Scope.                (line  6)
* separators:                            Separators.           (line  6)
* sequence point:                        Sequence Points.      (line 12)
* shifting:                              Bit Shifting.         (line  6)
* short int data type:                   Integer Types.        (line 37)
* side effect:                           Side Effects.         (line  6)
* side effects, macro argument:          Statements and Declarations in Expressions.
                                                               (line 37)
* signed char data type:                 Integer Types.        (line 21)
* signed integer overflow:               Integer Overflow Basics.
                                                               (line  6)
* signed integer overflow <1>:           Signed Overflow Examples.
                                                               (line  6)
* signed integer overflow <2>:           Signed Overflow Advice.
                                                               (line  6)
* size of structures:                    Size of Structures.   (line  6)
* size of unions:                        Size of Unions.       (line  6)
* sizeof operator:                       The sizeof Operator.  (line  6)
* specifiers, storage class:             Storage Class Specifiers.
                                                               (line  6)
* statement, null:                       The Null Statement.   (line  6)
* statements:                            Statements.           (line  6)
* statements inside expressions:         Statements and Declarations in Expressions.
                                                               (line  6)
* statements, expression:                Expression Statements.
                                                               (line  6)
* statements, labeled:                   Labels.               (line  6)
* static functions:                      Static Functions.     (line  6)
* static linkage:                        Static Functions.     (line  6)
* static storage class specifier:        Storage Class Specifiers.
                                                               (line  6)
* storage class specifiers:              Storage Class Specifiers.
                                                               (line  6)
* string arrays, declaring:              Arrays as Strings.    (line  9)
* string arrays, initializing:           Arrays as Strings.    (line 17)
* string constants:                      String Constants.     (line  6)
* string literals:                       String Constants.     (line  6)
* strings, arrays as:                    Arrays as Strings.    (line  6)
* structure members, accessing:          Accessing Structure Members.
                                                               (line  6)
* structure members, initializing:       Initializing Structure Members.
                                                               (line  6)
* structure variables, declaring:        Declaring Structure Variables.
                                                               (line  6)
* structure variables, declaring after definition: Declaring Structure Variables After Definition.
                                                               (line  6)
* structure variables, declaring at definition: Declaring Structure Variables at Definition.
                                                               (line  6)
* structure, program:                    Program Structure.    (line  6)
* structures:                            Structures.           (line  6)
* structures, arrays of:                 Arrays of Structures. (line  6)
* structures, defining:                  Defining Structures.  (line  6)
* structures, incomplete:                Incomplete Types.     (line  6)
* structures, pointers to:               Pointers to Structures.
                                                               (line  6)
* structures, size of:                   Size of Structures.   (line  6)
* switch statement:                      The switch Statement. (line  6)
* system.h:                              system.h.             (line  6)
* ternary operator:                      Conditional Expressions.
                                                               (line  6)
* type casts:                            Type Casts.           (line  6)
* type qualifiers:                       Type Qualifiers.      (line  6)
* typedef statement:                     The typedef Statement.
                                                               (line  6)
* types:                                 Data Types.           (line  6)
* types, array:                          Arrays.               (line  6)
* types, complex number:                 Complex Number Types. (line  6)
* types, enumeration:                    Enumerations.         (line  6)
* types, floating point:                 Real Number Types.    (line  6)
* types, incomplete:                     Incomplete Types.     (line  6)
* types, integer:                        Integer Types.        (line  6)
* types, pointer:                        Pointers.             (line  6)
* types, primitive:                      Primitive Types.      (line  6)
* types, real number:                    Real Number Types.    (line  6)
* types, renaming:                       Renaming Types.       (line  6)
* types, structure:                      Structures.           (line  6)
* types, union:                          Unions.               (line  6)
* union members, accessing:              Accessing Union Members.
                                                               (line  6)
* union members, initializing:           Initializing Union Members.
                                                               (line  6)
* union variables, declaring:            Declaring Union Variables.
                                                               (line  6)
* union variables, declaring after definition: Declaring Union Variables After Definition.
                                                               (line  6)
* union variables, declaring at definition: Declaring Union Variables at Definition.
                                                               (line  6)
* unions:                                Unions.               (line  6)
* unions, arrays of:                     Arrays of Unions.     (line  6)
* unions, defining:                      Defining Unions.      (line  6)
* unions, incomplete:                    Incomplete Types.     (line  6)
* unions, pointers to:                   Pointers to Unions.   (line  6)
* unions, size of:                       Size of Unions.       (line  6)
* unsigned char data type:               Integer Types.        (line 25)
* unsigned int data type:                Integer Types.        (line 52)
* unsigned long int data type:           Integer Types.        (line 65)
* unsigned long long int data type:      Integer Types.        (line 82)
* unsigned short int data type:          Integer Types.        (line 42)
* unspecified behaviour:                 Sequence Points Constrain Expressions.
                                                               (line 88)
* variable length parameter lists:       Variable Length Parameter Lists.
                                                               (line  6)
* volatile type qualifier:               Type Qualifiers.      (line  6)
* while statement:                       The while Statement.  (line  6)
* white space:                           White Space.          (line  6)
* wraparound arithmetic:                 Integer Overflow Basics.
                                                               (line  6)
* wraparound arithmetic <1>:             Signed Overflow Examples.
                                                               (line  6)
* wraparound arithmetic <2>:             Signed Overflow Advice.
                                                               (line  6)



Tag Table:
Node: Top517
Node: Preface951
Node: Lexical Elements4490
Node: Identifiers5503
Node: Keywords6559
Node: Constants8112
Node: Integer Constants9087
Node: Character Constants12546
Node: Real Number Constants16378
Node: String Constants18655
Node: Operators22763
Node: Separators23301
Node: White Space23768
Node: Data Types26214
Node: Primitive Types26863
Node: Integer Types27233
Node: Real Number Types33898
Node: Complex Number Types38628
Ref: Complex Number Types-Footnote-139409
Node: Standard Complex Number Types39560
Node: GNU Extensions for Complex Number Types41587
Node: Enumerations44529
Node: Defining Enumerations45778
Node: Declaring Enumerations48218
Node: Unions50854
Node: Defining Unions51959
Node: Declaring Union Variables53979
Node: Declaring Union Variables at Definition54905
Node: Declaring Union Variables After Definition56016
Node: Initializing Union Members57137
Node: Accessing Union Members59165
Node: Size of Unions60222
Node: Structures61501
Node: Defining Structures62242
Node: Declaring Structure Variables64538
Node: Declaring Structure Variables at Definition65414
Node: Declaring Structure Variables After Definition66513
Node: Initializing Structure Members67539
Node: Accessing Structure Members72709
Node: Bit Fields74229
Node: Size of Structures77112
Node: Arrays79079
Node: Declaring Arrays80043
Node: Initializing Arrays81978
Node: Accessing Array Elements85913
Node: Multidimensional Arrays87265
Node: Arrays as Strings88945
Node: Arrays of Unions93303
Node: Arrays of Structures94753
Node: Pointers97314
Node: Declaring Pointers98159
Node: Initializing Pointers99899
Node: Pointers to Unions102973
Node: Pointers to Structures104735
Node: Incomplete Types106515
Node: Type Qualifiers107891
Node: Storage Class Specifiers109730
Node: Renaming Types115903
Node: Expressions and Operators116349
Node: Expressions117046
Node: Assignment Operators118879
Node: Incrementing and Decrementing123502
Node: Arithmetic Operators126195
Node: Complex Conjugation130553
Node: Comparison Operators131614
Node: Logical Operators134653
Node: Bit Shifting136904
Node: Bitwise Logical Operators139817
Node: Pointer Operators142741
Node: The sizeof Operator145303
Node: Type Casts148071
Node: Array Subscripts150522
Node: Function Calls as Expressions151605
Node: The Comma Operator152041
Node: Member Access Expressions154449
Node: Conditional Expressions155802
Node: Statements and Declarations in Expressions158435
Node: Operator Precedence162042
Node: Order of Evaluation166738
Node: Side Effects168329
Node: Sequence Points170120
Ref: Sequence Points-Footnote-1174881
Node: Sequence Points Constrain Expressions175071
Ref: Sequence Points Constrain Expressions-Footnote-1181915
Node: Sequence Points and Signal Delivery182121
Node: Statements185030
Node: Labels185816
Node: Expression Statements187109
Node: The if Statement188777
Node: The switch Statement191421
Node: The while Statement196924
Node: The do Statement198168
Node: The for Statement199387
Node: Blocks205894
Node: The Null Statement207934
Node: The goto Statement209449
Node: The break Statement211956
Node: The continue Statement213276
Node: The return Statement214093
Node: The typedef Statement217135
Node: Functions219465
Node: Function Declarations220842
Node: Function Definitions224050
Node: Calling Functions226584
Node: Function Parameters227989
Node: Variable Length Parameter Lists233904
Node: Calling Functions Through Function Pointers237895
Node: The main Function238939
Ref: The main Function-Footnote-1242774
Node: Recursive Functions243052
Node: Static Functions244450
Node: Nested Functions245593
Node: Program Structure and Scope246749
Node: Program Structure247184
Node: Scope249814
Node: A Sample Program251525
Node: hello.c252897
Node: system.h261588
Node: Overflow264116
Node: Integer Overflow Basics266203
Node: Signed Overflow Examples269622
Node: Optimization and Wraparound275544
Node: Signed Overflow Advice280501
Node: Signed Integer Division285483
Node: GNU Free Documentation License286529
Node: Index311656

End Tag Table


Local Variables:
coding: utf-8
End:
